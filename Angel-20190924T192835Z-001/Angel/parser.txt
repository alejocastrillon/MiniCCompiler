Grammar:

Rule 0     S' -> program
Rule 1     program -> decl_list
Rule 2     decl_list -> decl
Rule 3     decl_list -> decl_list decl
Rule 4     decl -> fun_decl
Rule 5     decl -> var_decl
Rule 6     var_decl -> type_spec IDENT [ ] ;
Rule 7     var_decl -> CONST type_spec IDENT = expr ;
Rule 8     var_decl -> type_spec IDENT = expr ;
Rule 9     var_decl -> type_spec IDENT ;
Rule 10    type_spec -> FLOAT
Rule 11    type_spec -> INT
Rule 12    type_spec -> BOOL
Rule 13    type_spec -> VOID
Rule 14    fun_decl -> type_spec IDENT ( params ) compound_stmt  [precedence=left, level=11]
Rule 15    params -> VOID
Rule 16    params -> param_list
Rule 17    param_list -> param
Rule 18    param_list -> param_list , param  [precedence=left, level=1]
Rule 19    param -> type_spec IDENT [ ]  [precedence=left, level=11]
Rule 20    param -> type_spec IDENT
Rule 21    compound_stmt -> { local_decls stmt_list }
Rule 22    local_decls -> empty
Rule 23    local_decls -> local_decls local_decl
Rule 24    local_decl -> type_spec IDENT [ ] ;
Rule 25    local_decl -> type_spec IDENT = expr ;
Rule 26    local_decl -> type_spec IDENT ;
Rule 27    local_decl -> CONST type_spec IDENT = expr ;
Rule 28    stmt_list -> empty
Rule 29    stmt_list -> stmt_list stmt
Rule 30    stmt -> compound_stmt
Rule 31    stmt -> break_stmt
Rule 32    stmt -> return_stmt
Rule 33    stmt -> while_stmt
Rule 34    stmt -> if_stmt
Rule 35    stmt -> expr_stmt
Rule 36    expr_stmt -> ;
Rule 37    expr_stmt -> expr ;
Rule 38    while_stmt -> WHILE ( expr ) stmt  [precedence=left, level=11]
Rule 39    if_stmt -> IF ( expr ) stmt ELSE stmt  [precedence=nonassoc, level=13]
Rule 40    if_stmt -> IF ( expr ) stmt  [precedence=left, level=11]
Rule 41    return_stmt -> RETURN expr ;
Rule 42    return_stmt -> RETURN ;
Rule 43    break_stmt -> BREAK ;
Rule 44    expr -> type_spec [ expr ]  [precedence=left, level=11]
Rule 45    expr -> CHAR_LIT
Rule 46    expr -> FLOAT_LIT
Rule 47    expr -> INT_LIT
Rule 48    expr -> FALSE
Rule 49    expr -> TRUE
Rule 50    expr -> IDENT . SIZE  [precedence=right, level=10]
Rule 51    expr -> IDENT ( args )  [precedence=left, level=11]
Rule 52    expr -> location
Rule 53    expr -> ( expr )  [precedence=left, level=11]
Rule 54    expr -> - expr  [precedence=right, level=9]
Rule 55    expr -> + expr  [precedence=right, level=9]
Rule 56    expr -> ! expr  [precedence=right, level=9]
Rule 57    expr -> expr % expr  [precedence=left, level=8]
Rule 58    expr -> expr / expr  [precedence=left, level=8]
Rule 59    expr -> expr * expr  [precedence=left, level=8]
Rule 60    expr -> expr - expr  [precedence=left, level=7]
Rule 61    expr -> expr + expr  [precedence=left, level=7]
Rule 62    expr -> expr > expr  [precedence=left, level=6]
Rule 63    expr -> expr GE expr  [precedence=left, level=6]
Rule 64    expr -> expr < expr  [precedence=left, level=6]
Rule 65    expr -> expr LE expr  [precedence=left, level=6]
Rule 66    expr -> expr NE expr  [precedence=left, level=5]
Rule 67    expr -> expr EQ expr  [precedence=left, level=5]
Rule 68    expr -> expr AND expr  [precedence=left, level=4]
Rule 69    expr -> expr OR expr  [precedence=left, level=3]
Rule 70    expr -> location = expr  [precedence=right, level=2]
Rule 71    location -> IDENT [ expr ]  [precedence=left, level=11]
Rule 72    location -> IDENT
Rule 73    arg_list -> expr
Rule 74    arg_list -> arg_list , expr  [precedence=left, level=1]
Rule 75    args -> empty
Rule 76    args -> arg_list
Rule 77    empty -> <empty>

Unused terminals:

    INC
    ADDEQ
    DIVEQ
    GT
    LT
    DEC
    STRING_LIT
    CHAR
    BOOL_LIT
    MULEQ
    DELETE
    FOR
    SUBEQ
    MODEQ
    DO
    NOT

Terminals, with rules where they appear:

!                    : 56
%                    : 57
(                    : 14 38 39 40 51 53
)                    : 14 38 39 40 51 53
*                    : 59
+                    : 55 61
,                    : 18 74
-                    : 54 60
.                    : 50
/                    : 58
;                    : 6 7 8 9 24 25 26 27 36 37 41 42 43
<                    : 64
=                    : 7 8 25 27 70
>                    : 62
ADDEQ                : 
AND                  : 68
BOOL                 : 12
BOOL_LIT             : 
BREAK                : 43
CHAR                 : 
CHAR_LIT             : 45
CONST                : 7 27
DEC                  : 
DELETE               : 
DIVEQ                : 
DO                   : 
ELSE                 : 39
EQ                   : 67
FALSE                : 48
FLOAT                : 10
FLOAT_LIT            : 46
FOR                  : 
GE                   : 63
GT                   : 
IDENT                : 6 7 8 9 14 19 20 24 25 26 27 50 51 71 72
IF                   : 39 40
INC                  : 
INT                  : 11
INT_LIT              : 47
LE                   : 65
LT                   : 
MODEQ                : 
MULEQ                : 
NE                   : 66
NOT                  : 
OR                   : 69
RETURN               : 41 42
SIZE                 : 50
STRING_LIT           : 
SUBEQ                : 
TRUE                 : 49
VOID                 : 13 15
WHILE                : 38
[                    : 6 19 24 44 71
]                    : 6 19 24 44 71
error                : 
{                    : 21
}                    : 21

Nonterminals, with rules where they appear:

arg_list             : 74 76
args                 : 51
break_stmt           : 31
compound_stmt        : 14 30
decl                 : 2 3
decl_list            : 1 3
empty                : 22 28 75
expr                 : 7 8 25 27 37 38 39 40 41 44 53 54 55 56 57 57 58 58 59 59 60 60 61 61 62 62 63 63 64 64 65 65 66 66 67 67 68 68 69 69 70 71 73 74
expr_stmt            : 35
fun_decl             : 4
if_stmt              : 34
local_decl           : 23
local_decls          : 21 23
location             : 52 70
param                : 17 18
param_list           : 16 18
params               : 14
program              : 0
return_stmt          : 32
stmt                 : 29 38 39 39 40
stmt_list            : 21 29
type_spec            : 6 7 8 9 14 19 20 24 25 26 27 44
var_decl             : 5
while_stmt           : 33


state 0

    (0) S' -> . program
    (1) program -> . decl_list
    (2) decl_list -> . decl
    (3) decl_list -> . decl_list decl
    (4) decl -> . fun_decl
    (5) decl -> . var_decl
    (14) fun_decl -> . type_spec IDENT ( params ) compound_stmt
    (6) var_decl -> . type_spec IDENT [ ] ;
    (7) var_decl -> . CONST type_spec IDENT = expr ;
    (8) var_decl -> . type_spec IDENT = expr ;
    (9) var_decl -> . type_spec IDENT ;
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
    CONST           shift and go to state 7
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10
    VOID            shift and go to state 11

    program                        shift and go to state 1
    decl_list                      shift and go to state 2
    decl                           shift and go to state 3
    fun_decl                       shift and go to state 4
    var_decl                       shift and go to state 5
    type_spec                      shift and go to state 6

state 1

    (0) S' -> program .


state 2

    (1) program -> decl_list .
    (3) decl_list -> decl_list . decl
    (4) decl -> . fun_decl
    (5) decl -> . var_decl
    (14) fun_decl -> . type_spec IDENT ( params ) compound_stmt
    (6) var_decl -> . type_spec IDENT [ ] ;
    (7) var_decl -> . CONST type_spec IDENT = expr ;
    (8) var_decl -> . type_spec IDENT = expr ;
    (9) var_decl -> . type_spec IDENT ;
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
    $end            reduce using rule 1 (program -> decl_list .)
    CONST           shift and go to state 7
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10
    VOID            shift and go to state 11

    decl                           shift and go to state 12
    fun_decl                       shift and go to state 4
    var_decl                       shift and go to state 5
    type_spec                      shift and go to state 6

state 3

    (2) decl_list -> decl .
    CONST           reduce using rule 2 (decl_list -> decl .)
    FLOAT           reduce using rule 2 (decl_list -> decl .)
    INT             reduce using rule 2 (decl_list -> decl .)
    BOOL            reduce using rule 2 (decl_list -> decl .)
    VOID            reduce using rule 2 (decl_list -> decl .)
    $end            reduce using rule 2 (decl_list -> decl .)


state 4

    (4) decl -> fun_decl .
    CONST           reduce using rule 4 (decl -> fun_decl .)
    FLOAT           reduce using rule 4 (decl -> fun_decl .)
    INT             reduce using rule 4 (decl -> fun_decl .)
    BOOL            reduce using rule 4 (decl -> fun_decl .)
    VOID            reduce using rule 4 (decl -> fun_decl .)
    $end            reduce using rule 4 (decl -> fun_decl .)


state 5

    (5) decl -> var_decl .
    CONST           reduce using rule 5 (decl -> var_decl .)
    FLOAT           reduce using rule 5 (decl -> var_decl .)
    INT             reduce using rule 5 (decl -> var_decl .)
    BOOL            reduce using rule 5 (decl -> var_decl .)
    VOID            reduce using rule 5 (decl -> var_decl .)
    $end            reduce using rule 5 (decl -> var_decl .)


state 6

    (14) fun_decl -> type_spec . IDENT ( params ) compound_stmt
    (6) var_decl -> type_spec . IDENT [ ] ;
    (8) var_decl -> type_spec . IDENT = expr ;
    (9) var_decl -> type_spec . IDENT ;
    IDENT           shift and go to state 13


state 7

    (7) var_decl -> CONST . type_spec IDENT = expr ;
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10
    VOID            shift and go to state 11

    type_spec                      shift and go to state 14

state 8

    (10) type_spec -> FLOAT .
    IDENT           reduce using rule 10 (type_spec -> FLOAT .)
    [               reduce using rule 10 (type_spec -> FLOAT .)


state 9

    (11) type_spec -> INT .
    IDENT           reduce using rule 11 (type_spec -> INT .)
    [               reduce using rule 11 (type_spec -> INT .)


state 10

    (12) type_spec -> BOOL .
    IDENT           reduce using rule 12 (type_spec -> BOOL .)
    [               reduce using rule 12 (type_spec -> BOOL .)


state 11

    (13) type_spec -> VOID .
    IDENT           reduce using rule 13 (type_spec -> VOID .)
    [               reduce using rule 13 (type_spec -> VOID .)


state 12

    (3) decl_list -> decl_list decl .
    CONST           reduce using rule 3 (decl_list -> decl_list decl .)
    FLOAT           reduce using rule 3 (decl_list -> decl_list decl .)
    INT             reduce using rule 3 (decl_list -> decl_list decl .)
    BOOL            reduce using rule 3 (decl_list -> decl_list decl .)
    VOID            reduce using rule 3 (decl_list -> decl_list decl .)
    $end            reduce using rule 3 (decl_list -> decl_list decl .)


state 13

    (14) fun_decl -> type_spec IDENT . ( params ) compound_stmt
    (6) var_decl -> type_spec IDENT . [ ] ;
    (8) var_decl -> type_spec IDENT . = expr ;
    (9) var_decl -> type_spec IDENT . ;
    (               shift and go to state 15
    [               shift and go to state 16
    =               shift and go to state 18
    ;               shift and go to state 17


state 14

    (7) var_decl -> CONST type_spec . IDENT = expr ;
    IDENT           shift and go to state 19


state 15

    (14) fun_decl -> type_spec IDENT ( . params ) compound_stmt
    (15) params -> . VOID
    (16) params -> . param_list
    (17) param_list -> . param
    (18) param_list -> . param_list , param
    (19) param -> . type_spec IDENT [ ]
    (20) param -> . type_spec IDENT
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
    VOID            shift and go to state 22
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10

    type_spec                      shift and go to state 20
    params                         shift and go to state 21
    param_list                     shift and go to state 23
    param                          shift and go to state 24

state 16

    (6) var_decl -> type_spec IDENT [ . ] ;
    ]               shift and go to state 25


state 17

    (9) var_decl -> type_spec IDENT ; .
    CONST           reduce using rule 9 (var_decl -> type_spec IDENT ; .)
    FLOAT           reduce using rule 9 (var_decl -> type_spec IDENT ; .)
    INT             reduce using rule 9 (var_decl -> type_spec IDENT ; .)
    BOOL            reduce using rule 9 (var_decl -> type_spec IDENT ; .)
    VOID            reduce using rule 9 (var_decl -> type_spec IDENT ; .)
    $end            reduce using rule 9 (var_decl -> type_spec IDENT ; .)


state 18

    (8) var_decl -> type_spec IDENT = . expr ;
    (44) expr -> . type_spec [ expr ]
    (45) expr -> . CHAR_LIT
    (46) expr -> . FLOAT_LIT
    (47) expr -> . INT_LIT
    (48) expr -> . FALSE
    (49) expr -> . TRUE
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . location
    (53) expr -> . ( expr )
    (54) expr -> . - expr
    (55) expr -> . + expr
    (56) expr -> . ! expr
    (57) expr -> . expr % expr
    (58) expr -> . expr / expr
    (59) expr -> . expr * expr
    (60) expr -> . expr - expr
    (61) expr -> . expr + expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GE expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr NE expr
    (67) expr -> . expr EQ expr
    (68) expr -> . expr AND expr
    (69) expr -> . expr OR expr
    (70) expr -> . location = expr
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
    (71) location -> . IDENT [ expr ]
    (72) location -> . IDENT
    CHAR_LIT        shift and go to state 29
    FLOAT_LIT       shift and go to state 30
    INT_LIT         shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    IDENT           shift and go to state 27
    (               shift and go to state 34
    -               shift and go to state 36
    +               shift and go to state 37
    !               shift and go to state 38
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10
    VOID            shift and go to state 11

    type_spec                      shift and go to state 26
    expr                           shift and go to state 28
    location                       shift and go to state 35

state 19

    (7) var_decl -> CONST type_spec IDENT . = expr ;
    =               shift and go to state 39


state 20

    (19) param -> type_spec . IDENT [ ]
    (20) param -> type_spec . IDENT
    IDENT           shift and go to state 40


state 21

    (14) fun_decl -> type_spec IDENT ( params . ) compound_stmt
    )               shift and go to state 41


state 22

    (15) params -> VOID .
    (13) type_spec -> VOID .
    )               reduce using rule 15 (params -> VOID .)
    IDENT           reduce using rule 13 (type_spec -> VOID .)


state 23

    (16) params -> param_list .
    (18) param_list -> param_list . , param
    )               reduce using rule 16 (params -> param_list .)
    ,               shift and go to state 42


state 24

    (17) param_list -> param .
    ,               reduce using rule 17 (param_list -> param .)
    )               reduce using rule 17 (param_list -> param .)


state 25

    (6) var_decl -> type_spec IDENT [ ] . ;
    ;               shift and go to state 43


state 26

    (44) expr -> type_spec . [ expr ]
    [               shift and go to state 44


state 27

    (50) expr -> IDENT . . SIZE
    (51) expr -> IDENT . ( args )
    (71) location -> IDENT . [ expr ]
    (72) location -> IDENT .
    .               shift and go to state 45
    (               shift and go to state 46
    [               shift and go to state 47
    =               reduce using rule 72 (location -> IDENT .)
    ;               reduce using rule 72 (location -> IDENT .)
    %               reduce using rule 72 (location -> IDENT .)
    /               reduce using rule 72 (location -> IDENT .)
    *               reduce using rule 72 (location -> IDENT .)
    -               reduce using rule 72 (location -> IDENT .)
    +               reduce using rule 72 (location -> IDENT .)
    >               reduce using rule 72 (location -> IDENT .)
    GE              reduce using rule 72 (location -> IDENT .)
    <               reduce using rule 72 (location -> IDENT .)
    LE              reduce using rule 72 (location -> IDENT .)
    NE              reduce using rule 72 (location -> IDENT .)
    EQ              reduce using rule 72 (location -> IDENT .)
    AND             reduce using rule 72 (location -> IDENT .)
    OR              reduce using rule 72 (location -> IDENT .)
    )               reduce using rule 72 (location -> IDENT .)
    ]               reduce using rule 72 (location -> IDENT .)
    ,               reduce using rule 72 (location -> IDENT .)


state 28

    (8) var_decl -> type_spec IDENT = expr . ;
    (57) expr -> expr . % expr
    (58) expr -> expr . / expr
    (59) expr -> expr . * expr
    (60) expr -> expr . - expr
    (61) expr -> expr . + expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GE expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . NE expr
    (67) expr -> expr . EQ expr
    (68) expr -> expr . AND expr
    (69) expr -> expr . OR expr
    ;               shift and go to state 48
    %               shift and go to state 49
    /               shift and go to state 50
    *               shift and go to state 51
    -               shift and go to state 52
    +               shift and go to state 53
    >               shift and go to state 54
    GE              shift and go to state 55
    <               shift and go to state 56
    LE              shift and go to state 57
    NE              shift and go to state 58
    EQ              shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61


state 29

    (45) expr -> CHAR_LIT .
    ;               reduce using rule 45 (expr -> CHAR_LIT .)
    %               reduce using rule 45 (expr -> CHAR_LIT .)
    /               reduce using rule 45 (expr -> CHAR_LIT .)
    *               reduce using rule 45 (expr -> CHAR_LIT .)
    -               reduce using rule 45 (expr -> CHAR_LIT .)
    +               reduce using rule 45 (expr -> CHAR_LIT .)
    >               reduce using rule 45 (expr -> CHAR_LIT .)
    GE              reduce using rule 45 (expr -> CHAR_LIT .)
    <               reduce using rule 45 (expr -> CHAR_LIT .)
    LE              reduce using rule 45 (expr -> CHAR_LIT .)
    NE              reduce using rule 45 (expr -> CHAR_LIT .)
    EQ              reduce using rule 45 (expr -> CHAR_LIT .)
    AND             reduce using rule 45 (expr -> CHAR_LIT .)
    OR              reduce using rule 45 (expr -> CHAR_LIT .)
    )               reduce using rule 45 (expr -> CHAR_LIT .)
    ]               reduce using rule 45 (expr -> CHAR_LIT .)
    ,               reduce using rule 45 (expr -> CHAR_LIT .)


state 30

    (46) expr -> FLOAT_LIT .
    ;               reduce using rule 46 (expr -> FLOAT_LIT .)
    %               reduce using rule 46 (expr -> FLOAT_LIT .)
    /               reduce using rule 46 (expr -> FLOAT_LIT .)
    *               reduce using rule 46 (expr -> FLOAT_LIT .)
    -               reduce using rule 46 (expr -> FLOAT_LIT .)
    +               reduce using rule 46 (expr -> FLOAT_LIT .)
    >               reduce using rule 46 (expr -> FLOAT_LIT .)
    GE              reduce using rule 46 (expr -> FLOAT_LIT .)
    <               reduce using rule 46 (expr -> FLOAT_LIT .)
    LE              reduce using rule 46 (expr -> FLOAT_LIT .)
    NE              reduce using rule 46 (expr -> FLOAT_LIT .)
    EQ              reduce using rule 46 (expr -> FLOAT_LIT .)
    AND             reduce using rule 46 (expr -> FLOAT_LIT .)
    OR              reduce using rule 46 (expr -> FLOAT_LIT .)
    )               reduce using rule 46 (expr -> FLOAT_LIT .)
    ]               reduce using rule 46 (expr -> FLOAT_LIT .)
    ,               reduce using rule 46 (expr -> FLOAT_LIT .)


state 31

    (47) expr -> INT_LIT .
    ;               reduce using rule 47 (expr -> INT_LIT .)
    %               reduce using rule 47 (expr -> INT_LIT .)
    /               reduce using rule 47 (expr -> INT_LIT .)
    *               reduce using rule 47 (expr -> INT_LIT .)
    -               reduce using rule 47 (expr -> INT_LIT .)
    +               reduce using rule 47 (expr -> INT_LIT .)
    >               reduce using rule 47 (expr -> INT_LIT .)
    GE              reduce using rule 47 (expr -> INT_LIT .)
    <               reduce using rule 47 (expr -> INT_LIT .)
    LE              reduce using rule 47 (expr -> INT_LIT .)
    NE              reduce using rule 47 (expr -> INT_LIT .)
    EQ              reduce using rule 47 (expr -> INT_LIT .)
    AND             reduce using rule 47 (expr -> INT_LIT .)
    OR              reduce using rule 47 (expr -> INT_LIT .)
    )               reduce using rule 47 (expr -> INT_LIT .)
    ]               reduce using rule 47 (expr -> INT_LIT .)
    ,               reduce using rule 47 (expr -> INT_LIT .)


state 32

    (48) expr -> FALSE .
    ;               reduce using rule 48 (expr -> FALSE .)
    %               reduce using rule 48 (expr -> FALSE .)
    /               reduce using rule 48 (expr -> FALSE .)
    *               reduce using rule 48 (expr -> FALSE .)
    -               reduce using rule 48 (expr -> FALSE .)
    +               reduce using rule 48 (expr -> FALSE .)
    >               reduce using rule 48 (expr -> FALSE .)
    GE              reduce using rule 48 (expr -> FALSE .)
    <               reduce using rule 48 (expr -> FALSE .)
    LE              reduce using rule 48 (expr -> FALSE .)
    NE              reduce using rule 48 (expr -> FALSE .)
    EQ              reduce using rule 48 (expr -> FALSE .)
    AND             reduce using rule 48 (expr -> FALSE .)
    OR              reduce using rule 48 (expr -> FALSE .)
    )               reduce using rule 48 (expr -> FALSE .)
    ]               reduce using rule 48 (expr -> FALSE .)
    ,               reduce using rule 48 (expr -> FALSE .)


state 33

    (49) expr -> TRUE .
    ;               reduce using rule 49 (expr -> TRUE .)
    %               reduce using rule 49 (expr -> TRUE .)
    /               reduce using rule 49 (expr -> TRUE .)
    *               reduce using rule 49 (expr -> TRUE .)
    -               reduce using rule 49 (expr -> TRUE .)
    +               reduce using rule 49 (expr -> TRUE .)
    >               reduce using rule 49 (expr -> TRUE .)
    GE              reduce using rule 49 (expr -> TRUE .)
    <               reduce using rule 49 (expr -> TRUE .)
    LE              reduce using rule 49 (expr -> TRUE .)
    NE              reduce using rule 49 (expr -> TRUE .)
    EQ              reduce using rule 49 (expr -> TRUE .)
    AND             reduce using rule 49 (expr -> TRUE .)
    OR              reduce using rule 49 (expr -> TRUE .)
    )               reduce using rule 49 (expr -> TRUE .)
    ]               reduce using rule 49 (expr -> TRUE .)
    ,               reduce using rule 49 (expr -> TRUE .)


state 34

    (53) expr -> ( . expr )
    (44) expr -> . type_spec [ expr ]
    (45) expr -> . CHAR_LIT
    (46) expr -> . FLOAT_LIT
    (47) expr -> . INT_LIT
    (48) expr -> . FALSE
    (49) expr -> . TRUE
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . location
    (53) expr -> . ( expr )
    (54) expr -> . - expr
    (55) expr -> . + expr
    (56) expr -> . ! expr
    (57) expr -> . expr % expr
    (58) expr -> . expr / expr
    (59) expr -> . expr * expr
    (60) expr -> . expr - expr
    (61) expr -> . expr + expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GE expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr NE expr
    (67) expr -> . expr EQ expr
    (68) expr -> . expr AND expr
    (69) expr -> . expr OR expr
    (70) expr -> . location = expr
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
    (71) location -> . IDENT [ expr ]
    (72) location -> . IDENT
    CHAR_LIT        shift and go to state 29
    FLOAT_LIT       shift and go to state 30
    INT_LIT         shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    IDENT           shift and go to state 27
    (               shift and go to state 34
    -               shift and go to state 36
    +               shift and go to state 37
    !               shift and go to state 38
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10
    VOID            shift and go to state 11

    expr                           shift and go to state 62
    type_spec                      shift and go to state 26
    location                       shift and go to state 35

state 35

    (52) expr -> location .
    (70) expr -> location . = expr
    ;               reduce using rule 52 (expr -> location .)
    %               reduce using rule 52 (expr -> location .)
    /               reduce using rule 52 (expr -> location .)
    *               reduce using rule 52 (expr -> location .)
    -               reduce using rule 52 (expr -> location .)
    +               reduce using rule 52 (expr -> location .)
    >               reduce using rule 52 (expr -> location .)
    GE              reduce using rule 52 (expr -> location .)
    <               reduce using rule 52 (expr -> location .)
    LE              reduce using rule 52 (expr -> location .)
    NE              reduce using rule 52 (expr -> location .)
    EQ              reduce using rule 52 (expr -> location .)
    AND             reduce using rule 52 (expr -> location .)
    OR              reduce using rule 52 (expr -> location .)
    )               reduce using rule 52 (expr -> location .)
    ]               reduce using rule 52 (expr -> location .)
    ,               reduce using rule 52 (expr -> location .)
    =               shift and go to state 63


state 36

    (54) expr -> - . expr
    (44) expr -> . type_spec [ expr ]
    (45) expr -> . CHAR_LIT
    (46) expr -> . FLOAT_LIT
    (47) expr -> . INT_LIT
    (48) expr -> . FALSE
    (49) expr -> . TRUE
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . location
    (53) expr -> . ( expr )
    (54) expr -> . - expr
    (55) expr -> . + expr
    (56) expr -> . ! expr
    (57) expr -> . expr % expr
    (58) expr -> . expr / expr
    (59) expr -> . expr * expr
    (60) expr -> . expr - expr
    (61) expr -> . expr + expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GE expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr NE expr
    (67) expr -> . expr EQ expr
    (68) expr -> . expr AND expr
    (69) expr -> . expr OR expr
    (70) expr -> . location = expr
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
    (71) location -> . IDENT [ expr ]
    (72) location -> . IDENT
    CHAR_LIT        shift and go to state 29
    FLOAT_LIT       shift and go to state 30
    INT_LIT         shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    IDENT           shift and go to state 27
    (               shift and go to state 34
    -               shift and go to state 36
    +               shift and go to state 37
    !               shift and go to state 38
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10
    VOID            shift and go to state 11

    expr                           shift and go to state 64
    type_spec                      shift and go to state 26
    location                       shift and go to state 35

state 37

    (55) expr -> + . expr
    (44) expr -> . type_spec [ expr ]
    (45) expr -> . CHAR_LIT
    (46) expr -> . FLOAT_LIT
    (47) expr -> . INT_LIT
    (48) expr -> . FALSE
    (49) expr -> . TRUE
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . location
    (53) expr -> . ( expr )
    (54) expr -> . - expr
    (55) expr -> . + expr
    (56) expr -> . ! expr
    (57) expr -> . expr % expr
    (58) expr -> . expr / expr
    (59) expr -> . expr * expr
    (60) expr -> . expr - expr
    (61) expr -> . expr + expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GE expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr NE expr
    (67) expr -> . expr EQ expr
    (68) expr -> . expr AND expr
    (69) expr -> . expr OR expr
    (70) expr -> . location = expr
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
    (71) location -> . IDENT [ expr ]
    (72) location -> . IDENT
    CHAR_LIT        shift and go to state 29
    FLOAT_LIT       shift and go to state 30
    INT_LIT         shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    IDENT           shift and go to state 27
    (               shift and go to state 34
    -               shift and go to state 36
    +               shift and go to state 37
    !               shift and go to state 38
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10
    VOID            shift and go to state 11

    expr                           shift and go to state 65
    type_spec                      shift and go to state 26
    location                       shift and go to state 35

state 38

    (56) expr -> ! . expr
    (44) expr -> . type_spec [ expr ]
    (45) expr -> . CHAR_LIT
    (46) expr -> . FLOAT_LIT
    (47) expr -> . INT_LIT
    (48) expr -> . FALSE
    (49) expr -> . TRUE
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . location
    (53) expr -> . ( expr )
    (54) expr -> . - expr
    (55) expr -> . + expr
    (56) expr -> . ! expr
    (57) expr -> . expr % expr
    (58) expr -> . expr / expr
    (59) expr -> . expr * expr
    (60) expr -> . expr - expr
    (61) expr -> . expr + expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GE expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr NE expr
    (67) expr -> . expr EQ expr
    (68) expr -> . expr AND expr
    (69) expr -> . expr OR expr
    (70) expr -> . location = expr
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
    (71) location -> . IDENT [ expr ]
    (72) location -> . IDENT
    CHAR_LIT        shift and go to state 29
    FLOAT_LIT       shift and go to state 30
    INT_LIT         shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    IDENT           shift and go to state 27
    (               shift and go to state 34
    -               shift and go to state 36
    +               shift and go to state 37
    !               shift and go to state 38
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10
    VOID            shift and go to state 11

    expr                           shift and go to state 66
    type_spec                      shift and go to state 26
    location                       shift and go to state 35

state 39

    (7) var_decl -> CONST type_spec IDENT = . expr ;
    (44) expr -> . type_spec [ expr ]
    (45) expr -> . CHAR_LIT
    (46) expr -> . FLOAT_LIT
    (47) expr -> . INT_LIT
    (48) expr -> . FALSE
    (49) expr -> . TRUE
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . location
    (53) expr -> . ( expr )
    (54) expr -> . - expr
    (55) expr -> . + expr
    (56) expr -> . ! expr
    (57) expr -> . expr % expr
    (58) expr -> . expr / expr
    (59) expr -> . expr * expr
    (60) expr -> . expr - expr
    (61) expr -> . expr + expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GE expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr NE expr
    (67) expr -> . expr EQ expr
    (68) expr -> . expr AND expr
    (69) expr -> . expr OR expr
    (70) expr -> . location = expr
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
    (71) location -> . IDENT [ expr ]
    (72) location -> . IDENT
    CHAR_LIT        shift and go to state 29
    FLOAT_LIT       shift and go to state 30
    INT_LIT         shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    IDENT           shift and go to state 27
    (               shift and go to state 34
    -               shift and go to state 36
    +               shift and go to state 37
    !               shift and go to state 38
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10
    VOID            shift and go to state 11

    type_spec                      shift and go to state 26
    expr                           shift and go to state 67
    location                       shift and go to state 35

state 40

    (19) param -> type_spec IDENT . [ ]
    (20) param -> type_spec IDENT .
    [               shift and go to state 68
    ,               reduce using rule 20 (param -> type_spec IDENT .)
    )               reduce using rule 20 (param -> type_spec IDENT .)


state 41

    (14) fun_decl -> type_spec IDENT ( params ) . compound_stmt
    (21) compound_stmt -> . { local_decls stmt_list }
    {               shift and go to state 70

    compound_stmt                  shift and go to state 69

state 42

    (18) param_list -> param_list , . param
    (19) param -> . type_spec IDENT [ ]
    (20) param -> . type_spec IDENT
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10
    VOID            shift and go to state 11

    param                          shift and go to state 71
    type_spec                      shift and go to state 20

state 43

    (6) var_decl -> type_spec IDENT [ ] ; .
    CONST           reduce using rule 6 (var_decl -> type_spec IDENT [ ] ; .)
    FLOAT           reduce using rule 6 (var_decl -> type_spec IDENT [ ] ; .)
    INT             reduce using rule 6 (var_decl -> type_spec IDENT [ ] ; .)
    BOOL            reduce using rule 6 (var_decl -> type_spec IDENT [ ] ; .)
    VOID            reduce using rule 6 (var_decl -> type_spec IDENT [ ] ; .)
    $end            reduce using rule 6 (var_decl -> type_spec IDENT [ ] ; .)


state 44

    (44) expr -> type_spec [ . expr ]
    (44) expr -> . type_spec [ expr ]
    (45) expr -> . CHAR_LIT
    (46) expr -> . FLOAT_LIT
    (47) expr -> . INT_LIT
    (48) expr -> . FALSE
    (49) expr -> . TRUE
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . location
    (53) expr -> . ( expr )
    (54) expr -> . - expr
    (55) expr -> . + expr
    (56) expr -> . ! expr
    (57) expr -> . expr % expr
    (58) expr -> . expr / expr
    (59) expr -> . expr * expr
    (60) expr -> . expr - expr
    (61) expr -> . expr + expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GE expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr NE expr
    (67) expr -> . expr EQ expr
    (68) expr -> . expr AND expr
    (69) expr -> . expr OR expr
    (70) expr -> . location = expr
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
    (71) location -> . IDENT [ expr ]
    (72) location -> . IDENT
    CHAR_LIT        shift and go to state 29
    FLOAT_LIT       shift and go to state 30
    INT_LIT         shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    IDENT           shift and go to state 27
    (               shift and go to state 34
    -               shift and go to state 36
    +               shift and go to state 37
    !               shift and go to state 38
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10
    VOID            shift and go to state 11

    type_spec                      shift and go to state 26
    expr                           shift and go to state 72
    location                       shift and go to state 35

state 45

    (50) expr -> IDENT . . SIZE
    SIZE            shift and go to state 73


state 46

    (51) expr -> IDENT ( . args )
    (75) args -> . empty
    (76) args -> . arg_list
    (77) empty -> .
    (73) arg_list -> . expr
    (74) arg_list -> . arg_list , expr
    (44) expr -> . type_spec [ expr ]
    (45) expr -> . CHAR_LIT
    (46) expr -> . FLOAT_LIT
    (47) expr -> . INT_LIT
    (48) expr -> . FALSE
    (49) expr -> . TRUE
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . location
    (53) expr -> . ( expr )
    (54) expr -> . - expr
    (55) expr -> . + expr
    (56) expr -> . ! expr
    (57) expr -> . expr % expr
    (58) expr -> . expr / expr
    (59) expr -> . expr * expr
    (60) expr -> . expr - expr
    (61) expr -> . expr + expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GE expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr NE expr
    (67) expr -> . expr EQ expr
    (68) expr -> . expr AND expr
    (69) expr -> . expr OR expr
    (70) expr -> . location = expr
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
    (71) location -> . IDENT [ expr ]
    (72) location -> . IDENT
    )               reduce using rule 77 (empty -> .)
    CHAR_LIT        shift and go to state 29
    FLOAT_LIT       shift and go to state 30
    INT_LIT         shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    IDENT           shift and go to state 27
    (               shift and go to state 34
    -               shift and go to state 36
    +               shift and go to state 37
    !               shift and go to state 38
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10
    VOID            shift and go to state 11

    args                           shift and go to state 74
    empty                          shift and go to state 75
    arg_list                       shift and go to state 76
    expr                           shift and go to state 77
    type_spec                      shift and go to state 26
    location                       shift and go to state 35

state 47

    (71) location -> IDENT [ . expr ]
    (44) expr -> . type_spec [ expr ]
    (45) expr -> . CHAR_LIT
    (46) expr -> . FLOAT_LIT
    (47) expr -> . INT_LIT
    (48) expr -> . FALSE
    (49) expr -> . TRUE
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . location
    (53) expr -> . ( expr )
    (54) expr -> . - expr
    (55) expr -> . + expr
    (56) expr -> . ! expr
    (57) expr -> . expr % expr
    (58) expr -> . expr / expr
    (59) expr -> . expr * expr
    (60) expr -> . expr - expr
    (61) expr -> . expr + expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GE expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr NE expr
    (67) expr -> . expr EQ expr
    (68) expr -> . expr AND expr
    (69) expr -> . expr OR expr
    (70) expr -> . location = expr
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
    (71) location -> . IDENT [ expr ]
    (72) location -> . IDENT
    CHAR_LIT        shift and go to state 29
    FLOAT_LIT       shift and go to state 30
    INT_LIT         shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    IDENT           shift and go to state 27
    (               shift and go to state 34
    -               shift and go to state 36
    +               shift and go to state 37
    !               shift and go to state 38
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10
    VOID            shift and go to state 11

    expr                           shift and go to state 78
    type_spec                      shift and go to state 26
    location                       shift and go to state 35

state 48

    (8) var_decl -> type_spec IDENT = expr ; .
    CONST           reduce using rule 8 (var_decl -> type_spec IDENT = expr ; .)
    FLOAT           reduce using rule 8 (var_decl -> type_spec IDENT = expr ; .)
    INT             reduce using rule 8 (var_decl -> type_spec IDENT = expr ; .)
    BOOL            reduce using rule 8 (var_decl -> type_spec IDENT = expr ; .)
    VOID            reduce using rule 8 (var_decl -> type_spec IDENT = expr ; .)
    $end            reduce using rule 8 (var_decl -> type_spec IDENT = expr ; .)


state 49

    (57) expr -> expr % . expr
    (44) expr -> . type_spec [ expr ]
    (45) expr -> . CHAR_LIT
    (46) expr -> . FLOAT_LIT
    (47) expr -> . INT_LIT
    (48) expr -> . FALSE
    (49) expr -> . TRUE
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . location
    (53) expr -> . ( expr )
    (54) expr -> . - expr
    (55) expr -> . + expr
    (56) expr -> . ! expr
    (57) expr -> . expr % expr
    (58) expr -> . expr / expr
    (59) expr -> . expr * expr
    (60) expr -> . expr - expr
    (61) expr -> . expr + expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GE expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr NE expr
    (67) expr -> . expr EQ expr
    (68) expr -> . expr AND expr
    (69) expr -> . expr OR expr
    (70) expr -> . location = expr
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
    (71) location -> . IDENT [ expr ]
    (72) location -> . IDENT
    CHAR_LIT        shift and go to state 29
    FLOAT_LIT       shift and go to state 30
    INT_LIT         shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    IDENT           shift and go to state 27
    (               shift and go to state 34
    -               shift and go to state 36
    +               shift and go to state 37
    !               shift and go to state 38
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10
    VOID            shift and go to state 11

    expr                           shift and go to state 79
    type_spec                      shift and go to state 26
    location                       shift and go to state 35

state 50

    (58) expr -> expr / . expr
    (44) expr -> . type_spec [ expr ]
    (45) expr -> . CHAR_LIT
    (46) expr -> . FLOAT_LIT
    (47) expr -> . INT_LIT
    (48) expr -> . FALSE
    (49) expr -> . TRUE
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . location
    (53) expr -> . ( expr )
    (54) expr -> . - expr
    (55) expr -> . + expr
    (56) expr -> . ! expr
    (57) expr -> . expr % expr
    (58) expr -> . expr / expr
    (59) expr -> . expr * expr
    (60) expr -> . expr - expr
    (61) expr -> . expr + expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GE expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr NE expr
    (67) expr -> . expr EQ expr
    (68) expr -> . expr AND expr
    (69) expr -> . expr OR expr
    (70) expr -> . location = expr
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
    (71) location -> . IDENT [ expr ]
    (72) location -> . IDENT
    CHAR_LIT        shift and go to state 29
    FLOAT_LIT       shift and go to state 30
    INT_LIT         shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    IDENT           shift and go to state 27
    (               shift and go to state 34
    -               shift and go to state 36
    +               shift and go to state 37
    !               shift and go to state 38
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10
    VOID            shift and go to state 11

    expr                           shift and go to state 80
    type_spec                      shift and go to state 26
    location                       shift and go to state 35

state 51

    (59) expr -> expr * . expr
    (44) expr -> . type_spec [ expr ]
    (45) expr -> . CHAR_LIT
    (46) expr -> . FLOAT_LIT
    (47) expr -> . INT_LIT
    (48) expr -> . FALSE
    (49) expr -> . TRUE
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . location
    (53) expr -> . ( expr )
    (54) expr -> . - expr
    (55) expr -> . + expr
    (56) expr -> . ! expr
    (57) expr -> . expr % expr
    (58) expr -> . expr / expr
    (59) expr -> . expr * expr
    (60) expr -> . expr - expr
    (61) expr -> . expr + expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GE expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr NE expr
    (67) expr -> . expr EQ expr
    (68) expr -> . expr AND expr
    (69) expr -> . expr OR expr
    (70) expr -> . location = expr
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
    (71) location -> . IDENT [ expr ]
    (72) location -> . IDENT
    CHAR_LIT        shift and go to state 29
    FLOAT_LIT       shift and go to state 30
    INT_LIT         shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    IDENT           shift and go to state 27
    (               shift and go to state 34
    -               shift and go to state 36
    +               shift and go to state 37
    !               shift and go to state 38
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10
    VOID            shift and go to state 11

    expr                           shift and go to state 81
    type_spec                      shift and go to state 26
    location                       shift and go to state 35

state 52

    (60) expr -> expr - . expr
    (44) expr -> . type_spec [ expr ]
    (45) expr -> . CHAR_LIT
    (46) expr -> . FLOAT_LIT
    (47) expr -> . INT_LIT
    (48) expr -> . FALSE
    (49) expr -> . TRUE
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . location
    (53) expr -> . ( expr )
    (54) expr -> . - expr
    (55) expr -> . + expr
    (56) expr -> . ! expr
    (57) expr -> . expr % expr
    (58) expr -> . expr / expr
    (59) expr -> . expr * expr
    (60) expr -> . expr - expr
    (61) expr -> . expr + expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GE expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr NE expr
    (67) expr -> . expr EQ expr
    (68) expr -> . expr AND expr
    (69) expr -> . expr OR expr
    (70) expr -> . location = expr
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
    (71) location -> . IDENT [ expr ]
    (72) location -> . IDENT
    CHAR_LIT        shift and go to state 29
    FLOAT_LIT       shift and go to state 30
    INT_LIT         shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    IDENT           shift and go to state 27
    (               shift and go to state 34
    -               shift and go to state 36
    +               shift and go to state 37
    !               shift and go to state 38
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10
    VOID            shift and go to state 11

    expr                           shift and go to state 82
    type_spec                      shift and go to state 26
    location                       shift and go to state 35

state 53

    (61) expr -> expr + . expr
    (44) expr -> . type_spec [ expr ]
    (45) expr -> . CHAR_LIT
    (46) expr -> . FLOAT_LIT
    (47) expr -> . INT_LIT
    (48) expr -> . FALSE
    (49) expr -> . TRUE
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . location
    (53) expr -> . ( expr )
    (54) expr -> . - expr
    (55) expr -> . + expr
    (56) expr -> . ! expr
    (57) expr -> . expr % expr
    (58) expr -> . expr / expr
    (59) expr -> . expr * expr
    (60) expr -> . expr - expr
    (61) expr -> . expr + expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GE expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr NE expr
    (67) expr -> . expr EQ expr
    (68) expr -> . expr AND expr
    (69) expr -> . expr OR expr
    (70) expr -> . location = expr
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
    (71) location -> . IDENT [ expr ]
    (72) location -> . IDENT
    CHAR_LIT        shift and go to state 29
    FLOAT_LIT       shift and go to state 30
    INT_LIT         shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    IDENT           shift and go to state 27
    (               shift and go to state 34
    -               shift and go to state 36
    +               shift and go to state 37
    !               shift and go to state 38
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10
    VOID            shift and go to state 11

    expr                           shift and go to state 83
    type_spec                      shift and go to state 26
    location                       shift and go to state 35

state 54

    (62) expr -> expr > . expr
    (44) expr -> . type_spec [ expr ]
    (45) expr -> . CHAR_LIT
    (46) expr -> . FLOAT_LIT
    (47) expr -> . INT_LIT
    (48) expr -> . FALSE
    (49) expr -> . TRUE
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . location
    (53) expr -> . ( expr )
    (54) expr -> . - expr
    (55) expr -> . + expr
    (56) expr -> . ! expr
    (57) expr -> . expr % expr
    (58) expr -> . expr / expr
    (59) expr -> . expr * expr
    (60) expr -> . expr - expr
    (61) expr -> . expr + expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GE expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr NE expr
    (67) expr -> . expr EQ expr
    (68) expr -> . expr AND expr
    (69) expr -> . expr OR expr
    (70) expr -> . location = expr
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
    (71) location -> . IDENT [ expr ]
    (72) location -> . IDENT
    CHAR_LIT        shift and go to state 29
    FLOAT_LIT       shift and go to state 30
    INT_LIT         shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    IDENT           shift and go to state 27
    (               shift and go to state 34
    -               shift and go to state 36
    +               shift and go to state 37
    !               shift and go to state 38
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10
    VOID            shift and go to state 11

    expr                           shift and go to state 84
    type_spec                      shift and go to state 26
    location                       shift and go to state 35

state 55

    (63) expr -> expr GE . expr
    (44) expr -> . type_spec [ expr ]
    (45) expr -> . CHAR_LIT
    (46) expr -> . FLOAT_LIT
    (47) expr -> . INT_LIT
    (48) expr -> . FALSE
    (49) expr -> . TRUE
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . location
    (53) expr -> . ( expr )
    (54) expr -> . - expr
    (55) expr -> . + expr
    (56) expr -> . ! expr
    (57) expr -> . expr % expr
    (58) expr -> . expr / expr
    (59) expr -> . expr * expr
    (60) expr -> . expr - expr
    (61) expr -> . expr + expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GE expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr NE expr
    (67) expr -> . expr EQ expr
    (68) expr -> . expr AND expr
    (69) expr -> . expr OR expr
    (70) expr -> . location = expr
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
    (71) location -> . IDENT [ expr ]
    (72) location -> . IDENT
    CHAR_LIT        shift and go to state 29
    FLOAT_LIT       shift and go to state 30
    INT_LIT         shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    IDENT           shift and go to state 27
    (               shift and go to state 34
    -               shift and go to state 36
    +               shift and go to state 37
    !               shift and go to state 38
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10
    VOID            shift and go to state 11

    expr                           shift and go to state 85
    type_spec                      shift and go to state 26
    location                       shift and go to state 35

state 56

    (64) expr -> expr < . expr
    (44) expr -> . type_spec [ expr ]
    (45) expr -> . CHAR_LIT
    (46) expr -> . FLOAT_LIT
    (47) expr -> . INT_LIT
    (48) expr -> . FALSE
    (49) expr -> . TRUE
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . location
    (53) expr -> . ( expr )
    (54) expr -> . - expr
    (55) expr -> . + expr
    (56) expr -> . ! expr
    (57) expr -> . expr % expr
    (58) expr -> . expr / expr
    (59) expr -> . expr * expr
    (60) expr -> . expr - expr
    (61) expr -> . expr + expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GE expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr NE expr
    (67) expr -> . expr EQ expr
    (68) expr -> . expr AND expr
    (69) expr -> . expr OR expr
    (70) expr -> . location = expr
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
    (71) location -> . IDENT [ expr ]
    (72) location -> . IDENT
    CHAR_LIT        shift and go to state 29
    FLOAT_LIT       shift and go to state 30
    INT_LIT         shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    IDENT           shift and go to state 27
    (               shift and go to state 34
    -               shift and go to state 36
    +               shift and go to state 37
    !               shift and go to state 38
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10
    VOID            shift and go to state 11

    expr                           shift and go to state 86
    type_spec                      shift and go to state 26
    location                       shift and go to state 35

state 57

    (65) expr -> expr LE . expr
    (44) expr -> . type_spec [ expr ]
    (45) expr -> . CHAR_LIT
    (46) expr -> . FLOAT_LIT
    (47) expr -> . INT_LIT
    (48) expr -> . FALSE
    (49) expr -> . TRUE
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . location
    (53) expr -> . ( expr )
    (54) expr -> . - expr
    (55) expr -> . + expr
    (56) expr -> . ! expr
    (57) expr -> . expr % expr
    (58) expr -> . expr / expr
    (59) expr -> . expr * expr
    (60) expr -> . expr - expr
    (61) expr -> . expr + expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GE expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr NE expr
    (67) expr -> . expr EQ expr
    (68) expr -> . expr AND expr
    (69) expr -> . expr OR expr
    (70) expr -> . location = expr
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
    (71) location -> . IDENT [ expr ]
    (72) location -> . IDENT
    CHAR_LIT        shift and go to state 29
    FLOAT_LIT       shift and go to state 30
    INT_LIT         shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    IDENT           shift and go to state 27
    (               shift and go to state 34
    -               shift and go to state 36
    +               shift and go to state 37
    !               shift and go to state 38
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10
    VOID            shift and go to state 11

    expr                           shift and go to state 87
    type_spec                      shift and go to state 26
    location                       shift and go to state 35

state 58

    (66) expr -> expr NE . expr
    (44) expr -> . type_spec [ expr ]
    (45) expr -> . CHAR_LIT
    (46) expr -> . FLOAT_LIT
    (47) expr -> . INT_LIT
    (48) expr -> . FALSE
    (49) expr -> . TRUE
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . location
    (53) expr -> . ( expr )
    (54) expr -> . - expr
    (55) expr -> . + expr
    (56) expr -> . ! expr
    (57) expr -> . expr % expr
    (58) expr -> . expr / expr
    (59) expr -> . expr * expr
    (60) expr -> . expr - expr
    (61) expr -> . expr + expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GE expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr NE expr
    (67) expr -> . expr EQ expr
    (68) expr -> . expr AND expr
    (69) expr -> . expr OR expr
    (70) expr -> . location = expr
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
    (71) location -> . IDENT [ expr ]
    (72) location -> . IDENT
    CHAR_LIT        shift and go to state 29
    FLOAT_LIT       shift and go to state 30
    INT_LIT         shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    IDENT           shift and go to state 27
    (               shift and go to state 34
    -               shift and go to state 36
    +               shift and go to state 37
    !               shift and go to state 38
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10
    VOID            shift and go to state 11

    expr                           shift and go to state 88
    type_spec                      shift and go to state 26
    location                       shift and go to state 35

state 59

    (67) expr -> expr EQ . expr
    (44) expr -> . type_spec [ expr ]
    (45) expr -> . CHAR_LIT
    (46) expr -> . FLOAT_LIT
    (47) expr -> . INT_LIT
    (48) expr -> . FALSE
    (49) expr -> . TRUE
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . location
    (53) expr -> . ( expr )
    (54) expr -> . - expr
    (55) expr -> . + expr
    (56) expr -> . ! expr
    (57) expr -> . expr % expr
    (58) expr -> . expr / expr
    (59) expr -> . expr * expr
    (60) expr -> . expr - expr
    (61) expr -> . expr + expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GE expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr NE expr
    (67) expr -> . expr EQ expr
    (68) expr -> . expr AND expr
    (69) expr -> . expr OR expr
    (70) expr -> . location = expr
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
    (71) location -> . IDENT [ expr ]
    (72) location -> . IDENT
    CHAR_LIT        shift and go to state 29
    FLOAT_LIT       shift and go to state 30
    INT_LIT         shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    IDENT           shift and go to state 27
    (               shift and go to state 34
    -               shift and go to state 36
    +               shift and go to state 37
    !               shift and go to state 38
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10
    VOID            shift and go to state 11

    expr                           shift and go to state 89
    type_spec                      shift and go to state 26
    location                       shift and go to state 35

state 60

    (68) expr -> expr AND . expr
    (44) expr -> . type_spec [ expr ]
    (45) expr -> . CHAR_LIT
    (46) expr -> . FLOAT_LIT
    (47) expr -> . INT_LIT
    (48) expr -> . FALSE
    (49) expr -> . TRUE
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . location
    (53) expr -> . ( expr )
    (54) expr -> . - expr
    (55) expr -> . + expr
    (56) expr -> . ! expr
    (57) expr -> . expr % expr
    (58) expr -> . expr / expr
    (59) expr -> . expr * expr
    (60) expr -> . expr - expr
    (61) expr -> . expr + expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GE expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr NE expr
    (67) expr -> . expr EQ expr
    (68) expr -> . expr AND expr
    (69) expr -> . expr OR expr
    (70) expr -> . location = expr
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
    (71) location -> . IDENT [ expr ]
    (72) location -> . IDENT
    CHAR_LIT        shift and go to state 29
    FLOAT_LIT       shift and go to state 30
    INT_LIT         shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    IDENT           shift and go to state 27
    (               shift and go to state 34
    -               shift and go to state 36
    +               shift and go to state 37
    !               shift and go to state 38
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10
    VOID            shift and go to state 11

    expr                           shift and go to state 90
    type_spec                      shift and go to state 26
    location                       shift and go to state 35

state 61

    (69) expr -> expr OR . expr
    (44) expr -> . type_spec [ expr ]
    (45) expr -> . CHAR_LIT
    (46) expr -> . FLOAT_LIT
    (47) expr -> . INT_LIT
    (48) expr -> . FALSE
    (49) expr -> . TRUE
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . location
    (53) expr -> . ( expr )
    (54) expr -> . - expr
    (55) expr -> . + expr
    (56) expr -> . ! expr
    (57) expr -> . expr % expr
    (58) expr -> . expr / expr
    (59) expr -> . expr * expr
    (60) expr -> . expr - expr
    (61) expr -> . expr + expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GE expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr NE expr
    (67) expr -> . expr EQ expr
    (68) expr -> . expr AND expr
    (69) expr -> . expr OR expr
    (70) expr -> . location = expr
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
    (71) location -> . IDENT [ expr ]
    (72) location -> . IDENT
    CHAR_LIT        shift and go to state 29
    FLOAT_LIT       shift and go to state 30
    INT_LIT         shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    IDENT           shift and go to state 27
    (               shift and go to state 34
    -               shift and go to state 36
    +               shift and go to state 37
    !               shift and go to state 38
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10
    VOID            shift and go to state 11

    expr                           shift and go to state 91
    type_spec                      shift and go to state 26
    location                       shift and go to state 35

state 62

    (53) expr -> ( expr . )
    (57) expr -> expr . % expr
    (58) expr -> expr . / expr
    (59) expr -> expr . * expr
    (60) expr -> expr . - expr
    (61) expr -> expr . + expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GE expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . NE expr
    (67) expr -> expr . EQ expr
    (68) expr -> expr . AND expr
    (69) expr -> expr . OR expr
    )               shift and go to state 92
    %               shift and go to state 49
    /               shift and go to state 50
    *               shift and go to state 51
    -               shift and go to state 52
    +               shift and go to state 53
    >               shift and go to state 54
    GE              shift and go to state 55
    <               shift and go to state 56
    LE              shift and go to state 57
    NE              shift and go to state 58
    EQ              shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61


state 63

    (70) expr -> location = . expr
    (44) expr -> . type_spec [ expr ]
    (45) expr -> . CHAR_LIT
    (46) expr -> . FLOAT_LIT
    (47) expr -> . INT_LIT
    (48) expr -> . FALSE
    (49) expr -> . TRUE
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . location
    (53) expr -> . ( expr )
    (54) expr -> . - expr
    (55) expr -> . + expr
    (56) expr -> . ! expr
    (57) expr -> . expr % expr
    (58) expr -> . expr / expr
    (59) expr -> . expr * expr
    (60) expr -> . expr - expr
    (61) expr -> . expr + expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GE expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr NE expr
    (67) expr -> . expr EQ expr
    (68) expr -> . expr AND expr
    (69) expr -> . expr OR expr
    (70) expr -> . location = expr
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
    (71) location -> . IDENT [ expr ]
    (72) location -> . IDENT
    CHAR_LIT        shift and go to state 29
    FLOAT_LIT       shift and go to state 30
    INT_LIT         shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    IDENT           shift and go to state 27
    (               shift and go to state 34
    -               shift and go to state 36
    +               shift and go to state 37
    !               shift and go to state 38
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10
    VOID            shift and go to state 11

    location                       shift and go to state 35
    expr                           shift and go to state 93
    type_spec                      shift and go to state 26

state 64

    (54) expr -> - expr .
    (57) expr -> expr . % expr
    (58) expr -> expr . / expr
    (59) expr -> expr . * expr
    (60) expr -> expr . - expr
    (61) expr -> expr . + expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GE expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . NE expr
    (67) expr -> expr . EQ expr
    (68) expr -> expr . AND expr
    (69) expr -> expr . OR expr
    ;               reduce using rule 54 (expr -> - expr .)
    %               reduce using rule 54 (expr -> - expr .)
    /               reduce using rule 54 (expr -> - expr .)
    *               reduce using rule 54 (expr -> - expr .)
    -               reduce using rule 54 (expr -> - expr .)
    +               reduce using rule 54 (expr -> - expr .)
    >               reduce using rule 54 (expr -> - expr .)
    GE              reduce using rule 54 (expr -> - expr .)
    <               reduce using rule 54 (expr -> - expr .)
    LE              reduce using rule 54 (expr -> - expr .)
    NE              reduce using rule 54 (expr -> - expr .)
    EQ              reduce using rule 54 (expr -> - expr .)
    AND             reduce using rule 54 (expr -> - expr .)
    OR              reduce using rule 54 (expr -> - expr .)
    )               reduce using rule 54 (expr -> - expr .)
    ]               reduce using rule 54 (expr -> - expr .)
    ,               reduce using rule 54 (expr -> - expr .)


state 65

    (55) expr -> + expr .
    (57) expr -> expr . % expr
    (58) expr -> expr . / expr
    (59) expr -> expr . * expr
    (60) expr -> expr . - expr
    (61) expr -> expr . + expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GE expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . NE expr
    (67) expr -> expr . EQ expr
    (68) expr -> expr . AND expr
    (69) expr -> expr . OR expr
    ;               reduce using rule 55 (expr -> + expr .)
    %               reduce using rule 55 (expr -> + expr .)
    /               reduce using rule 55 (expr -> + expr .)
    *               reduce using rule 55 (expr -> + expr .)
    -               reduce using rule 55 (expr -> + expr .)
    +               reduce using rule 55 (expr -> + expr .)
    >               reduce using rule 55 (expr -> + expr .)
    GE              reduce using rule 55 (expr -> + expr .)
    <               reduce using rule 55 (expr -> + expr .)
    LE              reduce using rule 55 (expr -> + expr .)
    NE              reduce using rule 55 (expr -> + expr .)
    EQ              reduce using rule 55 (expr -> + expr .)
    AND             reduce using rule 55 (expr -> + expr .)
    OR              reduce using rule 55 (expr -> + expr .)
    )               reduce using rule 55 (expr -> + expr .)
    ]               reduce using rule 55 (expr -> + expr .)
    ,               reduce using rule 55 (expr -> + expr .)


state 66

    (56) expr -> ! expr .
    (57) expr -> expr . % expr
    (58) expr -> expr . / expr
    (59) expr -> expr . * expr
    (60) expr -> expr . - expr
    (61) expr -> expr . + expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GE expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . NE expr
    (67) expr -> expr . EQ expr
    (68) expr -> expr . AND expr
    (69) expr -> expr . OR expr
    ;               reduce using rule 56 (expr -> ! expr .)
    %               reduce using rule 56 (expr -> ! expr .)
    /               reduce using rule 56 (expr -> ! expr .)
    *               reduce using rule 56 (expr -> ! expr .)
    -               reduce using rule 56 (expr -> ! expr .)
    +               reduce using rule 56 (expr -> ! expr .)
    >               reduce using rule 56 (expr -> ! expr .)
    GE              reduce using rule 56 (expr -> ! expr .)
    <               reduce using rule 56 (expr -> ! expr .)
    LE              reduce using rule 56 (expr -> ! expr .)
    NE              reduce using rule 56 (expr -> ! expr .)
    EQ              reduce using rule 56 (expr -> ! expr .)
    AND             reduce using rule 56 (expr -> ! expr .)
    OR              reduce using rule 56 (expr -> ! expr .)
    )               reduce using rule 56 (expr -> ! expr .)
    ]               reduce using rule 56 (expr -> ! expr .)
    ,               reduce using rule 56 (expr -> ! expr .)


state 67

    (7) var_decl -> CONST type_spec IDENT = expr . ;
    (57) expr -> expr . % expr
    (58) expr -> expr . / expr
    (59) expr -> expr . * expr
    (60) expr -> expr . - expr
    (61) expr -> expr . + expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GE expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . NE expr
    (67) expr -> expr . EQ expr
    (68) expr -> expr . AND expr
    (69) expr -> expr . OR expr
    ;               shift and go to state 94
    %               shift and go to state 49
    /               shift and go to state 50
    *               shift and go to state 51
    -               shift and go to state 52
    +               shift and go to state 53
    >               shift and go to state 54
    GE              shift and go to state 55
    <               shift and go to state 56
    LE              shift and go to state 57
    NE              shift and go to state 58
    EQ              shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61


state 68

    (19) param -> type_spec IDENT [ . ]
    ]               shift and go to state 95


state 69

    (14) fun_decl -> type_spec IDENT ( params ) compound_stmt .
    CONST           reduce using rule 14 (fun_decl -> type_spec IDENT ( params ) compound_stmt .)
    FLOAT           reduce using rule 14 (fun_decl -> type_spec IDENT ( params ) compound_stmt .)
    INT             reduce using rule 14 (fun_decl -> type_spec IDENT ( params ) compound_stmt .)
    BOOL            reduce using rule 14 (fun_decl -> type_spec IDENT ( params ) compound_stmt .)
    VOID            reduce using rule 14 (fun_decl -> type_spec IDENT ( params ) compound_stmt .)
    $end            reduce using rule 14 (fun_decl -> type_spec IDENT ( params ) compound_stmt .)


state 70

    (21) compound_stmt -> { . local_decls stmt_list }
    (22) local_decls -> . empty
    (23) local_decls -> . local_decls local_decl
    (77) empty -> .
    CONST           reduce using rule 77 (empty -> .)
    FLOAT           reduce using rule 77 (empty -> .)
    INT             reduce using rule 77 (empty -> .)
    BOOL            reduce using rule 77 (empty -> .)
    VOID            reduce using rule 77 (empty -> .)
    }               reduce using rule 77 (empty -> .)
    {               reduce using rule 77 (empty -> .)
    BREAK           reduce using rule 77 (empty -> .)
    RETURN          reduce using rule 77 (empty -> .)
    WHILE           reduce using rule 77 (empty -> .)
    IF              reduce using rule 77 (empty -> .)
    ;               reduce using rule 77 (empty -> .)
    CHAR_LIT        reduce using rule 77 (empty -> .)
    FLOAT_LIT       reduce using rule 77 (empty -> .)
    INT_LIT         reduce using rule 77 (empty -> .)
    FALSE           reduce using rule 77 (empty -> .)
    TRUE            reduce using rule 77 (empty -> .)
    IDENT           reduce using rule 77 (empty -> .)
    (               reduce using rule 77 (empty -> .)
    -               reduce using rule 77 (empty -> .)
    +               reduce using rule 77 (empty -> .)
    !               reduce using rule 77 (empty -> .)

    local_decls                    shift and go to state 96
    empty                          shift and go to state 97

state 71

    (18) param_list -> param_list , param .
    ,               reduce using rule 18 (param_list -> param_list , param .)
    )               reduce using rule 18 (param_list -> param_list , param .)


state 72

    (44) expr -> type_spec [ expr . ]
    (57) expr -> expr . % expr
    (58) expr -> expr . / expr
    (59) expr -> expr . * expr
    (60) expr -> expr . - expr
    (61) expr -> expr . + expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GE expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . NE expr
    (67) expr -> expr . EQ expr
    (68) expr -> expr . AND expr
    (69) expr -> expr . OR expr
    ]               shift and go to state 98
    %               shift and go to state 49
    /               shift and go to state 50
    *               shift and go to state 51
    -               shift and go to state 52
    +               shift and go to state 53
    >               shift and go to state 54
    GE              shift and go to state 55
    <               shift and go to state 56
    LE              shift and go to state 57
    NE              shift and go to state 58
    EQ              shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61


state 73

    (50) expr -> IDENT . SIZE .
    ;               reduce using rule 50 (expr -> IDENT . SIZE .)
    %               reduce using rule 50 (expr -> IDENT . SIZE .)
    /               reduce using rule 50 (expr -> IDENT . SIZE .)
    *               reduce using rule 50 (expr -> IDENT . SIZE .)
    -               reduce using rule 50 (expr -> IDENT . SIZE .)
    +               reduce using rule 50 (expr -> IDENT . SIZE .)
    >               reduce using rule 50 (expr -> IDENT . SIZE .)
    GE              reduce using rule 50 (expr -> IDENT . SIZE .)
    <               reduce using rule 50 (expr -> IDENT . SIZE .)
    LE              reduce using rule 50 (expr -> IDENT . SIZE .)
    NE              reduce using rule 50 (expr -> IDENT . SIZE .)
    EQ              reduce using rule 50 (expr -> IDENT . SIZE .)
    AND             reduce using rule 50 (expr -> IDENT . SIZE .)
    OR              reduce using rule 50 (expr -> IDENT . SIZE .)
    )               reduce using rule 50 (expr -> IDENT . SIZE .)
    ]               reduce using rule 50 (expr -> IDENT . SIZE .)
    ,               reduce using rule 50 (expr -> IDENT . SIZE .)


state 74

    (51) expr -> IDENT ( args . )
    )               shift and go to state 99


state 75

    (75) args -> empty .
    )               reduce using rule 75 (args -> empty .)


state 76

    (76) args -> arg_list .
    (74) arg_list -> arg_list . , expr
    )               reduce using rule 76 (args -> arg_list .)
    ,               shift and go to state 100


state 77

    (73) arg_list -> expr .
    (57) expr -> expr . % expr
    (58) expr -> expr . / expr
    (59) expr -> expr . * expr
    (60) expr -> expr . - expr
    (61) expr -> expr . + expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GE expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . NE expr
    (67) expr -> expr . EQ expr
    (68) expr -> expr . AND expr
    (69) expr -> expr . OR expr
    ,               reduce using rule 73 (arg_list -> expr .)
    )               reduce using rule 73 (arg_list -> expr .)
    %               shift and go to state 49
    /               shift and go to state 50
    *               shift and go to state 51
    -               shift and go to state 52
    +               shift and go to state 53
    >               shift and go to state 54
    GE              shift and go to state 55
    <               shift and go to state 56
    LE              shift and go to state 57
    NE              shift and go to state 58
    EQ              shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61


state 78

    (71) location -> IDENT [ expr . ]
    (57) expr -> expr . % expr
    (58) expr -> expr . / expr
    (59) expr -> expr . * expr
    (60) expr -> expr . - expr
    (61) expr -> expr . + expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GE expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . NE expr
    (67) expr -> expr . EQ expr
    (68) expr -> expr . AND expr
    (69) expr -> expr . OR expr
    ]               shift and go to state 101
    %               shift and go to state 49
    /               shift and go to state 50
    *               shift and go to state 51
    -               shift and go to state 52
    +               shift and go to state 53
    >               shift and go to state 54
    GE              shift and go to state 55
    <               shift and go to state 56
    LE              shift and go to state 57
    NE              shift and go to state 58
    EQ              shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61


state 79

    (57) expr -> expr % expr .
    (57) expr -> expr . % expr
    (58) expr -> expr . / expr
    (59) expr -> expr . * expr
    (60) expr -> expr . - expr
    (61) expr -> expr . + expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GE expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . NE expr
    (67) expr -> expr . EQ expr
    (68) expr -> expr . AND expr
    (69) expr -> expr . OR expr
    ;               reduce using rule 57 (expr -> expr % expr .)
    %               reduce using rule 57 (expr -> expr % expr .)
    /               reduce using rule 57 (expr -> expr % expr .)
    *               reduce using rule 57 (expr -> expr % expr .)
    -               reduce using rule 57 (expr -> expr % expr .)
    +               reduce using rule 57 (expr -> expr % expr .)
    >               reduce using rule 57 (expr -> expr % expr .)
    GE              reduce using rule 57 (expr -> expr % expr .)
    <               reduce using rule 57 (expr -> expr % expr .)
    LE              reduce using rule 57 (expr -> expr % expr .)
    NE              reduce using rule 57 (expr -> expr % expr .)
    EQ              reduce using rule 57 (expr -> expr % expr .)
    AND             reduce using rule 57 (expr -> expr % expr .)
    OR              reduce using rule 57 (expr -> expr % expr .)
    )               reduce using rule 57 (expr -> expr % expr .)
    ]               reduce using rule 57 (expr -> expr % expr .)
    ,               reduce using rule 57 (expr -> expr % expr .)


state 80

    (58) expr -> expr / expr .
    (57) expr -> expr . % expr
    (58) expr -> expr . / expr
    (59) expr -> expr . * expr
    (60) expr -> expr . - expr
    (61) expr -> expr . + expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GE expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . NE expr
    (67) expr -> expr . EQ expr
    (68) expr -> expr . AND expr
    (69) expr -> expr . OR expr
    ;               reduce using rule 58 (expr -> expr / expr .)
    %               reduce using rule 58 (expr -> expr / expr .)
    /               reduce using rule 58 (expr -> expr / expr .)
    *               reduce using rule 58 (expr -> expr / expr .)
    -               reduce using rule 58 (expr -> expr / expr .)
    +               reduce using rule 58 (expr -> expr / expr .)
    >               reduce using rule 58 (expr -> expr / expr .)
    GE              reduce using rule 58 (expr -> expr / expr .)
    <               reduce using rule 58 (expr -> expr / expr .)
    LE              reduce using rule 58 (expr -> expr / expr .)
    NE              reduce using rule 58 (expr -> expr / expr .)
    EQ              reduce using rule 58 (expr -> expr / expr .)
    AND             reduce using rule 58 (expr -> expr / expr .)
    OR              reduce using rule 58 (expr -> expr / expr .)
    )               reduce using rule 58 (expr -> expr / expr .)
    ]               reduce using rule 58 (expr -> expr / expr .)
    ,               reduce using rule 58 (expr -> expr / expr .)


state 81

    (59) expr -> expr * expr .
    (57) expr -> expr . % expr
    (58) expr -> expr . / expr
    (59) expr -> expr . * expr
    (60) expr -> expr . - expr
    (61) expr -> expr . + expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GE expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . NE expr
    (67) expr -> expr . EQ expr
    (68) expr -> expr . AND expr
    (69) expr -> expr . OR expr
    ;               reduce using rule 59 (expr -> expr * expr .)
    %               reduce using rule 59 (expr -> expr * expr .)
    /               reduce using rule 59 (expr -> expr * expr .)
    *               reduce using rule 59 (expr -> expr * expr .)
    -               reduce using rule 59 (expr -> expr * expr .)
    +               reduce using rule 59 (expr -> expr * expr .)
    >               reduce using rule 59 (expr -> expr * expr .)
    GE              reduce using rule 59 (expr -> expr * expr .)
    <               reduce using rule 59 (expr -> expr * expr .)
    LE              reduce using rule 59 (expr -> expr * expr .)
    NE              reduce using rule 59 (expr -> expr * expr .)
    EQ              reduce using rule 59 (expr -> expr * expr .)
    AND             reduce using rule 59 (expr -> expr * expr .)
    OR              reduce using rule 59 (expr -> expr * expr .)
    )               reduce using rule 59 (expr -> expr * expr .)
    ]               reduce using rule 59 (expr -> expr * expr .)
    ,               reduce using rule 59 (expr -> expr * expr .)


state 82

    (60) expr -> expr - expr .
    (57) expr -> expr . % expr
    (58) expr -> expr . / expr
    (59) expr -> expr . * expr
    (60) expr -> expr . - expr
    (61) expr -> expr . + expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GE expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . NE expr
    (67) expr -> expr . EQ expr
    (68) expr -> expr . AND expr
    (69) expr -> expr . OR expr
    ;               reduce using rule 60 (expr -> expr - expr .)
    -               reduce using rule 60 (expr -> expr - expr .)
    +               reduce using rule 60 (expr -> expr - expr .)
    >               reduce using rule 60 (expr -> expr - expr .)
    GE              reduce using rule 60 (expr -> expr - expr .)
    <               reduce using rule 60 (expr -> expr - expr .)
    LE              reduce using rule 60 (expr -> expr - expr .)
    NE              reduce using rule 60 (expr -> expr - expr .)
    EQ              reduce using rule 60 (expr -> expr - expr .)
    AND             reduce using rule 60 (expr -> expr - expr .)
    OR              reduce using rule 60 (expr -> expr - expr .)
    )               reduce using rule 60 (expr -> expr - expr .)
    ]               reduce using rule 60 (expr -> expr - expr .)
    ,               reduce using rule 60 (expr -> expr - expr .)
    %               shift and go to state 49
    /               shift and go to state 50
    *               shift and go to state 51


state 83

    (61) expr -> expr + expr .
    (57) expr -> expr . % expr
    (58) expr -> expr . / expr
    (59) expr -> expr . * expr
    (60) expr -> expr . - expr
    (61) expr -> expr . + expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GE expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . NE expr
    (67) expr -> expr . EQ expr
    (68) expr -> expr . AND expr
    (69) expr -> expr . OR expr
    ;               reduce using rule 61 (expr -> expr + expr .)
    -               reduce using rule 61 (expr -> expr + expr .)
    +               reduce using rule 61 (expr -> expr + expr .)
    >               reduce using rule 61 (expr -> expr + expr .)
    GE              reduce using rule 61 (expr -> expr + expr .)
    <               reduce using rule 61 (expr -> expr + expr .)
    LE              reduce using rule 61 (expr -> expr + expr .)
    NE              reduce using rule 61 (expr -> expr + expr .)
    EQ              reduce using rule 61 (expr -> expr + expr .)
    AND             reduce using rule 61 (expr -> expr + expr .)
    OR              reduce using rule 61 (expr -> expr + expr .)
    )               reduce using rule 61 (expr -> expr + expr .)
    ]               reduce using rule 61 (expr -> expr + expr .)
    ,               reduce using rule 61 (expr -> expr + expr .)
    %               shift and go to state 49
    /               shift and go to state 50
    *               shift and go to state 51


state 84

    (62) expr -> expr > expr .
    (57) expr -> expr . % expr
    (58) expr -> expr . / expr
    (59) expr -> expr . * expr
    (60) expr -> expr . - expr
    (61) expr -> expr . + expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GE expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . NE expr
    (67) expr -> expr . EQ expr
    (68) expr -> expr . AND expr
    (69) expr -> expr . OR expr
    ;               reduce using rule 62 (expr -> expr > expr .)
    >               reduce using rule 62 (expr -> expr > expr .)
    GE              reduce using rule 62 (expr -> expr > expr .)
    <               reduce using rule 62 (expr -> expr > expr .)
    LE              reduce using rule 62 (expr -> expr > expr .)
    NE              reduce using rule 62 (expr -> expr > expr .)
    EQ              reduce using rule 62 (expr -> expr > expr .)
    AND             reduce using rule 62 (expr -> expr > expr .)
    OR              reduce using rule 62 (expr -> expr > expr .)
    )               reduce using rule 62 (expr -> expr > expr .)
    ]               reduce using rule 62 (expr -> expr > expr .)
    ,               reduce using rule 62 (expr -> expr > expr .)
    %               shift and go to state 49
    /               shift and go to state 50
    *               shift and go to state 51
    -               shift and go to state 52
    +               shift and go to state 53


state 85

    (63) expr -> expr GE expr .
    (57) expr -> expr . % expr
    (58) expr -> expr . / expr
    (59) expr -> expr . * expr
    (60) expr -> expr . - expr
    (61) expr -> expr . + expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GE expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . NE expr
    (67) expr -> expr . EQ expr
    (68) expr -> expr . AND expr
    (69) expr -> expr . OR expr
    ;               reduce using rule 63 (expr -> expr GE expr .)
    >               reduce using rule 63 (expr -> expr GE expr .)
    GE              reduce using rule 63 (expr -> expr GE expr .)
    <               reduce using rule 63 (expr -> expr GE expr .)
    LE              reduce using rule 63 (expr -> expr GE expr .)
    NE              reduce using rule 63 (expr -> expr GE expr .)
    EQ              reduce using rule 63 (expr -> expr GE expr .)
    AND             reduce using rule 63 (expr -> expr GE expr .)
    OR              reduce using rule 63 (expr -> expr GE expr .)
    )               reduce using rule 63 (expr -> expr GE expr .)
    ]               reduce using rule 63 (expr -> expr GE expr .)
    ,               reduce using rule 63 (expr -> expr GE expr .)
    %               shift and go to state 49
    /               shift and go to state 50
    *               shift and go to state 51
    -               shift and go to state 52
    +               shift and go to state 53


state 86

    (64) expr -> expr < expr .
    (57) expr -> expr . % expr
    (58) expr -> expr . / expr
    (59) expr -> expr . * expr
    (60) expr -> expr . - expr
    (61) expr -> expr . + expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GE expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . NE expr
    (67) expr -> expr . EQ expr
    (68) expr -> expr . AND expr
    (69) expr -> expr . OR expr
    ;               reduce using rule 64 (expr -> expr < expr .)
    >               reduce using rule 64 (expr -> expr < expr .)
    GE              reduce using rule 64 (expr -> expr < expr .)
    <               reduce using rule 64 (expr -> expr < expr .)
    LE              reduce using rule 64 (expr -> expr < expr .)
    NE              reduce using rule 64 (expr -> expr < expr .)
    EQ              reduce using rule 64 (expr -> expr < expr .)
    AND             reduce using rule 64 (expr -> expr < expr .)
    OR              reduce using rule 64 (expr -> expr < expr .)
    )               reduce using rule 64 (expr -> expr < expr .)
    ]               reduce using rule 64 (expr -> expr < expr .)
    ,               reduce using rule 64 (expr -> expr < expr .)
    %               shift and go to state 49
    /               shift and go to state 50
    *               shift and go to state 51
    -               shift and go to state 52
    +               shift and go to state 53


state 87

    (65) expr -> expr LE expr .
    (57) expr -> expr . % expr
    (58) expr -> expr . / expr
    (59) expr -> expr . * expr
    (60) expr -> expr . - expr
    (61) expr -> expr . + expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GE expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . NE expr
    (67) expr -> expr . EQ expr
    (68) expr -> expr . AND expr
    (69) expr -> expr . OR expr
    ;               reduce using rule 65 (expr -> expr LE expr .)
    >               reduce using rule 65 (expr -> expr LE expr .)
    GE              reduce using rule 65 (expr -> expr LE expr .)
    <               reduce using rule 65 (expr -> expr LE expr .)
    LE              reduce using rule 65 (expr -> expr LE expr .)
    NE              reduce using rule 65 (expr -> expr LE expr .)
    EQ              reduce using rule 65 (expr -> expr LE expr .)
    AND             reduce using rule 65 (expr -> expr LE expr .)
    OR              reduce using rule 65 (expr -> expr LE expr .)
    )               reduce using rule 65 (expr -> expr LE expr .)
    ]               reduce using rule 65 (expr -> expr LE expr .)
    ,               reduce using rule 65 (expr -> expr LE expr .)
    %               shift and go to state 49
    /               shift and go to state 50
    *               shift and go to state 51
    -               shift and go to state 52
    +               shift and go to state 53


state 88

    (66) expr -> expr NE expr .
    (57) expr -> expr . % expr
    (58) expr -> expr . / expr
    (59) expr -> expr . * expr
    (60) expr -> expr . - expr
    (61) expr -> expr . + expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GE expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . NE expr
    (67) expr -> expr . EQ expr
    (68) expr -> expr . AND expr
    (69) expr -> expr . OR expr
    ;               reduce using rule 66 (expr -> expr NE expr .)
    NE              reduce using rule 66 (expr -> expr NE expr .)
    EQ              reduce using rule 66 (expr -> expr NE expr .)
    AND             reduce using rule 66 (expr -> expr NE expr .)
    OR              reduce using rule 66 (expr -> expr NE expr .)
    )               reduce using rule 66 (expr -> expr NE expr .)
    ]               reduce using rule 66 (expr -> expr NE expr .)
    ,               reduce using rule 66 (expr -> expr NE expr .)
    %               shift and go to state 49
    /               shift and go to state 50
    *               shift and go to state 51
    -               shift and go to state 52
    +               shift and go to state 53
    >               shift and go to state 54
    GE              shift and go to state 55
    <               shift and go to state 56
    LE              shift and go to state 57


state 89

    (67) expr -> expr EQ expr .
    (57) expr -> expr . % expr
    (58) expr -> expr . / expr
    (59) expr -> expr . * expr
    (60) expr -> expr . - expr
    (61) expr -> expr . + expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GE expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . NE expr
    (67) expr -> expr . EQ expr
    (68) expr -> expr . AND expr
    (69) expr -> expr . OR expr
    ;               reduce using rule 67 (expr -> expr EQ expr .)
    NE              reduce using rule 67 (expr -> expr EQ expr .)
    EQ              reduce using rule 67 (expr -> expr EQ expr .)
    AND             reduce using rule 67 (expr -> expr EQ expr .)
    OR              reduce using rule 67 (expr -> expr EQ expr .)
    )               reduce using rule 67 (expr -> expr EQ expr .)
    ]               reduce using rule 67 (expr -> expr EQ expr .)
    ,               reduce using rule 67 (expr -> expr EQ expr .)
    %               shift and go to state 49
    /               shift and go to state 50
    *               shift and go to state 51
    -               shift and go to state 52
    +               shift and go to state 53
    >               shift and go to state 54
    GE              shift and go to state 55
    <               shift and go to state 56
    LE              shift and go to state 57


state 90

    (68) expr -> expr AND expr .
    (57) expr -> expr . % expr
    (58) expr -> expr . / expr
    (59) expr -> expr . * expr
    (60) expr -> expr . - expr
    (61) expr -> expr . + expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GE expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . NE expr
    (67) expr -> expr . EQ expr
    (68) expr -> expr . AND expr
    (69) expr -> expr . OR expr
    ;               reduce using rule 68 (expr -> expr AND expr .)
    AND             reduce using rule 68 (expr -> expr AND expr .)
    OR              reduce using rule 68 (expr -> expr AND expr .)
    )               reduce using rule 68 (expr -> expr AND expr .)
    ]               reduce using rule 68 (expr -> expr AND expr .)
    ,               reduce using rule 68 (expr -> expr AND expr .)
    %               shift and go to state 49
    /               shift and go to state 50
    *               shift and go to state 51
    -               shift and go to state 52
    +               shift and go to state 53
    >               shift and go to state 54
    GE              shift and go to state 55
    <               shift and go to state 56
    LE              shift and go to state 57
    NE              shift and go to state 58
    EQ              shift and go to state 59


state 91

    (69) expr -> expr OR expr .
    (57) expr -> expr . % expr
    (58) expr -> expr . / expr
    (59) expr -> expr . * expr
    (60) expr -> expr . - expr
    (61) expr -> expr . + expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GE expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . NE expr
    (67) expr -> expr . EQ expr
    (68) expr -> expr . AND expr
    (69) expr -> expr . OR expr
    ;               reduce using rule 69 (expr -> expr OR expr .)
    OR              reduce using rule 69 (expr -> expr OR expr .)
    )               reduce using rule 69 (expr -> expr OR expr .)
    ]               reduce using rule 69 (expr -> expr OR expr .)
    ,               reduce using rule 69 (expr -> expr OR expr .)
    %               shift and go to state 49
    /               shift and go to state 50
    *               shift and go to state 51
    -               shift and go to state 52
    +               shift and go to state 53
    >               shift and go to state 54
    GE              shift and go to state 55
    <               shift and go to state 56
    LE              shift and go to state 57
    NE              shift and go to state 58
    EQ              shift and go to state 59
    AND             shift and go to state 60


state 92

    (53) expr -> ( expr ) .
    ;               reduce using rule 53 (expr -> ( expr ) .)
    %               reduce using rule 53 (expr -> ( expr ) .)
    /               reduce using rule 53 (expr -> ( expr ) .)
    *               reduce using rule 53 (expr -> ( expr ) .)
    -               reduce using rule 53 (expr -> ( expr ) .)
    +               reduce using rule 53 (expr -> ( expr ) .)
    >               reduce using rule 53 (expr -> ( expr ) .)
    GE              reduce using rule 53 (expr -> ( expr ) .)
    <               reduce using rule 53 (expr -> ( expr ) .)
    LE              reduce using rule 53 (expr -> ( expr ) .)
    NE              reduce using rule 53 (expr -> ( expr ) .)
    EQ              reduce using rule 53 (expr -> ( expr ) .)
    AND             reduce using rule 53 (expr -> ( expr ) .)
    OR              reduce using rule 53 (expr -> ( expr ) .)
    )               reduce using rule 53 (expr -> ( expr ) .)
    ]               reduce using rule 53 (expr -> ( expr ) .)
    ,               reduce using rule 53 (expr -> ( expr ) .)


state 93

    (70) expr -> location = expr .
    (57) expr -> expr . % expr
    (58) expr -> expr . / expr
    (59) expr -> expr . * expr
    (60) expr -> expr . - expr
    (61) expr -> expr . + expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GE expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . NE expr
    (67) expr -> expr . EQ expr
    (68) expr -> expr . AND expr
    (69) expr -> expr . OR expr
    ;               reduce using rule 70 (expr -> location = expr .)
    )               reduce using rule 70 (expr -> location = expr .)
    ]               reduce using rule 70 (expr -> location = expr .)
    ,               reduce using rule 70 (expr -> location = expr .)
    %               shift and go to state 49
    /               shift and go to state 50
    *               shift and go to state 51
    -               shift and go to state 52
    +               shift and go to state 53
    >               shift and go to state 54
    GE              shift and go to state 55
    <               shift and go to state 56
    LE              shift and go to state 57
    NE              shift and go to state 58
    EQ              shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61


state 94

    (7) var_decl -> CONST type_spec IDENT = expr ; .
    CONST           reduce using rule 7 (var_decl -> CONST type_spec IDENT = expr ; .)
    FLOAT           reduce using rule 7 (var_decl -> CONST type_spec IDENT = expr ; .)
    INT             reduce using rule 7 (var_decl -> CONST type_spec IDENT = expr ; .)
    BOOL            reduce using rule 7 (var_decl -> CONST type_spec IDENT = expr ; .)
    VOID            reduce using rule 7 (var_decl -> CONST type_spec IDENT = expr ; .)
    $end            reduce using rule 7 (var_decl -> CONST type_spec IDENT = expr ; .)


state 95

    (19) param -> type_spec IDENT [ ] .
    ,               reduce using rule 19 (param -> type_spec IDENT [ ] .)
    )               reduce using rule 19 (param -> type_spec IDENT [ ] .)


state 96

    (21) compound_stmt -> { local_decls . stmt_list }
    (23) local_decls -> local_decls . local_decl
    (28) stmt_list -> . empty
    (29) stmt_list -> . stmt_list stmt
    (24) local_decl -> . type_spec IDENT [ ] ;
    (25) local_decl -> . type_spec IDENT = expr ;
    (26) local_decl -> . type_spec IDENT ;
    (27) local_decl -> . CONST type_spec IDENT = expr ;
    (77) empty -> .
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    CONST           shift and go to state 106
    }               reduce using rule 77 (empty -> .)
    {               reduce using rule 77 (empty -> .)
    BREAK           reduce using rule 77 (empty -> .)
    RETURN          reduce using rule 77 (empty -> .)
    WHILE           reduce using rule 77 (empty -> .)
    IF              reduce using rule 77 (empty -> .)
    ;               reduce using rule 77 (empty -> .)
    CHAR_LIT        reduce using rule 77 (empty -> .)
    FLOAT_LIT       reduce using rule 77 (empty -> .)
    INT_LIT         reduce using rule 77 (empty -> .)
    FALSE           reduce using rule 77 (empty -> .)
    TRUE            reduce using rule 77 (empty -> .)
    IDENT           reduce using rule 77 (empty -> .)
    (               reduce using rule 77 (empty -> .)
    -               reduce using rule 77 (empty -> .)
    +               reduce using rule 77 (empty -> .)
    !               reduce using rule 77 (empty -> .)
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10
    VOID            shift and go to state 11

    stmt_list                      shift and go to state 102
    local_decl                     shift and go to state 103
    empty                          shift and go to state 104
    type_spec                      shift and go to state 105

state 97

    (22) local_decls -> empty .
    CONST           reduce using rule 22 (local_decls -> empty .)
    FLOAT           reduce using rule 22 (local_decls -> empty .)
    INT             reduce using rule 22 (local_decls -> empty .)
    BOOL            reduce using rule 22 (local_decls -> empty .)
    VOID            reduce using rule 22 (local_decls -> empty .)
    }               reduce using rule 22 (local_decls -> empty .)
    {               reduce using rule 22 (local_decls -> empty .)
    BREAK           reduce using rule 22 (local_decls -> empty .)
    RETURN          reduce using rule 22 (local_decls -> empty .)
    WHILE           reduce using rule 22 (local_decls -> empty .)
    IF              reduce using rule 22 (local_decls -> empty .)
    ;               reduce using rule 22 (local_decls -> empty .)
    CHAR_LIT        reduce using rule 22 (local_decls -> empty .)
    FLOAT_LIT       reduce using rule 22 (local_decls -> empty .)
    INT_LIT         reduce using rule 22 (local_decls -> empty .)
    FALSE           reduce using rule 22 (local_decls -> empty .)
    TRUE            reduce using rule 22 (local_decls -> empty .)
    IDENT           reduce using rule 22 (local_decls -> empty .)
    (               reduce using rule 22 (local_decls -> empty .)
    -               reduce using rule 22 (local_decls -> empty .)
    +               reduce using rule 22 (local_decls -> empty .)
    !               reduce using rule 22 (local_decls -> empty .)


state 98

    (44) expr -> type_spec [ expr ] .
    ;               reduce using rule 44 (expr -> type_spec [ expr ] .)
    %               reduce using rule 44 (expr -> type_spec [ expr ] .)
    /               reduce using rule 44 (expr -> type_spec [ expr ] .)
    *               reduce using rule 44 (expr -> type_spec [ expr ] .)
    -               reduce using rule 44 (expr -> type_spec [ expr ] .)
    +               reduce using rule 44 (expr -> type_spec [ expr ] .)
    >               reduce using rule 44 (expr -> type_spec [ expr ] .)
    GE              reduce using rule 44 (expr -> type_spec [ expr ] .)
    <               reduce using rule 44 (expr -> type_spec [ expr ] .)
    LE              reduce using rule 44 (expr -> type_spec [ expr ] .)
    NE              reduce using rule 44 (expr -> type_spec [ expr ] .)
    EQ              reduce using rule 44 (expr -> type_spec [ expr ] .)
    AND             reduce using rule 44 (expr -> type_spec [ expr ] .)
    OR              reduce using rule 44 (expr -> type_spec [ expr ] .)
    )               reduce using rule 44 (expr -> type_spec [ expr ] .)
    ]               reduce using rule 44 (expr -> type_spec [ expr ] .)
    ,               reduce using rule 44 (expr -> type_spec [ expr ] .)


state 99

    (51) expr -> IDENT ( args ) .
    ;               reduce using rule 51 (expr -> IDENT ( args ) .)
    %               reduce using rule 51 (expr -> IDENT ( args ) .)
    /               reduce using rule 51 (expr -> IDENT ( args ) .)
    *               reduce using rule 51 (expr -> IDENT ( args ) .)
    -               reduce using rule 51 (expr -> IDENT ( args ) .)
    +               reduce using rule 51 (expr -> IDENT ( args ) .)
    >               reduce using rule 51 (expr -> IDENT ( args ) .)
    GE              reduce using rule 51 (expr -> IDENT ( args ) .)
    <               reduce using rule 51 (expr -> IDENT ( args ) .)
    LE              reduce using rule 51 (expr -> IDENT ( args ) .)
    NE              reduce using rule 51 (expr -> IDENT ( args ) .)
    EQ              reduce using rule 51 (expr -> IDENT ( args ) .)
    AND             reduce using rule 51 (expr -> IDENT ( args ) .)
    OR              reduce using rule 51 (expr -> IDENT ( args ) .)
    )               reduce using rule 51 (expr -> IDENT ( args ) .)
    ]               reduce using rule 51 (expr -> IDENT ( args ) .)
    ,               reduce using rule 51 (expr -> IDENT ( args ) .)


state 100

    (74) arg_list -> arg_list , . expr
    (44) expr -> . type_spec [ expr ]
    (45) expr -> . CHAR_LIT
    (46) expr -> . FLOAT_LIT
    (47) expr -> . INT_LIT
    (48) expr -> . FALSE
    (49) expr -> . TRUE
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . location
    (53) expr -> . ( expr )
    (54) expr -> . - expr
    (55) expr -> . + expr
    (56) expr -> . ! expr
    (57) expr -> . expr % expr
    (58) expr -> . expr / expr
    (59) expr -> . expr * expr
    (60) expr -> . expr - expr
    (61) expr -> . expr + expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GE expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr NE expr
    (67) expr -> . expr EQ expr
    (68) expr -> . expr AND expr
    (69) expr -> . expr OR expr
    (70) expr -> . location = expr
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
    (71) location -> . IDENT [ expr ]
    (72) location -> . IDENT
    CHAR_LIT        shift and go to state 29
    FLOAT_LIT       shift and go to state 30
    INT_LIT         shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    IDENT           shift and go to state 27
    (               shift and go to state 34
    -               shift and go to state 36
    +               shift and go to state 37
    !               shift and go to state 38
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10
    VOID            shift and go to state 11

    expr                           shift and go to state 107
    type_spec                      shift and go to state 26
    location                       shift and go to state 35

state 101

    (71) location -> IDENT [ expr ] .
    =               reduce using rule 71 (location -> IDENT [ expr ] .)
    ;               reduce using rule 71 (location -> IDENT [ expr ] .)
    %               reduce using rule 71 (location -> IDENT [ expr ] .)
    /               reduce using rule 71 (location -> IDENT [ expr ] .)
    *               reduce using rule 71 (location -> IDENT [ expr ] .)
    -               reduce using rule 71 (location -> IDENT [ expr ] .)
    +               reduce using rule 71 (location -> IDENT [ expr ] .)
    >               reduce using rule 71 (location -> IDENT [ expr ] .)
    GE              reduce using rule 71 (location -> IDENT [ expr ] .)
    <               reduce using rule 71 (location -> IDENT [ expr ] .)
    LE              reduce using rule 71 (location -> IDENT [ expr ] .)
    NE              reduce using rule 71 (location -> IDENT [ expr ] .)
    EQ              reduce using rule 71 (location -> IDENT [ expr ] .)
    AND             reduce using rule 71 (location -> IDENT [ expr ] .)
    OR              reduce using rule 71 (location -> IDENT [ expr ] .)
    )               reduce using rule 71 (location -> IDENT [ expr ] .)
    ]               reduce using rule 71 (location -> IDENT [ expr ] .)
    ,               reduce using rule 71 (location -> IDENT [ expr ] .)


state 102

    (21) compound_stmt -> { local_decls stmt_list . }
    (29) stmt_list -> stmt_list . stmt
    (30) stmt -> . compound_stmt
    (31) stmt -> . break_stmt
    (32) stmt -> . return_stmt
    (33) stmt -> . while_stmt
    (34) stmt -> . if_stmt
    (35) stmt -> . expr_stmt
    (21) compound_stmt -> . { local_decls stmt_list }
    (43) break_stmt -> . BREAK ;
    (41) return_stmt -> . RETURN expr ;
    (42) return_stmt -> . RETURN ;
    (38) while_stmt -> . WHILE ( expr ) stmt
    (39) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (40) if_stmt -> . IF ( expr ) stmt
    (36) expr_stmt -> . ;
    (37) expr_stmt -> . expr ;
    (44) expr -> . type_spec [ expr ]
    (45) expr -> . CHAR_LIT
    (46) expr -> . FLOAT_LIT
    (47) expr -> . INT_LIT
    (48) expr -> . FALSE
    (49) expr -> . TRUE
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . location
    (53) expr -> . ( expr )
    (54) expr -> . - expr
    (55) expr -> . + expr
    (56) expr -> . ! expr
    (57) expr -> . expr % expr
    (58) expr -> . expr / expr
    (59) expr -> . expr * expr
    (60) expr -> . expr - expr
    (61) expr -> . expr + expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GE expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr NE expr
    (67) expr -> . expr EQ expr
    (68) expr -> . expr AND expr
    (69) expr -> . expr OR expr
    (70) expr -> . location = expr
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
    (71) location -> . IDENT [ expr ]
    (72) location -> . IDENT
    }               shift and go to state 108
    {               shift and go to state 70
    BREAK           shift and go to state 116
    RETURN          shift and go to state 118
    WHILE           shift and go to state 120
    IF              shift and go to state 121
    ;               shift and go to state 117
    CHAR_LIT        shift and go to state 29
    FLOAT_LIT       shift and go to state 30
    INT_LIT         shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    IDENT           shift and go to state 27
    (               shift and go to state 34
    -               shift and go to state 36
    +               shift and go to state 37
    !               shift and go to state 38
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10
    VOID            shift and go to state 11

    stmt                           shift and go to state 109
    compound_stmt                  shift and go to state 110
    break_stmt                     shift and go to state 111
    return_stmt                    shift and go to state 112
    while_stmt                     shift and go to state 113
    if_stmt                        shift and go to state 114
    expr_stmt                      shift and go to state 115
    expr                           shift and go to state 119
    type_spec                      shift and go to state 26
    location                       shift and go to state 35

state 103

    (23) local_decls -> local_decls local_decl .
    CONST           reduce using rule 23 (local_decls -> local_decls local_decl .)
    FLOAT           reduce using rule 23 (local_decls -> local_decls local_decl .)
    INT             reduce using rule 23 (local_decls -> local_decls local_decl .)
    BOOL            reduce using rule 23 (local_decls -> local_decls local_decl .)
    VOID            reduce using rule 23 (local_decls -> local_decls local_decl .)
    }               reduce using rule 23 (local_decls -> local_decls local_decl .)
    {               reduce using rule 23 (local_decls -> local_decls local_decl .)
    BREAK           reduce using rule 23 (local_decls -> local_decls local_decl .)
    RETURN          reduce using rule 23 (local_decls -> local_decls local_decl .)
    WHILE           reduce using rule 23 (local_decls -> local_decls local_decl .)
    IF              reduce using rule 23 (local_decls -> local_decls local_decl .)
    ;               reduce using rule 23 (local_decls -> local_decls local_decl .)
    CHAR_LIT        reduce using rule 23 (local_decls -> local_decls local_decl .)
    FLOAT_LIT       reduce using rule 23 (local_decls -> local_decls local_decl .)
    INT_LIT         reduce using rule 23 (local_decls -> local_decls local_decl .)
    FALSE           reduce using rule 23 (local_decls -> local_decls local_decl .)
    TRUE            reduce using rule 23 (local_decls -> local_decls local_decl .)
    IDENT           reduce using rule 23 (local_decls -> local_decls local_decl .)
    (               reduce using rule 23 (local_decls -> local_decls local_decl .)
    -               reduce using rule 23 (local_decls -> local_decls local_decl .)
    +               reduce using rule 23 (local_decls -> local_decls local_decl .)
    !               reduce using rule 23 (local_decls -> local_decls local_decl .)


state 104

    (28) stmt_list -> empty .
    }               reduce using rule 28 (stmt_list -> empty .)
    {               reduce using rule 28 (stmt_list -> empty .)
    BREAK           reduce using rule 28 (stmt_list -> empty .)
    RETURN          reduce using rule 28 (stmt_list -> empty .)
    WHILE           reduce using rule 28 (stmt_list -> empty .)
    IF              reduce using rule 28 (stmt_list -> empty .)
    ;               reduce using rule 28 (stmt_list -> empty .)
    CHAR_LIT        reduce using rule 28 (stmt_list -> empty .)
    FLOAT_LIT       reduce using rule 28 (stmt_list -> empty .)
    INT_LIT         reduce using rule 28 (stmt_list -> empty .)
    FALSE           reduce using rule 28 (stmt_list -> empty .)
    TRUE            reduce using rule 28 (stmt_list -> empty .)
    IDENT           reduce using rule 28 (stmt_list -> empty .)
    (               reduce using rule 28 (stmt_list -> empty .)
    -               reduce using rule 28 (stmt_list -> empty .)
    +               reduce using rule 28 (stmt_list -> empty .)
    !               reduce using rule 28 (stmt_list -> empty .)
    FLOAT           reduce using rule 28 (stmt_list -> empty .)
    INT             reduce using rule 28 (stmt_list -> empty .)
    BOOL            reduce using rule 28 (stmt_list -> empty .)
    VOID            reduce using rule 28 (stmt_list -> empty .)


state 105

    (24) local_decl -> type_spec . IDENT [ ] ;
    (25) local_decl -> type_spec . IDENT = expr ;
    (26) local_decl -> type_spec . IDENT ;
    IDENT           shift and go to state 122


state 106

    (27) local_decl -> CONST . type_spec IDENT = expr ;
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10
    VOID            shift and go to state 11

    type_spec                      shift and go to state 123

state 107

    (74) arg_list -> arg_list , expr .
    (57) expr -> expr . % expr
    (58) expr -> expr . / expr
    (59) expr -> expr . * expr
    (60) expr -> expr . - expr
    (61) expr -> expr . + expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GE expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . NE expr
    (67) expr -> expr . EQ expr
    (68) expr -> expr . AND expr
    (69) expr -> expr . OR expr
    ,               reduce using rule 74 (arg_list -> arg_list , expr .)
    )               reduce using rule 74 (arg_list -> arg_list , expr .)
    %               shift and go to state 49
    /               shift and go to state 50
    *               shift and go to state 51
    -               shift and go to state 52
    +               shift and go to state 53
    >               shift and go to state 54
    GE              shift and go to state 55
    <               shift and go to state 56
    LE              shift and go to state 57
    NE              shift and go to state 58
    EQ              shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61


state 108

    (21) compound_stmt -> { local_decls stmt_list } .
    CONST           reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    FLOAT           reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    INT             reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    BOOL            reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    VOID            reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    $end            reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    }               reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    {               reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    BREAK           reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    RETURN          reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    WHILE           reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    IF              reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    ;               reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    CHAR_LIT        reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    FLOAT_LIT       reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    INT_LIT         reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    FALSE           reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    TRUE            reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    IDENT           reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    (               reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    -               reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    +               reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    !               reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)
    ELSE            reduce using rule 21 (compound_stmt -> { local_decls stmt_list } .)


state 109

    (29) stmt_list -> stmt_list stmt .
    }               reduce using rule 29 (stmt_list -> stmt_list stmt .)
    {               reduce using rule 29 (stmt_list -> stmt_list stmt .)
    BREAK           reduce using rule 29 (stmt_list -> stmt_list stmt .)
    RETURN          reduce using rule 29 (stmt_list -> stmt_list stmt .)
    WHILE           reduce using rule 29 (stmt_list -> stmt_list stmt .)
    IF              reduce using rule 29 (stmt_list -> stmt_list stmt .)
    ;               reduce using rule 29 (stmt_list -> stmt_list stmt .)
    CHAR_LIT        reduce using rule 29 (stmt_list -> stmt_list stmt .)
    FLOAT_LIT       reduce using rule 29 (stmt_list -> stmt_list stmt .)
    INT_LIT         reduce using rule 29 (stmt_list -> stmt_list stmt .)
    FALSE           reduce using rule 29 (stmt_list -> stmt_list stmt .)
    TRUE            reduce using rule 29 (stmt_list -> stmt_list stmt .)
    IDENT           reduce using rule 29 (stmt_list -> stmt_list stmt .)
    (               reduce using rule 29 (stmt_list -> stmt_list stmt .)
    -               reduce using rule 29 (stmt_list -> stmt_list stmt .)
    +               reduce using rule 29 (stmt_list -> stmt_list stmt .)
    !               reduce using rule 29 (stmt_list -> stmt_list stmt .)
    FLOAT           reduce using rule 29 (stmt_list -> stmt_list stmt .)
    INT             reduce using rule 29 (stmt_list -> stmt_list stmt .)
    BOOL            reduce using rule 29 (stmt_list -> stmt_list stmt .)
    VOID            reduce using rule 29 (stmt_list -> stmt_list stmt .)


state 110

    (30) stmt -> compound_stmt .
    }               reduce using rule 30 (stmt -> compound_stmt .)
    {               reduce using rule 30 (stmt -> compound_stmt .)
    BREAK           reduce using rule 30 (stmt -> compound_stmt .)
    RETURN          reduce using rule 30 (stmt -> compound_stmt .)
    WHILE           reduce using rule 30 (stmt -> compound_stmt .)
    IF              reduce using rule 30 (stmt -> compound_stmt .)
    ;               reduce using rule 30 (stmt -> compound_stmt .)
    CHAR_LIT        reduce using rule 30 (stmt -> compound_stmt .)
    FLOAT_LIT       reduce using rule 30 (stmt -> compound_stmt .)
    INT_LIT         reduce using rule 30 (stmt -> compound_stmt .)
    FALSE           reduce using rule 30 (stmt -> compound_stmt .)
    TRUE            reduce using rule 30 (stmt -> compound_stmt .)
    IDENT           reduce using rule 30 (stmt -> compound_stmt .)
    (               reduce using rule 30 (stmt -> compound_stmt .)
    -               reduce using rule 30 (stmt -> compound_stmt .)
    +               reduce using rule 30 (stmt -> compound_stmt .)
    !               reduce using rule 30 (stmt -> compound_stmt .)
    FLOAT           reduce using rule 30 (stmt -> compound_stmt .)
    INT             reduce using rule 30 (stmt -> compound_stmt .)
    BOOL            reduce using rule 30 (stmt -> compound_stmt .)
    VOID            reduce using rule 30 (stmt -> compound_stmt .)
    ELSE            reduce using rule 30 (stmt -> compound_stmt .)


state 111

    (31) stmt -> break_stmt .
    }               reduce using rule 31 (stmt -> break_stmt .)
    {               reduce using rule 31 (stmt -> break_stmt .)
    BREAK           reduce using rule 31 (stmt -> break_stmt .)
    RETURN          reduce using rule 31 (stmt -> break_stmt .)
    WHILE           reduce using rule 31 (stmt -> break_stmt .)
    IF              reduce using rule 31 (stmt -> break_stmt .)
    ;               reduce using rule 31 (stmt -> break_stmt .)
    CHAR_LIT        reduce using rule 31 (stmt -> break_stmt .)
    FLOAT_LIT       reduce using rule 31 (stmt -> break_stmt .)
    INT_LIT         reduce using rule 31 (stmt -> break_stmt .)
    FALSE           reduce using rule 31 (stmt -> break_stmt .)
    TRUE            reduce using rule 31 (stmt -> break_stmt .)
    IDENT           reduce using rule 31 (stmt -> break_stmt .)
    (               reduce using rule 31 (stmt -> break_stmt .)
    -               reduce using rule 31 (stmt -> break_stmt .)
    +               reduce using rule 31 (stmt -> break_stmt .)
    !               reduce using rule 31 (stmt -> break_stmt .)
    FLOAT           reduce using rule 31 (stmt -> break_stmt .)
    INT             reduce using rule 31 (stmt -> break_stmt .)
    BOOL            reduce using rule 31 (stmt -> break_stmt .)
    VOID            reduce using rule 31 (stmt -> break_stmt .)
    ELSE            reduce using rule 31 (stmt -> break_stmt .)


state 112

    (32) stmt -> return_stmt .
    }               reduce using rule 32 (stmt -> return_stmt .)
    {               reduce using rule 32 (stmt -> return_stmt .)
    BREAK           reduce using rule 32 (stmt -> return_stmt .)
    RETURN          reduce using rule 32 (stmt -> return_stmt .)
    WHILE           reduce using rule 32 (stmt -> return_stmt .)
    IF              reduce using rule 32 (stmt -> return_stmt .)
    ;               reduce using rule 32 (stmt -> return_stmt .)
    CHAR_LIT        reduce using rule 32 (stmt -> return_stmt .)
    FLOAT_LIT       reduce using rule 32 (stmt -> return_stmt .)
    INT_LIT         reduce using rule 32 (stmt -> return_stmt .)
    FALSE           reduce using rule 32 (stmt -> return_stmt .)
    TRUE            reduce using rule 32 (stmt -> return_stmt .)
    IDENT           reduce using rule 32 (stmt -> return_stmt .)
    (               reduce using rule 32 (stmt -> return_stmt .)
    -               reduce using rule 32 (stmt -> return_stmt .)
    +               reduce using rule 32 (stmt -> return_stmt .)
    !               reduce using rule 32 (stmt -> return_stmt .)
    FLOAT           reduce using rule 32 (stmt -> return_stmt .)
    INT             reduce using rule 32 (stmt -> return_stmt .)
    BOOL            reduce using rule 32 (stmt -> return_stmt .)
    VOID            reduce using rule 32 (stmt -> return_stmt .)
    ELSE            reduce using rule 32 (stmt -> return_stmt .)


state 113

    (33) stmt -> while_stmt .
    }               reduce using rule 33 (stmt -> while_stmt .)
    {               reduce using rule 33 (stmt -> while_stmt .)
    BREAK           reduce using rule 33 (stmt -> while_stmt .)
    RETURN          reduce using rule 33 (stmt -> while_stmt .)
    WHILE           reduce using rule 33 (stmt -> while_stmt .)
    IF              reduce using rule 33 (stmt -> while_stmt .)
    ;               reduce using rule 33 (stmt -> while_stmt .)
    CHAR_LIT        reduce using rule 33 (stmt -> while_stmt .)
    FLOAT_LIT       reduce using rule 33 (stmt -> while_stmt .)
    INT_LIT         reduce using rule 33 (stmt -> while_stmt .)
    FALSE           reduce using rule 33 (stmt -> while_stmt .)
    TRUE            reduce using rule 33 (stmt -> while_stmt .)
    IDENT           reduce using rule 33 (stmt -> while_stmt .)
    (               reduce using rule 33 (stmt -> while_stmt .)
    -               reduce using rule 33 (stmt -> while_stmt .)
    +               reduce using rule 33 (stmt -> while_stmt .)
    !               reduce using rule 33 (stmt -> while_stmt .)
    FLOAT           reduce using rule 33 (stmt -> while_stmt .)
    INT             reduce using rule 33 (stmt -> while_stmt .)
    BOOL            reduce using rule 33 (stmt -> while_stmt .)
    VOID            reduce using rule 33 (stmt -> while_stmt .)
    ELSE            reduce using rule 33 (stmt -> while_stmt .)


state 114

    (34) stmt -> if_stmt .
    }               reduce using rule 34 (stmt -> if_stmt .)
    {               reduce using rule 34 (stmt -> if_stmt .)
    BREAK           reduce using rule 34 (stmt -> if_stmt .)
    RETURN          reduce using rule 34 (stmt -> if_stmt .)
    WHILE           reduce using rule 34 (stmt -> if_stmt .)
    IF              reduce using rule 34 (stmt -> if_stmt .)
    ;               reduce using rule 34 (stmt -> if_stmt .)
    CHAR_LIT        reduce using rule 34 (stmt -> if_stmt .)
    FLOAT_LIT       reduce using rule 34 (stmt -> if_stmt .)
    INT_LIT         reduce using rule 34 (stmt -> if_stmt .)
    FALSE           reduce using rule 34 (stmt -> if_stmt .)
    TRUE            reduce using rule 34 (stmt -> if_stmt .)
    IDENT           reduce using rule 34 (stmt -> if_stmt .)
    (               reduce using rule 34 (stmt -> if_stmt .)
    -               reduce using rule 34 (stmt -> if_stmt .)
    +               reduce using rule 34 (stmt -> if_stmt .)
    !               reduce using rule 34 (stmt -> if_stmt .)
    FLOAT           reduce using rule 34 (stmt -> if_stmt .)
    INT             reduce using rule 34 (stmt -> if_stmt .)
    BOOL            reduce using rule 34 (stmt -> if_stmt .)
    VOID            reduce using rule 34 (stmt -> if_stmt .)
    ELSE            reduce using rule 34 (stmt -> if_stmt .)


state 115

    (35) stmt -> expr_stmt .
    }               reduce using rule 35 (stmt -> expr_stmt .)
    {               reduce using rule 35 (stmt -> expr_stmt .)
    BREAK           reduce using rule 35 (stmt -> expr_stmt .)
    RETURN          reduce using rule 35 (stmt -> expr_stmt .)
    WHILE           reduce using rule 35 (stmt -> expr_stmt .)
    IF              reduce using rule 35 (stmt -> expr_stmt .)
    ;               reduce using rule 35 (stmt -> expr_stmt .)
    CHAR_LIT        reduce using rule 35 (stmt -> expr_stmt .)
    FLOAT_LIT       reduce using rule 35 (stmt -> expr_stmt .)
    INT_LIT         reduce using rule 35 (stmt -> expr_stmt .)
    FALSE           reduce using rule 35 (stmt -> expr_stmt .)
    TRUE            reduce using rule 35 (stmt -> expr_stmt .)
    IDENT           reduce using rule 35 (stmt -> expr_stmt .)
    (               reduce using rule 35 (stmt -> expr_stmt .)
    -               reduce using rule 35 (stmt -> expr_stmt .)
    +               reduce using rule 35 (stmt -> expr_stmt .)
    !               reduce using rule 35 (stmt -> expr_stmt .)
    FLOAT           reduce using rule 35 (stmt -> expr_stmt .)
    INT             reduce using rule 35 (stmt -> expr_stmt .)
    BOOL            reduce using rule 35 (stmt -> expr_stmt .)
    VOID            reduce using rule 35 (stmt -> expr_stmt .)
    ELSE            reduce using rule 35 (stmt -> expr_stmt .)


state 116

    (43) break_stmt -> BREAK . ;
    ;               shift and go to state 124


state 117

    (36) expr_stmt -> ; .
    }               reduce using rule 36 (expr_stmt -> ; .)
    {               reduce using rule 36 (expr_stmt -> ; .)
    BREAK           reduce using rule 36 (expr_stmt -> ; .)
    RETURN          reduce using rule 36 (expr_stmt -> ; .)
    WHILE           reduce using rule 36 (expr_stmt -> ; .)
    IF              reduce using rule 36 (expr_stmt -> ; .)
    ;               reduce using rule 36 (expr_stmt -> ; .)
    CHAR_LIT        reduce using rule 36 (expr_stmt -> ; .)
    FLOAT_LIT       reduce using rule 36 (expr_stmt -> ; .)
    INT_LIT         reduce using rule 36 (expr_stmt -> ; .)
    FALSE           reduce using rule 36 (expr_stmt -> ; .)
    TRUE            reduce using rule 36 (expr_stmt -> ; .)
    IDENT           reduce using rule 36 (expr_stmt -> ; .)
    (               reduce using rule 36 (expr_stmt -> ; .)
    -               reduce using rule 36 (expr_stmt -> ; .)
    +               reduce using rule 36 (expr_stmt -> ; .)
    !               reduce using rule 36 (expr_stmt -> ; .)
    FLOAT           reduce using rule 36 (expr_stmt -> ; .)
    INT             reduce using rule 36 (expr_stmt -> ; .)
    BOOL            reduce using rule 36 (expr_stmt -> ; .)
    VOID            reduce using rule 36 (expr_stmt -> ; .)
    ELSE            reduce using rule 36 (expr_stmt -> ; .)


state 118

    (41) return_stmt -> RETURN . expr ;
    (42) return_stmt -> RETURN . ;
    (44) expr -> . type_spec [ expr ]
    (45) expr -> . CHAR_LIT
    (46) expr -> . FLOAT_LIT
    (47) expr -> . INT_LIT
    (48) expr -> . FALSE
    (49) expr -> . TRUE
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . location
    (53) expr -> . ( expr )
    (54) expr -> . - expr
    (55) expr -> . + expr
    (56) expr -> . ! expr
    (57) expr -> . expr % expr
    (58) expr -> . expr / expr
    (59) expr -> . expr * expr
    (60) expr -> . expr - expr
    (61) expr -> . expr + expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GE expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr NE expr
    (67) expr -> . expr EQ expr
    (68) expr -> . expr AND expr
    (69) expr -> . expr OR expr
    (70) expr -> . location = expr
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
    (71) location -> . IDENT [ expr ]
    (72) location -> . IDENT
    ;               shift and go to state 126
    CHAR_LIT        shift and go to state 29
    FLOAT_LIT       shift and go to state 30
    INT_LIT         shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    IDENT           shift and go to state 27
    (               shift and go to state 34
    -               shift and go to state 36
    +               shift and go to state 37
    !               shift and go to state 38
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10
    VOID            shift and go to state 11

    expr                           shift and go to state 125
    type_spec                      shift and go to state 26
    location                       shift and go to state 35

state 119

    (37) expr_stmt -> expr . ;
    (57) expr -> expr . % expr
    (58) expr -> expr . / expr
    (59) expr -> expr . * expr
    (60) expr -> expr . - expr
    (61) expr -> expr . + expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GE expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . NE expr
    (67) expr -> expr . EQ expr
    (68) expr -> expr . AND expr
    (69) expr -> expr . OR expr
    ;               shift and go to state 127
    %               shift and go to state 49
    /               shift and go to state 50
    *               shift and go to state 51
    -               shift and go to state 52
    +               shift and go to state 53
    >               shift and go to state 54
    GE              shift and go to state 55
    <               shift and go to state 56
    LE              shift and go to state 57
    NE              shift and go to state 58
    EQ              shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61


state 120

    (38) while_stmt -> WHILE . ( expr ) stmt
    (               shift and go to state 128


state 121

    (39) if_stmt -> IF . ( expr ) stmt ELSE stmt
    (40) if_stmt -> IF . ( expr ) stmt
    (               shift and go to state 129


state 122

    (24) local_decl -> type_spec IDENT . [ ] ;
    (25) local_decl -> type_spec IDENT . = expr ;
    (26) local_decl -> type_spec IDENT . ;
    [               shift and go to state 130
    =               shift and go to state 132
    ;               shift and go to state 131


state 123

    (27) local_decl -> CONST type_spec . IDENT = expr ;
    IDENT           shift and go to state 133


state 124

    (43) break_stmt -> BREAK ; .
    }               reduce using rule 43 (break_stmt -> BREAK ; .)
    {               reduce using rule 43 (break_stmt -> BREAK ; .)
    BREAK           reduce using rule 43 (break_stmt -> BREAK ; .)
    RETURN          reduce using rule 43 (break_stmt -> BREAK ; .)
    WHILE           reduce using rule 43 (break_stmt -> BREAK ; .)
    IF              reduce using rule 43 (break_stmt -> BREAK ; .)
    ;               reduce using rule 43 (break_stmt -> BREAK ; .)
    CHAR_LIT        reduce using rule 43 (break_stmt -> BREAK ; .)
    FLOAT_LIT       reduce using rule 43 (break_stmt -> BREAK ; .)
    INT_LIT         reduce using rule 43 (break_stmt -> BREAK ; .)
    FALSE           reduce using rule 43 (break_stmt -> BREAK ; .)
    TRUE            reduce using rule 43 (break_stmt -> BREAK ; .)
    IDENT           reduce using rule 43 (break_stmt -> BREAK ; .)
    (               reduce using rule 43 (break_stmt -> BREAK ; .)
    -               reduce using rule 43 (break_stmt -> BREAK ; .)
    +               reduce using rule 43 (break_stmt -> BREAK ; .)
    !               reduce using rule 43 (break_stmt -> BREAK ; .)
    FLOAT           reduce using rule 43 (break_stmt -> BREAK ; .)
    INT             reduce using rule 43 (break_stmt -> BREAK ; .)
    BOOL            reduce using rule 43 (break_stmt -> BREAK ; .)
    VOID            reduce using rule 43 (break_stmt -> BREAK ; .)
    ELSE            reduce using rule 43 (break_stmt -> BREAK ; .)


state 125

    (41) return_stmt -> RETURN expr . ;
    (57) expr -> expr . % expr
    (58) expr -> expr . / expr
    (59) expr -> expr . * expr
    (60) expr -> expr . - expr
    (61) expr -> expr . + expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GE expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . NE expr
    (67) expr -> expr . EQ expr
    (68) expr -> expr . AND expr
    (69) expr -> expr . OR expr
    ;               shift and go to state 134
    %               shift and go to state 49
    /               shift and go to state 50
    *               shift and go to state 51
    -               shift and go to state 52
    +               shift and go to state 53
    >               shift and go to state 54
    GE              shift and go to state 55
    <               shift and go to state 56
    LE              shift and go to state 57
    NE              shift and go to state 58
    EQ              shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61


state 126

    (42) return_stmt -> RETURN ; .
    }               reduce using rule 42 (return_stmt -> RETURN ; .)
    {               reduce using rule 42 (return_stmt -> RETURN ; .)
    BREAK           reduce using rule 42 (return_stmt -> RETURN ; .)
    RETURN          reduce using rule 42 (return_stmt -> RETURN ; .)
    WHILE           reduce using rule 42 (return_stmt -> RETURN ; .)
    IF              reduce using rule 42 (return_stmt -> RETURN ; .)
    ;               reduce using rule 42 (return_stmt -> RETURN ; .)
    CHAR_LIT        reduce using rule 42 (return_stmt -> RETURN ; .)
    FLOAT_LIT       reduce using rule 42 (return_stmt -> RETURN ; .)
    INT_LIT         reduce using rule 42 (return_stmt -> RETURN ; .)
    FALSE           reduce using rule 42 (return_stmt -> RETURN ; .)
    TRUE            reduce using rule 42 (return_stmt -> RETURN ; .)
    IDENT           reduce using rule 42 (return_stmt -> RETURN ; .)
    (               reduce using rule 42 (return_stmt -> RETURN ; .)
    -               reduce using rule 42 (return_stmt -> RETURN ; .)
    +               reduce using rule 42 (return_stmt -> RETURN ; .)
    !               reduce using rule 42 (return_stmt -> RETURN ; .)
    FLOAT           reduce using rule 42 (return_stmt -> RETURN ; .)
    INT             reduce using rule 42 (return_stmt -> RETURN ; .)
    BOOL            reduce using rule 42 (return_stmt -> RETURN ; .)
    VOID            reduce using rule 42 (return_stmt -> RETURN ; .)
    ELSE            reduce using rule 42 (return_stmt -> RETURN ; .)


state 127

    (37) expr_stmt -> expr ; .
    }               reduce using rule 37 (expr_stmt -> expr ; .)
    {               reduce using rule 37 (expr_stmt -> expr ; .)
    BREAK           reduce using rule 37 (expr_stmt -> expr ; .)
    RETURN          reduce using rule 37 (expr_stmt -> expr ; .)
    WHILE           reduce using rule 37 (expr_stmt -> expr ; .)
    IF              reduce using rule 37 (expr_stmt -> expr ; .)
    ;               reduce using rule 37 (expr_stmt -> expr ; .)
    CHAR_LIT        reduce using rule 37 (expr_stmt -> expr ; .)
    FLOAT_LIT       reduce using rule 37 (expr_stmt -> expr ; .)
    INT_LIT         reduce using rule 37 (expr_stmt -> expr ; .)
    FALSE           reduce using rule 37 (expr_stmt -> expr ; .)
    TRUE            reduce using rule 37 (expr_stmt -> expr ; .)
    IDENT           reduce using rule 37 (expr_stmt -> expr ; .)
    (               reduce using rule 37 (expr_stmt -> expr ; .)
    -               reduce using rule 37 (expr_stmt -> expr ; .)
    +               reduce using rule 37 (expr_stmt -> expr ; .)
    !               reduce using rule 37 (expr_stmt -> expr ; .)
    FLOAT           reduce using rule 37 (expr_stmt -> expr ; .)
    INT             reduce using rule 37 (expr_stmt -> expr ; .)
    BOOL            reduce using rule 37 (expr_stmt -> expr ; .)
    VOID            reduce using rule 37 (expr_stmt -> expr ; .)
    ELSE            reduce using rule 37 (expr_stmt -> expr ; .)


state 128

    (38) while_stmt -> WHILE ( . expr ) stmt
    (44) expr -> . type_spec [ expr ]
    (45) expr -> . CHAR_LIT
    (46) expr -> . FLOAT_LIT
    (47) expr -> . INT_LIT
    (48) expr -> . FALSE
    (49) expr -> . TRUE
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . location
    (53) expr -> . ( expr )
    (54) expr -> . - expr
    (55) expr -> . + expr
    (56) expr -> . ! expr
    (57) expr -> . expr % expr
    (58) expr -> . expr / expr
    (59) expr -> . expr * expr
    (60) expr -> . expr - expr
    (61) expr -> . expr + expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GE expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr NE expr
    (67) expr -> . expr EQ expr
    (68) expr -> . expr AND expr
    (69) expr -> . expr OR expr
    (70) expr -> . location = expr
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
    (71) location -> . IDENT [ expr ]
    (72) location -> . IDENT
    CHAR_LIT        shift and go to state 29
    FLOAT_LIT       shift and go to state 30
    INT_LIT         shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    IDENT           shift and go to state 27
    (               shift and go to state 34
    -               shift and go to state 36
    +               shift and go to state 37
    !               shift and go to state 38
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10
    VOID            shift and go to state 11

    expr                           shift and go to state 135
    type_spec                      shift and go to state 26
    location                       shift and go to state 35

state 129

    (39) if_stmt -> IF ( . expr ) stmt ELSE stmt
    (40) if_stmt -> IF ( . expr ) stmt
    (44) expr -> . type_spec [ expr ]
    (45) expr -> . CHAR_LIT
    (46) expr -> . FLOAT_LIT
    (47) expr -> . INT_LIT
    (48) expr -> . FALSE
    (49) expr -> . TRUE
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . location
    (53) expr -> . ( expr )
    (54) expr -> . - expr
    (55) expr -> . + expr
    (56) expr -> . ! expr
    (57) expr -> . expr % expr
    (58) expr -> . expr / expr
    (59) expr -> . expr * expr
    (60) expr -> . expr - expr
    (61) expr -> . expr + expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GE expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr NE expr
    (67) expr -> . expr EQ expr
    (68) expr -> . expr AND expr
    (69) expr -> . expr OR expr
    (70) expr -> . location = expr
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
    (71) location -> . IDENT [ expr ]
    (72) location -> . IDENT
    CHAR_LIT        shift and go to state 29
    FLOAT_LIT       shift and go to state 30
    INT_LIT         shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    IDENT           shift and go to state 27
    (               shift and go to state 34
    -               shift and go to state 36
    +               shift and go to state 37
    !               shift and go to state 38
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10
    VOID            shift and go to state 11

    expr                           shift and go to state 136
    type_spec                      shift and go to state 26
    location                       shift and go to state 35

state 130

    (24) local_decl -> type_spec IDENT [ . ] ;
    ]               shift and go to state 137


state 131

    (26) local_decl -> type_spec IDENT ; .
    CONST           reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    FLOAT           reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    INT             reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    BOOL            reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    VOID            reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    }               reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    {               reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    BREAK           reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    RETURN          reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    WHILE           reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    IF              reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    ;               reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    CHAR_LIT        reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    FLOAT_LIT       reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    INT_LIT         reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    FALSE           reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    TRUE            reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    IDENT           reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    (               reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    -               reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    +               reduce using rule 26 (local_decl -> type_spec IDENT ; .)
    !               reduce using rule 26 (local_decl -> type_spec IDENT ; .)


state 132

    (25) local_decl -> type_spec IDENT = . expr ;
    (44) expr -> . type_spec [ expr ]
    (45) expr -> . CHAR_LIT
    (46) expr -> . FLOAT_LIT
    (47) expr -> . INT_LIT
    (48) expr -> . FALSE
    (49) expr -> . TRUE
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . location
    (53) expr -> . ( expr )
    (54) expr -> . - expr
    (55) expr -> . + expr
    (56) expr -> . ! expr
    (57) expr -> . expr % expr
    (58) expr -> . expr / expr
    (59) expr -> . expr * expr
    (60) expr -> . expr - expr
    (61) expr -> . expr + expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GE expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr NE expr
    (67) expr -> . expr EQ expr
    (68) expr -> . expr AND expr
    (69) expr -> . expr OR expr
    (70) expr -> . location = expr
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
    (71) location -> . IDENT [ expr ]
    (72) location -> . IDENT
    CHAR_LIT        shift and go to state 29
    FLOAT_LIT       shift and go to state 30
    INT_LIT         shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    IDENT           shift and go to state 27
    (               shift and go to state 34
    -               shift and go to state 36
    +               shift and go to state 37
    !               shift and go to state 38
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10
    VOID            shift and go to state 11

    type_spec                      shift and go to state 26
    expr                           shift and go to state 138
    location                       shift and go to state 35

state 133

    (27) local_decl -> CONST type_spec IDENT . = expr ;
    =               shift and go to state 139


state 134

    (41) return_stmt -> RETURN expr ; .
    }               reduce using rule 41 (return_stmt -> RETURN expr ; .)
    {               reduce using rule 41 (return_stmt -> RETURN expr ; .)
    BREAK           reduce using rule 41 (return_stmt -> RETURN expr ; .)
    RETURN          reduce using rule 41 (return_stmt -> RETURN expr ; .)
    WHILE           reduce using rule 41 (return_stmt -> RETURN expr ; .)
    IF              reduce using rule 41 (return_stmt -> RETURN expr ; .)
    ;               reduce using rule 41 (return_stmt -> RETURN expr ; .)
    CHAR_LIT        reduce using rule 41 (return_stmt -> RETURN expr ; .)
    FLOAT_LIT       reduce using rule 41 (return_stmt -> RETURN expr ; .)
    INT_LIT         reduce using rule 41 (return_stmt -> RETURN expr ; .)
    FALSE           reduce using rule 41 (return_stmt -> RETURN expr ; .)
    TRUE            reduce using rule 41 (return_stmt -> RETURN expr ; .)
    IDENT           reduce using rule 41 (return_stmt -> RETURN expr ; .)
    (               reduce using rule 41 (return_stmt -> RETURN expr ; .)
    -               reduce using rule 41 (return_stmt -> RETURN expr ; .)
    +               reduce using rule 41 (return_stmt -> RETURN expr ; .)
    !               reduce using rule 41 (return_stmt -> RETURN expr ; .)
    FLOAT           reduce using rule 41 (return_stmt -> RETURN expr ; .)
    INT             reduce using rule 41 (return_stmt -> RETURN expr ; .)
    BOOL            reduce using rule 41 (return_stmt -> RETURN expr ; .)
    VOID            reduce using rule 41 (return_stmt -> RETURN expr ; .)
    ELSE            reduce using rule 41 (return_stmt -> RETURN expr ; .)


state 135

    (38) while_stmt -> WHILE ( expr . ) stmt
    (57) expr -> expr . % expr
    (58) expr -> expr . / expr
    (59) expr -> expr . * expr
    (60) expr -> expr . - expr
    (61) expr -> expr . + expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GE expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . NE expr
    (67) expr -> expr . EQ expr
    (68) expr -> expr . AND expr
    (69) expr -> expr . OR expr
    )               shift and go to state 140
    %               shift and go to state 49
    /               shift and go to state 50
    *               shift and go to state 51
    -               shift and go to state 52
    +               shift and go to state 53
    >               shift and go to state 54
    GE              shift and go to state 55
    <               shift and go to state 56
    LE              shift and go to state 57
    NE              shift and go to state 58
    EQ              shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61


state 136

    (39) if_stmt -> IF ( expr . ) stmt ELSE stmt
    (40) if_stmt -> IF ( expr . ) stmt
    (57) expr -> expr . % expr
    (58) expr -> expr . / expr
    (59) expr -> expr . * expr
    (60) expr -> expr . - expr
    (61) expr -> expr . + expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GE expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . NE expr
    (67) expr -> expr . EQ expr
    (68) expr -> expr . AND expr
    (69) expr -> expr . OR expr
    )               shift and go to state 141
    %               shift and go to state 49
    /               shift and go to state 50
    *               shift and go to state 51
    -               shift and go to state 52
    +               shift and go to state 53
    >               shift and go to state 54
    GE              shift and go to state 55
    <               shift and go to state 56
    LE              shift and go to state 57
    NE              shift and go to state 58
    EQ              shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61


state 137

    (24) local_decl -> type_spec IDENT [ ] . ;
    ;               shift and go to state 142


state 138

    (25) local_decl -> type_spec IDENT = expr . ;
    (57) expr -> expr . % expr
    (58) expr -> expr . / expr
    (59) expr -> expr . * expr
    (60) expr -> expr . - expr
    (61) expr -> expr . + expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GE expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . NE expr
    (67) expr -> expr . EQ expr
    (68) expr -> expr . AND expr
    (69) expr -> expr . OR expr
    ;               shift and go to state 143
    %               shift and go to state 49
    /               shift and go to state 50
    *               shift and go to state 51
    -               shift and go to state 52
    +               shift and go to state 53
    >               shift and go to state 54
    GE              shift and go to state 55
    <               shift and go to state 56
    LE              shift and go to state 57
    NE              shift and go to state 58
    EQ              shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61


state 139

    (27) local_decl -> CONST type_spec IDENT = . expr ;
    (44) expr -> . type_spec [ expr ]
    (45) expr -> . CHAR_LIT
    (46) expr -> . FLOAT_LIT
    (47) expr -> . INT_LIT
    (48) expr -> . FALSE
    (49) expr -> . TRUE
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . location
    (53) expr -> . ( expr )
    (54) expr -> . - expr
    (55) expr -> . + expr
    (56) expr -> . ! expr
    (57) expr -> . expr % expr
    (58) expr -> . expr / expr
    (59) expr -> . expr * expr
    (60) expr -> . expr - expr
    (61) expr -> . expr + expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GE expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr NE expr
    (67) expr -> . expr EQ expr
    (68) expr -> . expr AND expr
    (69) expr -> . expr OR expr
    (70) expr -> . location = expr
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
    (71) location -> . IDENT [ expr ]
    (72) location -> . IDENT
    CHAR_LIT        shift and go to state 29
    FLOAT_LIT       shift and go to state 30
    INT_LIT         shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    IDENT           shift and go to state 27
    (               shift and go to state 34
    -               shift and go to state 36
    +               shift and go to state 37
    !               shift and go to state 38
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10
    VOID            shift and go to state 11

    type_spec                      shift and go to state 26
    expr                           shift and go to state 144
    location                       shift and go to state 35

state 140

    (38) while_stmt -> WHILE ( expr ) . stmt
    (30) stmt -> . compound_stmt
    (31) stmt -> . break_stmt
    (32) stmt -> . return_stmt
    (33) stmt -> . while_stmt
    (34) stmt -> . if_stmt
    (35) stmt -> . expr_stmt
    (21) compound_stmt -> . { local_decls stmt_list }
    (43) break_stmt -> . BREAK ;
    (41) return_stmt -> . RETURN expr ;
    (42) return_stmt -> . RETURN ;
    (38) while_stmt -> . WHILE ( expr ) stmt
    (39) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (40) if_stmt -> . IF ( expr ) stmt
    (36) expr_stmt -> . ;
    (37) expr_stmt -> . expr ;
    (44) expr -> . type_spec [ expr ]
    (45) expr -> . CHAR_LIT
    (46) expr -> . FLOAT_LIT
    (47) expr -> . INT_LIT
    (48) expr -> . FALSE
    (49) expr -> . TRUE
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . location
    (53) expr -> . ( expr )
    (54) expr -> . - expr
    (55) expr -> . + expr
    (56) expr -> . ! expr
    (57) expr -> . expr % expr
    (58) expr -> . expr / expr
    (59) expr -> . expr * expr
    (60) expr -> . expr - expr
    (61) expr -> . expr + expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GE expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr NE expr
    (67) expr -> . expr EQ expr
    (68) expr -> . expr AND expr
    (69) expr -> . expr OR expr
    (70) expr -> . location = expr
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
    (71) location -> . IDENT [ expr ]
    (72) location -> . IDENT
    {               shift and go to state 70
    BREAK           shift and go to state 116
    RETURN          shift and go to state 118
    WHILE           shift and go to state 120
    IF              shift and go to state 121
    ;               shift and go to state 117
    CHAR_LIT        shift and go to state 29
    FLOAT_LIT       shift and go to state 30
    INT_LIT         shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    IDENT           shift and go to state 27
    (               shift and go to state 34
    -               shift and go to state 36
    +               shift and go to state 37
    !               shift and go to state 38
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10
    VOID            shift and go to state 11

    expr                           shift and go to state 119
    stmt                           shift and go to state 145
    compound_stmt                  shift and go to state 110
    break_stmt                     shift and go to state 111
    return_stmt                    shift and go to state 112
    while_stmt                     shift and go to state 113
    if_stmt                        shift and go to state 114
    expr_stmt                      shift and go to state 115
    type_spec                      shift and go to state 26
    location                       shift and go to state 35

state 141

    (39) if_stmt -> IF ( expr ) . stmt ELSE stmt
    (40) if_stmt -> IF ( expr ) . stmt
    (30) stmt -> . compound_stmt
    (31) stmt -> . break_stmt
    (32) stmt -> . return_stmt
    (33) stmt -> . while_stmt
    (34) stmt -> . if_stmt
    (35) stmt -> . expr_stmt
    (21) compound_stmt -> . { local_decls stmt_list }
    (43) break_stmt -> . BREAK ;
    (41) return_stmt -> . RETURN expr ;
    (42) return_stmt -> . RETURN ;
    (38) while_stmt -> . WHILE ( expr ) stmt
    (39) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (40) if_stmt -> . IF ( expr ) stmt
    (36) expr_stmt -> . ;
    (37) expr_stmt -> . expr ;
    (44) expr -> . type_spec [ expr ]
    (45) expr -> . CHAR_LIT
    (46) expr -> . FLOAT_LIT
    (47) expr -> . INT_LIT
    (48) expr -> . FALSE
    (49) expr -> . TRUE
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . location
    (53) expr -> . ( expr )
    (54) expr -> . - expr
    (55) expr -> . + expr
    (56) expr -> . ! expr
    (57) expr -> . expr % expr
    (58) expr -> . expr / expr
    (59) expr -> . expr * expr
    (60) expr -> . expr - expr
    (61) expr -> . expr + expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GE expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr NE expr
    (67) expr -> . expr EQ expr
    (68) expr -> . expr AND expr
    (69) expr -> . expr OR expr
    (70) expr -> . location = expr
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
    (71) location -> . IDENT [ expr ]
    (72) location -> . IDENT
    {               shift and go to state 70
    BREAK           shift and go to state 116
    RETURN          shift and go to state 118
    WHILE           shift and go to state 120
    IF              shift and go to state 121
    ;               shift and go to state 117
    CHAR_LIT        shift and go to state 29
    FLOAT_LIT       shift and go to state 30
    INT_LIT         shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    IDENT           shift and go to state 27
    (               shift and go to state 34
    -               shift and go to state 36
    +               shift and go to state 37
    !               shift and go to state 38
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10
    VOID            shift and go to state 11

    expr                           shift and go to state 119
    stmt                           shift and go to state 146
    compound_stmt                  shift and go to state 110
    break_stmt                     shift and go to state 111
    return_stmt                    shift and go to state 112
    while_stmt                     shift and go to state 113
    if_stmt                        shift and go to state 114
    expr_stmt                      shift and go to state 115
    type_spec                      shift and go to state 26
    location                       shift and go to state 35

state 142

    (24) local_decl -> type_spec IDENT [ ] ; .
    CONST           reduce using rule 24 (local_decl -> type_spec IDENT [ ] ; .)
    FLOAT           reduce using rule 24 (local_decl -> type_spec IDENT [ ] ; .)
    INT             reduce using rule 24 (local_decl -> type_spec IDENT [ ] ; .)
    BOOL            reduce using rule 24 (local_decl -> type_spec IDENT [ ] ; .)
    VOID            reduce using rule 24 (local_decl -> type_spec IDENT [ ] ; .)
    }               reduce using rule 24 (local_decl -> type_spec IDENT [ ] ; .)
    {               reduce using rule 24 (local_decl -> type_spec IDENT [ ] ; .)
    BREAK           reduce using rule 24 (local_decl -> type_spec IDENT [ ] ; .)
    RETURN          reduce using rule 24 (local_decl -> type_spec IDENT [ ] ; .)
    WHILE           reduce using rule 24 (local_decl -> type_spec IDENT [ ] ; .)
    IF              reduce using rule 24 (local_decl -> type_spec IDENT [ ] ; .)
    ;               reduce using rule 24 (local_decl -> type_spec IDENT [ ] ; .)
    CHAR_LIT        reduce using rule 24 (local_decl -> type_spec IDENT [ ] ; .)
    FLOAT_LIT       reduce using rule 24 (local_decl -> type_spec IDENT [ ] ; .)
    INT_LIT         reduce using rule 24 (local_decl -> type_spec IDENT [ ] ; .)
    FALSE           reduce using rule 24 (local_decl -> type_spec IDENT [ ] ; .)
    TRUE            reduce using rule 24 (local_decl -> type_spec IDENT [ ] ; .)
    IDENT           reduce using rule 24 (local_decl -> type_spec IDENT [ ] ; .)
    (               reduce using rule 24 (local_decl -> type_spec IDENT [ ] ; .)
    -               reduce using rule 24 (local_decl -> type_spec IDENT [ ] ; .)
    +               reduce using rule 24 (local_decl -> type_spec IDENT [ ] ; .)
    !               reduce using rule 24 (local_decl -> type_spec IDENT [ ] ; .)


state 143

    (25) local_decl -> type_spec IDENT = expr ; .
    CONST           reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    FLOAT           reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    INT             reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    BOOL            reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    VOID            reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    }               reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    {               reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    BREAK           reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    RETURN          reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    WHILE           reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    IF              reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    ;               reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    CHAR_LIT        reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    FLOAT_LIT       reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    INT_LIT         reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    FALSE           reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    TRUE            reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    IDENT           reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    (               reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    -               reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    +               reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)
    !               reduce using rule 25 (local_decl -> type_spec IDENT = expr ; .)


state 144

    (27) local_decl -> CONST type_spec IDENT = expr . ;
    (57) expr -> expr . % expr
    (58) expr -> expr . / expr
    (59) expr -> expr . * expr
    (60) expr -> expr . - expr
    (61) expr -> expr . + expr
    (62) expr -> expr . > expr
    (63) expr -> expr . GE expr
    (64) expr -> expr . < expr
    (65) expr -> expr . LE expr
    (66) expr -> expr . NE expr
    (67) expr -> expr . EQ expr
    (68) expr -> expr . AND expr
    (69) expr -> expr . OR expr
    ;               shift and go to state 147
    %               shift and go to state 49
    /               shift and go to state 50
    *               shift and go to state 51
    -               shift and go to state 52
    +               shift and go to state 53
    >               shift and go to state 54
    GE              shift and go to state 55
    <               shift and go to state 56
    LE              shift and go to state 57
    NE              shift and go to state 58
    EQ              shift and go to state 59
    AND             shift and go to state 60
    OR              shift and go to state 61


state 145

    (38) while_stmt -> WHILE ( expr ) stmt .
    }               reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)
    {               reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)
    BREAK           reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)
    RETURN          reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)
    WHILE           reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)
    IF              reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)
    ;               reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)
    CHAR_LIT        reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)
    FLOAT_LIT       reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)
    INT_LIT         reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)
    FALSE           reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)
    TRUE            reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)
    IDENT           reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)
    (               reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)
    -               reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)
    +               reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)
    !               reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)
    FLOAT           reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)
    INT             reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)
    BOOL            reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)
    VOID            reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)
    ELSE            reduce using rule 38 (while_stmt -> WHILE ( expr ) stmt .)


state 146

    (39) if_stmt -> IF ( expr ) stmt . ELSE stmt
    (40) if_stmt -> IF ( expr ) stmt .
    ELSE            shift and go to state 148
    }               reduce using rule 40 (if_stmt -> IF ( expr ) stmt .)
    {               reduce using rule 40 (if_stmt -> IF ( expr ) stmt .)
    BREAK           reduce using rule 40 (if_stmt -> IF ( expr ) stmt .)
    RETURN          reduce using rule 40 (if_stmt -> IF ( expr ) stmt .)
    WHILE           reduce using rule 40 (if_stmt -> IF ( expr ) stmt .)
    IF              reduce using rule 40 (if_stmt -> IF ( expr ) stmt .)
    ;               reduce using rule 40 (if_stmt -> IF ( expr ) stmt .)
    CHAR_LIT        reduce using rule 40 (if_stmt -> IF ( expr ) stmt .)
    FLOAT_LIT       reduce using rule 40 (if_stmt -> IF ( expr ) stmt .)
    INT_LIT         reduce using rule 40 (if_stmt -> IF ( expr ) stmt .)
    FALSE           reduce using rule 40 (if_stmt -> IF ( expr ) stmt .)
    TRUE            reduce using rule 40 (if_stmt -> IF ( expr ) stmt .)
    IDENT           reduce using rule 40 (if_stmt -> IF ( expr ) stmt .)
    (               reduce using rule 40 (if_stmt -> IF ( expr ) stmt .)
    -               reduce using rule 40 (if_stmt -> IF ( expr ) stmt .)
    +               reduce using rule 40 (if_stmt -> IF ( expr ) stmt .)
    !               reduce using rule 40 (if_stmt -> IF ( expr ) stmt .)
    FLOAT           reduce using rule 40 (if_stmt -> IF ( expr ) stmt .)
    INT             reduce using rule 40 (if_stmt -> IF ( expr ) stmt .)
    BOOL            reduce using rule 40 (if_stmt -> IF ( expr ) stmt .)
    VOID            reduce using rule 40 (if_stmt -> IF ( expr ) stmt .)


state 147

    (27) local_decl -> CONST type_spec IDENT = expr ; .
    CONST           reduce using rule 27 (local_decl -> CONST type_spec IDENT = expr ; .)
    FLOAT           reduce using rule 27 (local_decl -> CONST type_spec IDENT = expr ; .)
    INT             reduce using rule 27 (local_decl -> CONST type_spec IDENT = expr ; .)
    BOOL            reduce using rule 27 (local_decl -> CONST type_spec IDENT = expr ; .)
    VOID            reduce using rule 27 (local_decl -> CONST type_spec IDENT = expr ; .)
    }               reduce using rule 27 (local_decl -> CONST type_spec IDENT = expr ; .)
    {               reduce using rule 27 (local_decl -> CONST type_spec IDENT = expr ; .)
    BREAK           reduce using rule 27 (local_decl -> CONST type_spec IDENT = expr ; .)
    RETURN          reduce using rule 27 (local_decl -> CONST type_spec IDENT = expr ; .)
    WHILE           reduce using rule 27 (local_decl -> CONST type_spec IDENT = expr ; .)
    IF              reduce using rule 27 (local_decl -> CONST type_spec IDENT = expr ; .)
    ;               reduce using rule 27 (local_decl -> CONST type_spec IDENT = expr ; .)
    CHAR_LIT        reduce using rule 27 (local_decl -> CONST type_spec IDENT = expr ; .)
    FLOAT_LIT       reduce using rule 27 (local_decl -> CONST type_spec IDENT = expr ; .)
    INT_LIT         reduce using rule 27 (local_decl -> CONST type_spec IDENT = expr ; .)
    FALSE           reduce using rule 27 (local_decl -> CONST type_spec IDENT = expr ; .)
    TRUE            reduce using rule 27 (local_decl -> CONST type_spec IDENT = expr ; .)
    IDENT           reduce using rule 27 (local_decl -> CONST type_spec IDENT = expr ; .)
    (               reduce using rule 27 (local_decl -> CONST type_spec IDENT = expr ; .)
    -               reduce using rule 27 (local_decl -> CONST type_spec IDENT = expr ; .)
    +               reduce using rule 27 (local_decl -> CONST type_spec IDENT = expr ; .)
    !               reduce using rule 27 (local_decl -> CONST type_spec IDENT = expr ; .)


state 148

    (39) if_stmt -> IF ( expr ) stmt ELSE . stmt
    (30) stmt -> . compound_stmt
    (31) stmt -> . break_stmt
    (32) stmt -> . return_stmt
    (33) stmt -> . while_stmt
    (34) stmt -> . if_stmt
    (35) stmt -> . expr_stmt
    (21) compound_stmt -> . { local_decls stmt_list }
    (43) break_stmt -> . BREAK ;
    (41) return_stmt -> . RETURN expr ;
    (42) return_stmt -> . RETURN ;
    (38) while_stmt -> . WHILE ( expr ) stmt
    (39) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (40) if_stmt -> . IF ( expr ) stmt
    (36) expr_stmt -> . ;
    (37) expr_stmt -> . expr ;
    (44) expr -> . type_spec [ expr ]
    (45) expr -> . CHAR_LIT
    (46) expr -> . FLOAT_LIT
    (47) expr -> . INT_LIT
    (48) expr -> . FALSE
    (49) expr -> . TRUE
    (50) expr -> . IDENT . SIZE
    (51) expr -> . IDENT ( args )
    (52) expr -> . location
    (53) expr -> . ( expr )
    (54) expr -> . - expr
    (55) expr -> . + expr
    (56) expr -> . ! expr
    (57) expr -> . expr % expr
    (58) expr -> . expr / expr
    (59) expr -> . expr * expr
    (60) expr -> . expr - expr
    (61) expr -> . expr + expr
    (62) expr -> . expr > expr
    (63) expr -> . expr GE expr
    (64) expr -> . expr < expr
    (65) expr -> . expr LE expr
    (66) expr -> . expr NE expr
    (67) expr -> . expr EQ expr
    (68) expr -> . expr AND expr
    (69) expr -> . expr OR expr
    (70) expr -> . location = expr
    (10) type_spec -> . FLOAT
    (11) type_spec -> . INT
    (12) type_spec -> . BOOL
    (13) type_spec -> . VOID
    (71) location -> . IDENT [ expr ]
    (72) location -> . IDENT
    {               shift and go to state 70
    BREAK           shift and go to state 116
    RETURN          shift and go to state 118
    WHILE           shift and go to state 120
    IF              shift and go to state 121
    ;               shift and go to state 117
    CHAR_LIT        shift and go to state 29
    FLOAT_LIT       shift and go to state 30
    INT_LIT         shift and go to state 31
    FALSE           shift and go to state 32
    TRUE            shift and go to state 33
    IDENT           shift and go to state 27
    (               shift and go to state 34
    -               shift and go to state 36
    +               shift and go to state 37
    !               shift and go to state 38
    FLOAT           shift and go to state 8
    INT             shift and go to state 9
    BOOL            shift and go to state 10
    VOID            shift and go to state 11

    expr                           shift and go to state 119
    stmt                           shift and go to state 149
    compound_stmt                  shift and go to state 110
    break_stmt                     shift and go to state 111
    return_stmt                    shift and go to state 112
    while_stmt                     shift and go to state 113
    if_stmt                        shift and go to state 114
    expr_stmt                      shift and go to state 115
    type_spec                      shift and go to state 26
    location                       shift and go to state 35

state 149

    (39) if_stmt -> IF ( expr ) stmt ELSE stmt .
    }               reduce using rule 39 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    {               reduce using rule 39 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    BREAK           reduce using rule 39 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    RETURN          reduce using rule 39 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    WHILE           reduce using rule 39 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    IF              reduce using rule 39 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    ;               reduce using rule 39 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    CHAR_LIT        reduce using rule 39 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    FLOAT_LIT       reduce using rule 39 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    INT_LIT         reduce using rule 39 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    FALSE           reduce using rule 39 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    TRUE            reduce using rule 39 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    IDENT           reduce using rule 39 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    (               reduce using rule 39 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    -               reduce using rule 39 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    +               reduce using rule 39 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    !               reduce using rule 39 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    FLOAT           reduce using rule 39 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    INT             reduce using rule 39 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    BOOL            reduce using rule 39 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    VOID            reduce using rule 39 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    ELSE            reduce using rule 39 (if_stmt -> IF ( expr ) stmt ELSE stmt .)


Conflicts:

shift/reduce conflict for FLOAT in state 96 resolved as shift
shift/reduce conflict for INT in state 96 resolved as shift
shift/reduce conflict for BOOL in state 96 resolved as shift
shift/reduce conflict for VOID in state 96 resolved as shift