Grammar:

Rule 0     S' -> program
Rule 1     program -> decl_list
Rule 2     decl_list -> decl
Rule 3     decl_list -> decl_list decl
Rule 4     decl -> const_decl
Rule 5     decl -> fun_decl
Rule 6     decl -> var_decl
Rule 7     const_decl -> CONST IDENT = expr ;
Rule 8     var_decl -> type_spec IDENT [ ] ;
Rule 9     var_decl -> type_spec IDENT = expr ;
Rule 10    var_decl -> type_spec IDENT ;
Rule 11    type_spec -> CHAR
Rule 12    type_spec -> VOID
Rule 13    type_spec -> FLOAT
Rule 14    type_spec -> INT
Rule 15    type_spec -> BOOL
Rule 16    fun_decl -> type_spec IDENT ( params ) compound_stmt  [precedence=left, level=12]
Rule 17    params -> VOID
Rule 18    params -> param_list
Rule 19    param_list -> param
Rule 20    param_list -> param_list , param
Rule 21    param -> type_spec IDENT [ ]  [precedence=left, level=12]
Rule 22    param -> type_spec IDENT
Rule 23    compound_stmt -> { local_decls stmt_list }
Rule 24    local_decls -> empty
Rule 25    local_decls -> local_decls local_decl
Rule 26    local_decl -> type_spec IDENT [ ] ;
Rule 27    local_decl -> type_spec IDENT = expr ;
Rule 28    local_decl -> type_spec IDENT ;
Rule 29    stmt_list -> empty
Rule 30    stmt_list -> stmt_list stmt
Rule 31    stmt -> break_stmt
Rule 32    stmt -> return_stmt
Rule 33    stmt -> for_stmt
Rule 34    stmt -> while_stmt
Rule 35    stmt -> if_stmt
Rule 36    stmt -> compound_stmt
Rule 37    stmt -> expr_stmt
Rule 38    expr_stmt -> ;
Rule 39    expr_stmt -> expr ;
Rule 40    while_stmt -> WHILE ( expr ) compound_stmt  [precedence=left, level=12]
Rule 41    for_stmt -> FOR ( var_decl expr_stmt expr ) compound_stmt  [precedence=left, level=12]
Rule 42    if_stmt -> IF ( expr ) stmt  [precedence=nonassoc, level=1]
Rule 43    if_stmt -> IF ( expr ) stmt ELSE stmt  [precedence=nonassoc, level=2]
Rule 44    return_stmt -> RETURN expr ;
Rule 45    return_stmt -> RETURN ;
Rule 46    break_stmt -> BREAK ;
Rule 47    location -> IDENT [ expr ]  [precedence=left, level=12]
Rule 48    location -> IDENT
Rule 49    expr -> NEW type_spec [ expr ]  [precedence=left, level=12]
Rule 50    expr -> STRING_LIT
Rule 51    expr -> CHAR_LIT
Rule 52    expr -> FLOAT_LIT
Rule 53    expr -> INT_LIT
Rule 54    expr -> BOOL_LIT
Rule 55    expr -> IDENT . SIZE
Rule 56    expr -> IDENT ( args )  [precedence=left, level=12]
Rule 57    expr -> location
Rule 58    expr -> ( expr )  [precedence=left, level=12]
Rule 59    expr -> expr SUB  [precedence=right, level=11]
Rule 60    expr -> expr ADD  [precedence=right, level=11]
Rule 61    expr -> SUB expr  [precedence=right, level=11]
Rule 62    expr -> ADD expr  [precedence=right, level=11]
Rule 63    expr -> ! expr  [precedence=right, level=11]
Rule 64    expr -> + expr  [precedence=right, level=11]
Rule 65    expr -> - expr  [precedence=right, level=11]
Rule 66    expr -> expr % expr  [precedence=left, level=10]
Rule 67    expr -> expr / expr  [precedence=left, level=10]
Rule 68    expr -> expr * expr  [precedence=left, level=10]
Rule 69    expr -> expr - expr  [precedence=left, level=9]
Rule 70    expr -> expr + expr  [precedence=left, level=9]
Rule 71    expr -> expr MDE expr  [precedence=left, level=8]
Rule 72    expr -> expr TE expr  [precedence=left, level=8]
Rule 73    expr -> expr DE expr  [precedence=left, level=8]
Rule 74    expr -> expr PE expr  [precedence=left, level=8]
Rule 75    expr -> expr ME expr  [precedence=left, level=8]
Rule 76    expr -> expr > expr  [precedence=left, level=7]
Rule 77    expr -> expr GE expr  [precedence=left, level=7]
Rule 78    expr -> expr < expr  [precedence=left, level=7]
Rule 79    expr -> expr LE expr  [precedence=left, level=7]
Rule 80    expr -> expr NE expr  [precedence=left, level=6]
Rule 81    expr -> expr EQ expr  [precedence=left, level=6]
Rule 82    expr -> expr AND expr  [precedence=left, level=5]
Rule 83    expr -> expr OR expr  [precedence=left, level=4]
Rule 84    expr -> location = expr  [precedence=right, level=3]
Rule 85    arg_list -> expr
Rule 86    arg_list -> arg_list , expr
Rule 87    args -> empty
Rule 88    args -> arg_list
Rule 89    empty -> <empty>

Unused terminals:

    TRUE
    FALSE
    NOT
    MULEQ
    LT
    GT
    INC
    DELETE
    SUBEQ
    ADDEQ
    DO
    MODEQ
    DEC
    DIVEQ

Terminals, with rules where they appear:

!                    : 63
%                    : 66
(                    : 16 40 41 42 43 56 58
)                    : 16 40 41 42 43 56 58
*                    : 68
+                    : 64 70
,                    : 20 86
-                    : 65 69
.                    : 55
/                    : 67
;                    : 7 8 9 10 26 27 28 38 39 44 45 46
<                    : 78
=                    : 7 9 27 84
>                    : 76
ADD                  : 60 62
ADDEQ                : 
AND                  : 82
BOOL                 : 15
BOOL_LIT             : 54
BREAK                : 46
CHAR                 : 11
CHAR_LIT             : 51
CONST                : 7
DE                   : 73
DEC                  : 
DELETE               : 
DIVEQ                : 
DO                   : 
ELSE                 : 43
EQ                   : 81
FALSE                : 
FLOAT                : 13
FLOAT_LIT            : 52
FOR                  : 41
GE                   : 77
GT                   : 
IDENT                : 7 8 9 10 16 21 22 26 27 28 47 48 55 56
IF                   : 42 43
INC                  : 
INT                  : 14
INT_LIT              : 53
LE                   : 79
LT                   : 
MDE                  : 71
ME                   : 75
MODEQ                : 
MULEQ                : 
NE                   : 80
NEW                  : 49
NOT                  : 
OR                   : 83
PE                   : 74
RETURN               : 44 45
SIZE                 : 55
STRING_LIT           : 50
SUB                  : 59 61
SUBEQ                : 
TE                   : 72
TRUE                 : 
VOID                 : 12 17
WHILE                : 40
[                    : 8 21 26 47 49
]                    : 8 21 26 47 49
error                : 
{                    : 23
}                    : 23

Nonterminals, with rules where they appear:

arg_list             : 86 88
args                 : 56
break_stmt           : 31
compound_stmt        : 16 36 40 41
const_decl           : 4
decl                 : 2 3
decl_list            : 1 3
empty                : 24 29 87
expr                 : 7 9 27 39 40 41 42 43 44 47 49 58 59 60 61 62 63 64 65 66 66 67 67 68 68 69 69 70 70 71 71 72 72 73 73 74 74 75 75 76 76 77 77 78 78 79 79 80 80 81 81 82 82 83 83 84 85 86
expr_stmt            : 37 41
for_stmt             : 33
fun_decl             : 5
if_stmt              : 35
local_decl           : 25
local_decls          : 23 25
location             : 57 84
param                : 19 20
param_list           : 18 20
params               : 16
program              : 0
return_stmt          : 32
stmt                 : 30 42 43 43
stmt_list            : 23 30
type_spec            : 8 9 10 16 21 22 26 27 28 49
var_decl             : 6 41
while_stmt           : 34


state 0

    (0) S' -> . program
    (1) program -> . decl_list
    (2) decl_list -> . decl
    (3) decl_list -> . decl_list decl
    (4) decl -> . const_decl
    (5) decl -> . fun_decl
    (6) decl -> . var_decl
    (7) const_decl -> . CONST IDENT = expr ;
    (16) fun_decl -> . type_spec IDENT ( params ) compound_stmt
    (8) var_decl -> . type_spec IDENT [ ] ;
    (9) var_decl -> . type_spec IDENT = expr ;
    (10) var_decl -> . type_spec IDENT ;
    (11) type_spec -> . CHAR
    (12) type_spec -> . VOID
    (13) type_spec -> . FLOAT
    (14) type_spec -> . INT
    (15) type_spec -> . BOOL
    CONST           shift and go to state 7
    CHAR            shift and go to state 9
    VOID            shift and go to state 10
    FLOAT           shift and go to state 11
    INT             shift and go to state 12
    BOOL            shift and go to state 13

    program                        shift and go to state 1
    decl_list                      shift and go to state 2
    decl                           shift and go to state 3
    const_decl                     shift and go to state 4
    fun_decl                       shift and go to state 5
    var_decl                       shift and go to state 6
    type_spec                      shift and go to state 8

state 1

    (0) S' -> program .


state 2

    (1) program -> decl_list .
    (3) decl_list -> decl_list . decl
    (4) decl -> . const_decl
    (5) decl -> . fun_decl
    (6) decl -> . var_decl
    (7) const_decl -> . CONST IDENT = expr ;
    (16) fun_decl -> . type_spec IDENT ( params ) compound_stmt
    (8) var_decl -> . type_spec IDENT [ ] ;
    (9) var_decl -> . type_spec IDENT = expr ;
    (10) var_decl -> . type_spec IDENT ;
    (11) type_spec -> . CHAR
    (12) type_spec -> . VOID
    (13) type_spec -> . FLOAT
    (14) type_spec -> . INT
    (15) type_spec -> . BOOL
    $end            reduce using rule 1 (program -> decl_list .)
    CONST           shift and go to state 7
    CHAR            shift and go to state 9
    VOID            shift and go to state 10
    FLOAT           shift and go to state 11
    INT             shift and go to state 12
    BOOL            shift and go to state 13

    decl                           shift and go to state 14
    const_decl                     shift and go to state 4
    fun_decl                       shift and go to state 5
    var_decl                       shift and go to state 6
    type_spec                      shift and go to state 8

state 3

    (2) decl_list -> decl .
    CONST           reduce using rule 2 (decl_list -> decl .)
    CHAR            reduce using rule 2 (decl_list -> decl .)
    VOID            reduce using rule 2 (decl_list -> decl .)
    FLOAT           reduce using rule 2 (decl_list -> decl .)
    INT             reduce using rule 2 (decl_list -> decl .)
    BOOL            reduce using rule 2 (decl_list -> decl .)
    $end            reduce using rule 2 (decl_list -> decl .)


state 4

    (4) decl -> const_decl .
    CONST           reduce using rule 4 (decl -> const_decl .)
    CHAR            reduce using rule 4 (decl -> const_decl .)
    VOID            reduce using rule 4 (decl -> const_decl .)
    FLOAT           reduce using rule 4 (decl -> const_decl .)
    INT             reduce using rule 4 (decl -> const_decl .)
    BOOL            reduce using rule 4 (decl -> const_decl .)
    $end            reduce using rule 4 (decl -> const_decl .)


state 5

    (5) decl -> fun_decl .
    CONST           reduce using rule 5 (decl -> fun_decl .)
    CHAR            reduce using rule 5 (decl -> fun_decl .)
    VOID            reduce using rule 5 (decl -> fun_decl .)
    FLOAT           reduce using rule 5 (decl -> fun_decl .)
    INT             reduce using rule 5 (decl -> fun_decl .)
    BOOL            reduce using rule 5 (decl -> fun_decl .)
    $end            reduce using rule 5 (decl -> fun_decl .)


state 6

    (6) decl -> var_decl .
    CONST           reduce using rule 6 (decl -> var_decl .)
    CHAR            reduce using rule 6 (decl -> var_decl .)
    VOID            reduce using rule 6 (decl -> var_decl .)
    FLOAT           reduce using rule 6 (decl -> var_decl .)
    INT             reduce using rule 6 (decl -> var_decl .)
    BOOL            reduce using rule 6 (decl -> var_decl .)
    $end            reduce using rule 6 (decl -> var_decl .)


state 7

    (7) const_decl -> CONST . IDENT = expr ;
    IDENT           shift and go to state 15


state 8

    (16) fun_decl -> type_spec . IDENT ( params ) compound_stmt
    (8) var_decl -> type_spec . IDENT [ ] ;
    (9) var_decl -> type_spec . IDENT = expr ;
    (10) var_decl -> type_spec . IDENT ;
    IDENT           shift and go to state 16


state 9

    (11) type_spec -> CHAR .
    IDENT           reduce using rule 11 (type_spec -> CHAR .)
    [               reduce using rule 11 (type_spec -> CHAR .)


state 10

    (12) type_spec -> VOID .
    IDENT           reduce using rule 12 (type_spec -> VOID .)
    [               reduce using rule 12 (type_spec -> VOID .)


state 11

    (13) type_spec -> FLOAT .
    IDENT           reduce using rule 13 (type_spec -> FLOAT .)
    [               reduce using rule 13 (type_spec -> FLOAT .)


state 12

    (14) type_spec -> INT .
    IDENT           reduce using rule 14 (type_spec -> INT .)
    [               reduce using rule 14 (type_spec -> INT .)


state 13

    (15) type_spec -> BOOL .
    IDENT           reduce using rule 15 (type_spec -> BOOL .)
    [               reduce using rule 15 (type_spec -> BOOL .)


state 14

    (3) decl_list -> decl_list decl .
    CONST           reduce using rule 3 (decl_list -> decl_list decl .)
    CHAR            reduce using rule 3 (decl_list -> decl_list decl .)
    VOID            reduce using rule 3 (decl_list -> decl_list decl .)
    FLOAT           reduce using rule 3 (decl_list -> decl_list decl .)
    INT             reduce using rule 3 (decl_list -> decl_list decl .)
    BOOL            reduce using rule 3 (decl_list -> decl_list decl .)
    $end            reduce using rule 3 (decl_list -> decl_list decl .)


state 15

    (7) const_decl -> CONST IDENT . = expr ;
    =               shift and go to state 17


state 16

    (16) fun_decl -> type_spec IDENT . ( params ) compound_stmt
    (8) var_decl -> type_spec IDENT . [ ] ;
    (9) var_decl -> type_spec IDENT . = expr ;
    (10) var_decl -> type_spec IDENT . ;
    (               shift and go to state 18
    [               shift and go to state 19
    =               shift and go to state 21
    ;               shift and go to state 20


state 17

    (7) const_decl -> CONST IDENT = . expr ;
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . STRING_LIT
    (51) expr -> . CHAR_LIT
    (52) expr -> . FLOAT_LIT
    (53) expr -> . INT_LIT
    (54) expr -> . BOOL_LIT
    (55) expr -> . IDENT . SIZE
    (56) expr -> . IDENT ( args )
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . expr SUB
    (60) expr -> . expr ADD
    (61) expr -> . SUB expr
    (62) expr -> . ADD expr
    (63) expr -> . ! expr
    (64) expr -> . + expr
    (65) expr -> . - expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr MDE expr
    (72) expr -> . expr TE expr
    (73) expr -> . expr DE expr
    (74) expr -> . expr PE expr
    (75) expr -> . expr ME expr
    (76) expr -> . expr > expr
    (77) expr -> . expr GE expr
    (78) expr -> . expr < expr
    (79) expr -> . expr LE expr
    (80) expr -> . expr NE expr
    (81) expr -> . expr EQ expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . location = expr
    (47) location -> . IDENT [ expr ]
    (48) location -> . IDENT
    NEW             shift and go to state 24
    STRING_LIT      shift and go to state 25
    CHAR_LIT        shift and go to state 26
    FLOAT_LIT       shift and go to state 27
    INT_LIT         shift and go to state 28
    BOOL_LIT        shift and go to state 29
    IDENT           shift and go to state 22
    (               shift and go to state 30
    SUB             shift and go to state 32
    ADD             shift and go to state 33
    !               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36

    expr                           shift and go to state 23
    location                       shift and go to state 31

state 18

    (16) fun_decl -> type_spec IDENT ( . params ) compound_stmt
    (17) params -> . VOID
    (18) params -> . param_list
    (19) param_list -> . param
    (20) param_list -> . param_list , param
    (21) param -> . type_spec IDENT [ ]
    (22) param -> . type_spec IDENT
    (11) type_spec -> . CHAR
    (12) type_spec -> . VOID
    (13) type_spec -> . FLOAT
    (14) type_spec -> . INT
    (15) type_spec -> . BOOL
    VOID            shift and go to state 39
    CHAR            shift and go to state 9
    FLOAT           shift and go to state 11
    INT             shift and go to state 12
    BOOL            shift and go to state 13

    type_spec                      shift and go to state 37
    params                         shift and go to state 38
    param_list                     shift and go to state 40
    param                          shift and go to state 41

state 19

    (8) var_decl -> type_spec IDENT [ . ] ;
    ]               shift and go to state 42


state 20

    (10) var_decl -> type_spec IDENT ; .
    CONST           reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    CHAR            reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    VOID            reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    FLOAT           reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    INT             reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    BOOL            reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    $end            reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    ;               reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    NEW             reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    STRING_LIT      reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    CHAR_LIT        reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    FLOAT_LIT       reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    INT_LIT         reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    BOOL_LIT        reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    IDENT           reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    (               reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    SUB             reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    ADD             reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    !               reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    +               reduce using rule 10 (var_decl -> type_spec IDENT ; .)
    -               reduce using rule 10 (var_decl -> type_spec IDENT ; .)


state 21

    (9) var_decl -> type_spec IDENT = . expr ;
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . STRING_LIT
    (51) expr -> . CHAR_LIT
    (52) expr -> . FLOAT_LIT
    (53) expr -> . INT_LIT
    (54) expr -> . BOOL_LIT
    (55) expr -> . IDENT . SIZE
    (56) expr -> . IDENT ( args )
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . expr SUB
    (60) expr -> . expr ADD
    (61) expr -> . SUB expr
    (62) expr -> . ADD expr
    (63) expr -> . ! expr
    (64) expr -> . + expr
    (65) expr -> . - expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr MDE expr
    (72) expr -> . expr TE expr
    (73) expr -> . expr DE expr
    (74) expr -> . expr PE expr
    (75) expr -> . expr ME expr
    (76) expr -> . expr > expr
    (77) expr -> . expr GE expr
    (78) expr -> . expr < expr
    (79) expr -> . expr LE expr
    (80) expr -> . expr NE expr
    (81) expr -> . expr EQ expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . location = expr
    (47) location -> . IDENT [ expr ]
    (48) location -> . IDENT
    NEW             shift and go to state 24
    STRING_LIT      shift and go to state 25
    CHAR_LIT        shift and go to state 26
    FLOAT_LIT       shift and go to state 27
    INT_LIT         shift and go to state 28
    BOOL_LIT        shift and go to state 29
    IDENT           shift and go to state 22
    (               shift and go to state 30
    SUB             shift and go to state 32
    ADD             shift and go to state 33
    !               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36

    expr                           shift and go to state 43
    location                       shift and go to state 31

state 22

    (55) expr -> IDENT . . SIZE
    (56) expr -> IDENT . ( args )
    (47) location -> IDENT . [ expr ]
    (48) location -> IDENT .
    .               shift and go to state 44
    (               shift and go to state 45
    [               shift and go to state 46
    =               reduce using rule 48 (location -> IDENT .)
    ;               reduce using rule 48 (location -> IDENT .)
    SUB             reduce using rule 48 (location -> IDENT .)
    ADD             reduce using rule 48 (location -> IDENT .)
    %               reduce using rule 48 (location -> IDENT .)
    /               reduce using rule 48 (location -> IDENT .)
    *               reduce using rule 48 (location -> IDENT .)
    -               reduce using rule 48 (location -> IDENT .)
    +               reduce using rule 48 (location -> IDENT .)
    MDE             reduce using rule 48 (location -> IDENT .)
    TE              reduce using rule 48 (location -> IDENT .)
    DE              reduce using rule 48 (location -> IDENT .)
    PE              reduce using rule 48 (location -> IDENT .)
    ME              reduce using rule 48 (location -> IDENT .)
    >               reduce using rule 48 (location -> IDENT .)
    GE              reduce using rule 48 (location -> IDENT .)
    <               reduce using rule 48 (location -> IDENT .)
    LE              reduce using rule 48 (location -> IDENT .)
    NE              reduce using rule 48 (location -> IDENT .)
    EQ              reduce using rule 48 (location -> IDENT .)
    AND             reduce using rule 48 (location -> IDENT .)
    OR              reduce using rule 48 (location -> IDENT .)
    )               reduce using rule 48 (location -> IDENT .)
    ,               reduce using rule 48 (location -> IDENT .)
    ]               reduce using rule 48 (location -> IDENT .)


state 23

    (7) const_decl -> CONST IDENT = expr . ;
    (59) expr -> expr . SUB
    (60) expr -> expr . ADD
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . MDE expr
    (72) expr -> expr . TE expr
    (73) expr -> expr . DE expr
    (74) expr -> expr . PE expr
    (75) expr -> expr . ME expr
    (76) expr -> expr . > expr
    (77) expr -> expr . GE expr
    (78) expr -> expr . < expr
    (79) expr -> expr . LE expr
    (80) expr -> expr . NE expr
    (81) expr -> expr . EQ expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    ;               shift and go to state 47
    SUB             shift and go to state 48
    ADD             shift and go to state 49
    %               shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54
    MDE             shift and go to state 55
    TE              shift and go to state 56
    DE              shift and go to state 57
    PE              shift and go to state 58
    ME              shift and go to state 59
    >               shift and go to state 60
    GE              shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    NE              shift and go to state 64
    EQ              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 24

    (49) expr -> NEW . type_spec [ expr ]
    (11) type_spec -> . CHAR
    (12) type_spec -> . VOID
    (13) type_spec -> . FLOAT
    (14) type_spec -> . INT
    (15) type_spec -> . BOOL
    CHAR            shift and go to state 9
    VOID            shift and go to state 10
    FLOAT           shift and go to state 11
    INT             shift and go to state 12
    BOOL            shift and go to state 13

    type_spec                      shift and go to state 68

state 25

    (50) expr -> STRING_LIT .
    ;               reduce using rule 50 (expr -> STRING_LIT .)
    SUB             reduce using rule 50 (expr -> STRING_LIT .)
    ADD             reduce using rule 50 (expr -> STRING_LIT .)
    %               reduce using rule 50 (expr -> STRING_LIT .)
    /               reduce using rule 50 (expr -> STRING_LIT .)
    *               reduce using rule 50 (expr -> STRING_LIT .)
    -               reduce using rule 50 (expr -> STRING_LIT .)
    +               reduce using rule 50 (expr -> STRING_LIT .)
    MDE             reduce using rule 50 (expr -> STRING_LIT .)
    TE              reduce using rule 50 (expr -> STRING_LIT .)
    DE              reduce using rule 50 (expr -> STRING_LIT .)
    PE              reduce using rule 50 (expr -> STRING_LIT .)
    ME              reduce using rule 50 (expr -> STRING_LIT .)
    >               reduce using rule 50 (expr -> STRING_LIT .)
    GE              reduce using rule 50 (expr -> STRING_LIT .)
    <               reduce using rule 50 (expr -> STRING_LIT .)
    LE              reduce using rule 50 (expr -> STRING_LIT .)
    NE              reduce using rule 50 (expr -> STRING_LIT .)
    EQ              reduce using rule 50 (expr -> STRING_LIT .)
    AND             reduce using rule 50 (expr -> STRING_LIT .)
    OR              reduce using rule 50 (expr -> STRING_LIT .)
    )               reduce using rule 50 (expr -> STRING_LIT .)
    ,               reduce using rule 50 (expr -> STRING_LIT .)
    ]               reduce using rule 50 (expr -> STRING_LIT .)


state 26

    (51) expr -> CHAR_LIT .
    ;               reduce using rule 51 (expr -> CHAR_LIT .)
    SUB             reduce using rule 51 (expr -> CHAR_LIT .)
    ADD             reduce using rule 51 (expr -> CHAR_LIT .)
    %               reduce using rule 51 (expr -> CHAR_LIT .)
    /               reduce using rule 51 (expr -> CHAR_LIT .)
    *               reduce using rule 51 (expr -> CHAR_LIT .)
    -               reduce using rule 51 (expr -> CHAR_LIT .)
    +               reduce using rule 51 (expr -> CHAR_LIT .)
    MDE             reduce using rule 51 (expr -> CHAR_LIT .)
    TE              reduce using rule 51 (expr -> CHAR_LIT .)
    DE              reduce using rule 51 (expr -> CHAR_LIT .)
    PE              reduce using rule 51 (expr -> CHAR_LIT .)
    ME              reduce using rule 51 (expr -> CHAR_LIT .)
    >               reduce using rule 51 (expr -> CHAR_LIT .)
    GE              reduce using rule 51 (expr -> CHAR_LIT .)
    <               reduce using rule 51 (expr -> CHAR_LIT .)
    LE              reduce using rule 51 (expr -> CHAR_LIT .)
    NE              reduce using rule 51 (expr -> CHAR_LIT .)
    EQ              reduce using rule 51 (expr -> CHAR_LIT .)
    AND             reduce using rule 51 (expr -> CHAR_LIT .)
    OR              reduce using rule 51 (expr -> CHAR_LIT .)
    )               reduce using rule 51 (expr -> CHAR_LIT .)
    ,               reduce using rule 51 (expr -> CHAR_LIT .)
    ]               reduce using rule 51 (expr -> CHAR_LIT .)


state 27

    (52) expr -> FLOAT_LIT .
    ;               reduce using rule 52 (expr -> FLOAT_LIT .)
    SUB             reduce using rule 52 (expr -> FLOAT_LIT .)
    ADD             reduce using rule 52 (expr -> FLOAT_LIT .)
    %               reduce using rule 52 (expr -> FLOAT_LIT .)
    /               reduce using rule 52 (expr -> FLOAT_LIT .)
    *               reduce using rule 52 (expr -> FLOAT_LIT .)
    -               reduce using rule 52 (expr -> FLOAT_LIT .)
    +               reduce using rule 52 (expr -> FLOAT_LIT .)
    MDE             reduce using rule 52 (expr -> FLOAT_LIT .)
    TE              reduce using rule 52 (expr -> FLOAT_LIT .)
    DE              reduce using rule 52 (expr -> FLOAT_LIT .)
    PE              reduce using rule 52 (expr -> FLOAT_LIT .)
    ME              reduce using rule 52 (expr -> FLOAT_LIT .)
    >               reduce using rule 52 (expr -> FLOAT_LIT .)
    GE              reduce using rule 52 (expr -> FLOAT_LIT .)
    <               reduce using rule 52 (expr -> FLOAT_LIT .)
    LE              reduce using rule 52 (expr -> FLOAT_LIT .)
    NE              reduce using rule 52 (expr -> FLOAT_LIT .)
    EQ              reduce using rule 52 (expr -> FLOAT_LIT .)
    AND             reduce using rule 52 (expr -> FLOAT_LIT .)
    OR              reduce using rule 52 (expr -> FLOAT_LIT .)
    )               reduce using rule 52 (expr -> FLOAT_LIT .)
    ,               reduce using rule 52 (expr -> FLOAT_LIT .)
    ]               reduce using rule 52 (expr -> FLOAT_LIT .)


state 28

    (53) expr -> INT_LIT .
    ;               reduce using rule 53 (expr -> INT_LIT .)
    SUB             reduce using rule 53 (expr -> INT_LIT .)
    ADD             reduce using rule 53 (expr -> INT_LIT .)
    %               reduce using rule 53 (expr -> INT_LIT .)
    /               reduce using rule 53 (expr -> INT_LIT .)
    *               reduce using rule 53 (expr -> INT_LIT .)
    -               reduce using rule 53 (expr -> INT_LIT .)
    +               reduce using rule 53 (expr -> INT_LIT .)
    MDE             reduce using rule 53 (expr -> INT_LIT .)
    TE              reduce using rule 53 (expr -> INT_LIT .)
    DE              reduce using rule 53 (expr -> INT_LIT .)
    PE              reduce using rule 53 (expr -> INT_LIT .)
    ME              reduce using rule 53 (expr -> INT_LIT .)
    >               reduce using rule 53 (expr -> INT_LIT .)
    GE              reduce using rule 53 (expr -> INT_LIT .)
    <               reduce using rule 53 (expr -> INT_LIT .)
    LE              reduce using rule 53 (expr -> INT_LIT .)
    NE              reduce using rule 53 (expr -> INT_LIT .)
    EQ              reduce using rule 53 (expr -> INT_LIT .)
    AND             reduce using rule 53 (expr -> INT_LIT .)
    OR              reduce using rule 53 (expr -> INT_LIT .)
    )               reduce using rule 53 (expr -> INT_LIT .)
    ,               reduce using rule 53 (expr -> INT_LIT .)
    ]               reduce using rule 53 (expr -> INT_LIT .)


state 29

    (54) expr -> BOOL_LIT .
    ;               reduce using rule 54 (expr -> BOOL_LIT .)
    SUB             reduce using rule 54 (expr -> BOOL_LIT .)
    ADD             reduce using rule 54 (expr -> BOOL_LIT .)
    %               reduce using rule 54 (expr -> BOOL_LIT .)
    /               reduce using rule 54 (expr -> BOOL_LIT .)
    *               reduce using rule 54 (expr -> BOOL_LIT .)
    -               reduce using rule 54 (expr -> BOOL_LIT .)
    +               reduce using rule 54 (expr -> BOOL_LIT .)
    MDE             reduce using rule 54 (expr -> BOOL_LIT .)
    TE              reduce using rule 54 (expr -> BOOL_LIT .)
    DE              reduce using rule 54 (expr -> BOOL_LIT .)
    PE              reduce using rule 54 (expr -> BOOL_LIT .)
    ME              reduce using rule 54 (expr -> BOOL_LIT .)
    >               reduce using rule 54 (expr -> BOOL_LIT .)
    GE              reduce using rule 54 (expr -> BOOL_LIT .)
    <               reduce using rule 54 (expr -> BOOL_LIT .)
    LE              reduce using rule 54 (expr -> BOOL_LIT .)
    NE              reduce using rule 54 (expr -> BOOL_LIT .)
    EQ              reduce using rule 54 (expr -> BOOL_LIT .)
    AND             reduce using rule 54 (expr -> BOOL_LIT .)
    OR              reduce using rule 54 (expr -> BOOL_LIT .)
    )               reduce using rule 54 (expr -> BOOL_LIT .)
    ,               reduce using rule 54 (expr -> BOOL_LIT .)
    ]               reduce using rule 54 (expr -> BOOL_LIT .)


state 30

    (58) expr -> ( . expr )
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . STRING_LIT
    (51) expr -> . CHAR_LIT
    (52) expr -> . FLOAT_LIT
    (53) expr -> . INT_LIT
    (54) expr -> . BOOL_LIT
    (55) expr -> . IDENT . SIZE
    (56) expr -> . IDENT ( args )
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . expr SUB
    (60) expr -> . expr ADD
    (61) expr -> . SUB expr
    (62) expr -> . ADD expr
    (63) expr -> . ! expr
    (64) expr -> . + expr
    (65) expr -> . - expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr MDE expr
    (72) expr -> . expr TE expr
    (73) expr -> . expr DE expr
    (74) expr -> . expr PE expr
    (75) expr -> . expr ME expr
    (76) expr -> . expr > expr
    (77) expr -> . expr GE expr
    (78) expr -> . expr < expr
    (79) expr -> . expr LE expr
    (80) expr -> . expr NE expr
    (81) expr -> . expr EQ expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . location = expr
    (47) location -> . IDENT [ expr ]
    (48) location -> . IDENT
    NEW             shift and go to state 24
    STRING_LIT      shift and go to state 25
    CHAR_LIT        shift and go to state 26
    FLOAT_LIT       shift and go to state 27
    INT_LIT         shift and go to state 28
    BOOL_LIT        shift and go to state 29
    IDENT           shift and go to state 22
    (               shift and go to state 30
    SUB             shift and go to state 32
    ADD             shift and go to state 33
    !               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36

    expr                           shift and go to state 69
    location                       shift and go to state 31

state 31

    (57) expr -> location .
    (84) expr -> location . = expr
    ;               reduce using rule 57 (expr -> location .)
    SUB             reduce using rule 57 (expr -> location .)
    ADD             reduce using rule 57 (expr -> location .)
    %               reduce using rule 57 (expr -> location .)
    /               reduce using rule 57 (expr -> location .)
    *               reduce using rule 57 (expr -> location .)
    -               reduce using rule 57 (expr -> location .)
    +               reduce using rule 57 (expr -> location .)
    MDE             reduce using rule 57 (expr -> location .)
    TE              reduce using rule 57 (expr -> location .)
    DE              reduce using rule 57 (expr -> location .)
    PE              reduce using rule 57 (expr -> location .)
    ME              reduce using rule 57 (expr -> location .)
    >               reduce using rule 57 (expr -> location .)
    GE              reduce using rule 57 (expr -> location .)
    <               reduce using rule 57 (expr -> location .)
    LE              reduce using rule 57 (expr -> location .)
    NE              reduce using rule 57 (expr -> location .)
    EQ              reduce using rule 57 (expr -> location .)
    AND             reduce using rule 57 (expr -> location .)
    OR              reduce using rule 57 (expr -> location .)
    )               reduce using rule 57 (expr -> location .)
    ,               reduce using rule 57 (expr -> location .)
    ]               reduce using rule 57 (expr -> location .)
    =               shift and go to state 70


state 32

    (61) expr -> SUB . expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . STRING_LIT
    (51) expr -> . CHAR_LIT
    (52) expr -> . FLOAT_LIT
    (53) expr -> . INT_LIT
    (54) expr -> . BOOL_LIT
    (55) expr -> . IDENT . SIZE
    (56) expr -> . IDENT ( args )
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . expr SUB
    (60) expr -> . expr ADD
    (61) expr -> . SUB expr
    (62) expr -> . ADD expr
    (63) expr -> . ! expr
    (64) expr -> . + expr
    (65) expr -> . - expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr MDE expr
    (72) expr -> . expr TE expr
    (73) expr -> . expr DE expr
    (74) expr -> . expr PE expr
    (75) expr -> . expr ME expr
    (76) expr -> . expr > expr
    (77) expr -> . expr GE expr
    (78) expr -> . expr < expr
    (79) expr -> . expr LE expr
    (80) expr -> . expr NE expr
    (81) expr -> . expr EQ expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . location = expr
    (47) location -> . IDENT [ expr ]
    (48) location -> . IDENT
    NEW             shift and go to state 24
    STRING_LIT      shift and go to state 25
    CHAR_LIT        shift and go to state 26
    FLOAT_LIT       shift and go to state 27
    INT_LIT         shift and go to state 28
    BOOL_LIT        shift and go to state 29
    IDENT           shift and go to state 22
    (               shift and go to state 30
    SUB             shift and go to state 32
    ADD             shift and go to state 33
    !               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36

    expr                           shift and go to state 71
    location                       shift and go to state 31

state 33

    (62) expr -> ADD . expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . STRING_LIT
    (51) expr -> . CHAR_LIT
    (52) expr -> . FLOAT_LIT
    (53) expr -> . INT_LIT
    (54) expr -> . BOOL_LIT
    (55) expr -> . IDENT . SIZE
    (56) expr -> . IDENT ( args )
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . expr SUB
    (60) expr -> . expr ADD
    (61) expr -> . SUB expr
    (62) expr -> . ADD expr
    (63) expr -> . ! expr
    (64) expr -> . + expr
    (65) expr -> . - expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr MDE expr
    (72) expr -> . expr TE expr
    (73) expr -> . expr DE expr
    (74) expr -> . expr PE expr
    (75) expr -> . expr ME expr
    (76) expr -> . expr > expr
    (77) expr -> . expr GE expr
    (78) expr -> . expr < expr
    (79) expr -> . expr LE expr
    (80) expr -> . expr NE expr
    (81) expr -> . expr EQ expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . location = expr
    (47) location -> . IDENT [ expr ]
    (48) location -> . IDENT
    NEW             shift and go to state 24
    STRING_LIT      shift and go to state 25
    CHAR_LIT        shift and go to state 26
    FLOAT_LIT       shift and go to state 27
    INT_LIT         shift and go to state 28
    BOOL_LIT        shift and go to state 29
    IDENT           shift and go to state 22
    (               shift and go to state 30
    SUB             shift and go to state 32
    ADD             shift and go to state 33
    !               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36

    expr                           shift and go to state 72
    location                       shift and go to state 31

state 34

    (63) expr -> ! . expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . STRING_LIT
    (51) expr -> . CHAR_LIT
    (52) expr -> . FLOAT_LIT
    (53) expr -> . INT_LIT
    (54) expr -> . BOOL_LIT
    (55) expr -> . IDENT . SIZE
    (56) expr -> . IDENT ( args )
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . expr SUB
    (60) expr -> . expr ADD
    (61) expr -> . SUB expr
    (62) expr -> . ADD expr
    (63) expr -> . ! expr
    (64) expr -> . + expr
    (65) expr -> . - expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr MDE expr
    (72) expr -> . expr TE expr
    (73) expr -> . expr DE expr
    (74) expr -> . expr PE expr
    (75) expr -> . expr ME expr
    (76) expr -> . expr > expr
    (77) expr -> . expr GE expr
    (78) expr -> . expr < expr
    (79) expr -> . expr LE expr
    (80) expr -> . expr NE expr
    (81) expr -> . expr EQ expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . location = expr
    (47) location -> . IDENT [ expr ]
    (48) location -> . IDENT
    NEW             shift and go to state 24
    STRING_LIT      shift and go to state 25
    CHAR_LIT        shift and go to state 26
    FLOAT_LIT       shift and go to state 27
    INT_LIT         shift and go to state 28
    BOOL_LIT        shift and go to state 29
    IDENT           shift and go to state 22
    (               shift and go to state 30
    SUB             shift and go to state 32
    ADD             shift and go to state 33
    !               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36

    expr                           shift and go to state 73
    location                       shift and go to state 31

state 35

    (64) expr -> + . expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . STRING_LIT
    (51) expr -> . CHAR_LIT
    (52) expr -> . FLOAT_LIT
    (53) expr -> . INT_LIT
    (54) expr -> . BOOL_LIT
    (55) expr -> . IDENT . SIZE
    (56) expr -> . IDENT ( args )
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . expr SUB
    (60) expr -> . expr ADD
    (61) expr -> . SUB expr
    (62) expr -> . ADD expr
    (63) expr -> . ! expr
    (64) expr -> . + expr
    (65) expr -> . - expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr MDE expr
    (72) expr -> . expr TE expr
    (73) expr -> . expr DE expr
    (74) expr -> . expr PE expr
    (75) expr -> . expr ME expr
    (76) expr -> . expr > expr
    (77) expr -> . expr GE expr
    (78) expr -> . expr < expr
    (79) expr -> . expr LE expr
    (80) expr -> . expr NE expr
    (81) expr -> . expr EQ expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . location = expr
    (47) location -> . IDENT [ expr ]
    (48) location -> . IDENT
    NEW             shift and go to state 24
    STRING_LIT      shift and go to state 25
    CHAR_LIT        shift and go to state 26
    FLOAT_LIT       shift and go to state 27
    INT_LIT         shift and go to state 28
    BOOL_LIT        shift and go to state 29
    IDENT           shift and go to state 22
    (               shift and go to state 30
    SUB             shift and go to state 32
    ADD             shift and go to state 33
    !               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36

    expr                           shift and go to state 74
    location                       shift and go to state 31

state 36

    (65) expr -> - . expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . STRING_LIT
    (51) expr -> . CHAR_LIT
    (52) expr -> . FLOAT_LIT
    (53) expr -> . INT_LIT
    (54) expr -> . BOOL_LIT
    (55) expr -> . IDENT . SIZE
    (56) expr -> . IDENT ( args )
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . expr SUB
    (60) expr -> . expr ADD
    (61) expr -> . SUB expr
    (62) expr -> . ADD expr
    (63) expr -> . ! expr
    (64) expr -> . + expr
    (65) expr -> . - expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr MDE expr
    (72) expr -> . expr TE expr
    (73) expr -> . expr DE expr
    (74) expr -> . expr PE expr
    (75) expr -> . expr ME expr
    (76) expr -> . expr > expr
    (77) expr -> . expr GE expr
    (78) expr -> . expr < expr
    (79) expr -> . expr LE expr
    (80) expr -> . expr NE expr
    (81) expr -> . expr EQ expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . location = expr
    (47) location -> . IDENT [ expr ]
    (48) location -> . IDENT
    NEW             shift and go to state 24
    STRING_LIT      shift and go to state 25
    CHAR_LIT        shift and go to state 26
    FLOAT_LIT       shift and go to state 27
    INT_LIT         shift and go to state 28
    BOOL_LIT        shift and go to state 29
    IDENT           shift and go to state 22
    (               shift and go to state 30
    SUB             shift and go to state 32
    ADD             shift and go to state 33
    !               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36

    expr                           shift and go to state 75
    location                       shift and go to state 31

state 37

    (21) param -> type_spec . IDENT [ ]
    (22) param -> type_spec . IDENT
    IDENT           shift and go to state 76


state 38

    (16) fun_decl -> type_spec IDENT ( params . ) compound_stmt
    )               shift and go to state 77


state 39

    (17) params -> VOID .
    (12) type_spec -> VOID .
    )               reduce using rule 17 (params -> VOID .)
    IDENT           reduce using rule 12 (type_spec -> VOID .)


state 40

    (18) params -> param_list .
    (20) param_list -> param_list . , param
    )               reduce using rule 18 (params -> param_list .)
    ,               shift and go to state 78


state 41

    (19) param_list -> param .
    ,               reduce using rule 19 (param_list -> param .)
    )               reduce using rule 19 (param_list -> param .)


state 42

    (8) var_decl -> type_spec IDENT [ ] . ;
    ;               shift and go to state 79


state 43

    (9) var_decl -> type_spec IDENT = expr . ;
    (59) expr -> expr . SUB
    (60) expr -> expr . ADD
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . MDE expr
    (72) expr -> expr . TE expr
    (73) expr -> expr . DE expr
    (74) expr -> expr . PE expr
    (75) expr -> expr . ME expr
    (76) expr -> expr . > expr
    (77) expr -> expr . GE expr
    (78) expr -> expr . < expr
    (79) expr -> expr . LE expr
    (80) expr -> expr . NE expr
    (81) expr -> expr . EQ expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    ;               shift and go to state 80
    SUB             shift and go to state 48
    ADD             shift and go to state 49
    %               shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54
    MDE             shift and go to state 55
    TE              shift and go to state 56
    DE              shift and go to state 57
    PE              shift and go to state 58
    ME              shift and go to state 59
    >               shift and go to state 60
    GE              shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    NE              shift and go to state 64
    EQ              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 44

    (55) expr -> IDENT . . SIZE
    SIZE            shift and go to state 81


state 45

    (56) expr -> IDENT ( . args )
    (87) args -> . empty
    (88) args -> . arg_list
    (89) empty -> .
    (85) arg_list -> . expr
    (86) arg_list -> . arg_list , expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . STRING_LIT
    (51) expr -> . CHAR_LIT
    (52) expr -> . FLOAT_LIT
    (53) expr -> . INT_LIT
    (54) expr -> . BOOL_LIT
    (55) expr -> . IDENT . SIZE
    (56) expr -> . IDENT ( args )
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . expr SUB
    (60) expr -> . expr ADD
    (61) expr -> . SUB expr
    (62) expr -> . ADD expr
    (63) expr -> . ! expr
    (64) expr -> . + expr
    (65) expr -> . - expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr MDE expr
    (72) expr -> . expr TE expr
    (73) expr -> . expr DE expr
    (74) expr -> . expr PE expr
    (75) expr -> . expr ME expr
    (76) expr -> . expr > expr
    (77) expr -> . expr GE expr
    (78) expr -> . expr < expr
    (79) expr -> . expr LE expr
    (80) expr -> . expr NE expr
    (81) expr -> . expr EQ expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . location = expr
    (47) location -> . IDENT [ expr ]
    (48) location -> . IDENT
    )               reduce using rule 89 (empty -> .)
    NEW             shift and go to state 24
    STRING_LIT      shift and go to state 25
    CHAR_LIT        shift and go to state 26
    FLOAT_LIT       shift and go to state 27
    INT_LIT         shift and go to state 28
    BOOL_LIT        shift and go to state 29
    IDENT           shift and go to state 22
    (               shift and go to state 30
    SUB             shift and go to state 32
    ADD             shift and go to state 33
    !               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36

    args                           shift and go to state 82
    empty                          shift and go to state 83
    arg_list                       shift and go to state 84
    expr                           shift and go to state 85
    location                       shift and go to state 31

state 46

    (47) location -> IDENT [ . expr ]
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . STRING_LIT
    (51) expr -> . CHAR_LIT
    (52) expr -> . FLOAT_LIT
    (53) expr -> . INT_LIT
    (54) expr -> . BOOL_LIT
    (55) expr -> . IDENT . SIZE
    (56) expr -> . IDENT ( args )
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . expr SUB
    (60) expr -> . expr ADD
    (61) expr -> . SUB expr
    (62) expr -> . ADD expr
    (63) expr -> . ! expr
    (64) expr -> . + expr
    (65) expr -> . - expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr MDE expr
    (72) expr -> . expr TE expr
    (73) expr -> . expr DE expr
    (74) expr -> . expr PE expr
    (75) expr -> . expr ME expr
    (76) expr -> . expr > expr
    (77) expr -> . expr GE expr
    (78) expr -> . expr < expr
    (79) expr -> . expr LE expr
    (80) expr -> . expr NE expr
    (81) expr -> . expr EQ expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . location = expr
    (47) location -> . IDENT [ expr ]
    (48) location -> . IDENT
    NEW             shift and go to state 24
    STRING_LIT      shift and go to state 25
    CHAR_LIT        shift and go to state 26
    FLOAT_LIT       shift and go to state 27
    INT_LIT         shift and go to state 28
    BOOL_LIT        shift and go to state 29
    IDENT           shift and go to state 22
    (               shift and go to state 30
    SUB             shift and go to state 32
    ADD             shift and go to state 33
    !               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36

    expr                           shift and go to state 86
    location                       shift and go to state 31

state 47

    (7) const_decl -> CONST IDENT = expr ; .
    CONST           reduce using rule 7 (const_decl -> CONST IDENT = expr ; .)
    CHAR            reduce using rule 7 (const_decl -> CONST IDENT = expr ; .)
    VOID            reduce using rule 7 (const_decl -> CONST IDENT = expr ; .)
    FLOAT           reduce using rule 7 (const_decl -> CONST IDENT = expr ; .)
    INT             reduce using rule 7 (const_decl -> CONST IDENT = expr ; .)
    BOOL            reduce using rule 7 (const_decl -> CONST IDENT = expr ; .)
    $end            reduce using rule 7 (const_decl -> CONST IDENT = expr ; .)


state 48

    (59) expr -> expr SUB .
    ;               reduce using rule 59 (expr -> expr SUB .)
    SUB             reduce using rule 59 (expr -> expr SUB .)
    ADD             reduce using rule 59 (expr -> expr SUB .)
    %               reduce using rule 59 (expr -> expr SUB .)
    /               reduce using rule 59 (expr -> expr SUB .)
    *               reduce using rule 59 (expr -> expr SUB .)
    -               reduce using rule 59 (expr -> expr SUB .)
    +               reduce using rule 59 (expr -> expr SUB .)
    MDE             reduce using rule 59 (expr -> expr SUB .)
    TE              reduce using rule 59 (expr -> expr SUB .)
    DE              reduce using rule 59 (expr -> expr SUB .)
    PE              reduce using rule 59 (expr -> expr SUB .)
    ME              reduce using rule 59 (expr -> expr SUB .)
    >               reduce using rule 59 (expr -> expr SUB .)
    GE              reduce using rule 59 (expr -> expr SUB .)
    <               reduce using rule 59 (expr -> expr SUB .)
    LE              reduce using rule 59 (expr -> expr SUB .)
    NE              reduce using rule 59 (expr -> expr SUB .)
    EQ              reduce using rule 59 (expr -> expr SUB .)
    AND             reduce using rule 59 (expr -> expr SUB .)
    OR              reduce using rule 59 (expr -> expr SUB .)
    )               reduce using rule 59 (expr -> expr SUB .)
    ,               reduce using rule 59 (expr -> expr SUB .)
    ]               reduce using rule 59 (expr -> expr SUB .)


state 49

    (60) expr -> expr ADD .
    ;               reduce using rule 60 (expr -> expr ADD .)
    SUB             reduce using rule 60 (expr -> expr ADD .)
    ADD             reduce using rule 60 (expr -> expr ADD .)
    %               reduce using rule 60 (expr -> expr ADD .)
    /               reduce using rule 60 (expr -> expr ADD .)
    *               reduce using rule 60 (expr -> expr ADD .)
    -               reduce using rule 60 (expr -> expr ADD .)
    +               reduce using rule 60 (expr -> expr ADD .)
    MDE             reduce using rule 60 (expr -> expr ADD .)
    TE              reduce using rule 60 (expr -> expr ADD .)
    DE              reduce using rule 60 (expr -> expr ADD .)
    PE              reduce using rule 60 (expr -> expr ADD .)
    ME              reduce using rule 60 (expr -> expr ADD .)
    >               reduce using rule 60 (expr -> expr ADD .)
    GE              reduce using rule 60 (expr -> expr ADD .)
    <               reduce using rule 60 (expr -> expr ADD .)
    LE              reduce using rule 60 (expr -> expr ADD .)
    NE              reduce using rule 60 (expr -> expr ADD .)
    EQ              reduce using rule 60 (expr -> expr ADD .)
    AND             reduce using rule 60 (expr -> expr ADD .)
    OR              reduce using rule 60 (expr -> expr ADD .)
    )               reduce using rule 60 (expr -> expr ADD .)
    ,               reduce using rule 60 (expr -> expr ADD .)
    ]               reduce using rule 60 (expr -> expr ADD .)


state 50

    (66) expr -> expr % . expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . STRING_LIT
    (51) expr -> . CHAR_LIT
    (52) expr -> . FLOAT_LIT
    (53) expr -> . INT_LIT
    (54) expr -> . BOOL_LIT
    (55) expr -> . IDENT . SIZE
    (56) expr -> . IDENT ( args )
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . expr SUB
    (60) expr -> . expr ADD
    (61) expr -> . SUB expr
    (62) expr -> . ADD expr
    (63) expr -> . ! expr
    (64) expr -> . + expr
    (65) expr -> . - expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr MDE expr
    (72) expr -> . expr TE expr
    (73) expr -> . expr DE expr
    (74) expr -> . expr PE expr
    (75) expr -> . expr ME expr
    (76) expr -> . expr > expr
    (77) expr -> . expr GE expr
    (78) expr -> . expr < expr
    (79) expr -> . expr LE expr
    (80) expr -> . expr NE expr
    (81) expr -> . expr EQ expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . location = expr
    (47) location -> . IDENT [ expr ]
    (48) location -> . IDENT
    NEW             shift and go to state 24
    STRING_LIT      shift and go to state 25
    CHAR_LIT        shift and go to state 26
    FLOAT_LIT       shift and go to state 27
    INT_LIT         shift and go to state 28
    BOOL_LIT        shift and go to state 29
    IDENT           shift and go to state 22
    (               shift and go to state 30
    SUB             shift and go to state 32
    ADD             shift and go to state 33
    !               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36

    expr                           shift and go to state 87
    location                       shift and go to state 31

state 51

    (67) expr -> expr / . expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . STRING_LIT
    (51) expr -> . CHAR_LIT
    (52) expr -> . FLOAT_LIT
    (53) expr -> . INT_LIT
    (54) expr -> . BOOL_LIT
    (55) expr -> . IDENT . SIZE
    (56) expr -> . IDENT ( args )
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . expr SUB
    (60) expr -> . expr ADD
    (61) expr -> . SUB expr
    (62) expr -> . ADD expr
    (63) expr -> . ! expr
    (64) expr -> . + expr
    (65) expr -> . - expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr MDE expr
    (72) expr -> . expr TE expr
    (73) expr -> . expr DE expr
    (74) expr -> . expr PE expr
    (75) expr -> . expr ME expr
    (76) expr -> . expr > expr
    (77) expr -> . expr GE expr
    (78) expr -> . expr < expr
    (79) expr -> . expr LE expr
    (80) expr -> . expr NE expr
    (81) expr -> . expr EQ expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . location = expr
    (47) location -> . IDENT [ expr ]
    (48) location -> . IDENT
    NEW             shift and go to state 24
    STRING_LIT      shift and go to state 25
    CHAR_LIT        shift and go to state 26
    FLOAT_LIT       shift and go to state 27
    INT_LIT         shift and go to state 28
    BOOL_LIT        shift and go to state 29
    IDENT           shift and go to state 22
    (               shift and go to state 30
    SUB             shift and go to state 32
    ADD             shift and go to state 33
    !               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36

    expr                           shift and go to state 88
    location                       shift and go to state 31

state 52

    (68) expr -> expr * . expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . STRING_LIT
    (51) expr -> . CHAR_LIT
    (52) expr -> . FLOAT_LIT
    (53) expr -> . INT_LIT
    (54) expr -> . BOOL_LIT
    (55) expr -> . IDENT . SIZE
    (56) expr -> . IDENT ( args )
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . expr SUB
    (60) expr -> . expr ADD
    (61) expr -> . SUB expr
    (62) expr -> . ADD expr
    (63) expr -> . ! expr
    (64) expr -> . + expr
    (65) expr -> . - expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr MDE expr
    (72) expr -> . expr TE expr
    (73) expr -> . expr DE expr
    (74) expr -> . expr PE expr
    (75) expr -> . expr ME expr
    (76) expr -> . expr > expr
    (77) expr -> . expr GE expr
    (78) expr -> . expr < expr
    (79) expr -> . expr LE expr
    (80) expr -> . expr NE expr
    (81) expr -> . expr EQ expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . location = expr
    (47) location -> . IDENT [ expr ]
    (48) location -> . IDENT
    NEW             shift and go to state 24
    STRING_LIT      shift and go to state 25
    CHAR_LIT        shift and go to state 26
    FLOAT_LIT       shift and go to state 27
    INT_LIT         shift and go to state 28
    BOOL_LIT        shift and go to state 29
    IDENT           shift and go to state 22
    (               shift and go to state 30
    SUB             shift and go to state 32
    ADD             shift and go to state 33
    !               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36

    expr                           shift and go to state 89
    location                       shift and go to state 31

state 53

    (69) expr -> expr - . expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . STRING_LIT
    (51) expr -> . CHAR_LIT
    (52) expr -> . FLOAT_LIT
    (53) expr -> . INT_LIT
    (54) expr -> . BOOL_LIT
    (55) expr -> . IDENT . SIZE
    (56) expr -> . IDENT ( args )
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . expr SUB
    (60) expr -> . expr ADD
    (61) expr -> . SUB expr
    (62) expr -> . ADD expr
    (63) expr -> . ! expr
    (64) expr -> . + expr
    (65) expr -> . - expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr MDE expr
    (72) expr -> . expr TE expr
    (73) expr -> . expr DE expr
    (74) expr -> . expr PE expr
    (75) expr -> . expr ME expr
    (76) expr -> . expr > expr
    (77) expr -> . expr GE expr
    (78) expr -> . expr < expr
    (79) expr -> . expr LE expr
    (80) expr -> . expr NE expr
    (81) expr -> . expr EQ expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . location = expr
    (47) location -> . IDENT [ expr ]
    (48) location -> . IDENT
    NEW             shift and go to state 24
    STRING_LIT      shift and go to state 25
    CHAR_LIT        shift and go to state 26
    FLOAT_LIT       shift and go to state 27
    INT_LIT         shift and go to state 28
    BOOL_LIT        shift and go to state 29
    IDENT           shift and go to state 22
    (               shift and go to state 30
    SUB             shift and go to state 32
    ADD             shift and go to state 33
    !               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36

    expr                           shift and go to state 90
    location                       shift and go to state 31

state 54

    (70) expr -> expr + . expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . STRING_LIT
    (51) expr -> . CHAR_LIT
    (52) expr -> . FLOAT_LIT
    (53) expr -> . INT_LIT
    (54) expr -> . BOOL_LIT
    (55) expr -> . IDENT . SIZE
    (56) expr -> . IDENT ( args )
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . expr SUB
    (60) expr -> . expr ADD
    (61) expr -> . SUB expr
    (62) expr -> . ADD expr
    (63) expr -> . ! expr
    (64) expr -> . + expr
    (65) expr -> . - expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr MDE expr
    (72) expr -> . expr TE expr
    (73) expr -> . expr DE expr
    (74) expr -> . expr PE expr
    (75) expr -> . expr ME expr
    (76) expr -> . expr > expr
    (77) expr -> . expr GE expr
    (78) expr -> . expr < expr
    (79) expr -> . expr LE expr
    (80) expr -> . expr NE expr
    (81) expr -> . expr EQ expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . location = expr
    (47) location -> . IDENT [ expr ]
    (48) location -> . IDENT
    NEW             shift and go to state 24
    STRING_LIT      shift and go to state 25
    CHAR_LIT        shift and go to state 26
    FLOAT_LIT       shift and go to state 27
    INT_LIT         shift and go to state 28
    BOOL_LIT        shift and go to state 29
    IDENT           shift and go to state 22
    (               shift and go to state 30
    SUB             shift and go to state 32
    ADD             shift and go to state 33
    !               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36

    expr                           shift and go to state 91
    location                       shift and go to state 31

state 55

    (71) expr -> expr MDE . expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . STRING_LIT
    (51) expr -> . CHAR_LIT
    (52) expr -> . FLOAT_LIT
    (53) expr -> . INT_LIT
    (54) expr -> . BOOL_LIT
    (55) expr -> . IDENT . SIZE
    (56) expr -> . IDENT ( args )
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . expr SUB
    (60) expr -> . expr ADD
    (61) expr -> . SUB expr
    (62) expr -> . ADD expr
    (63) expr -> . ! expr
    (64) expr -> . + expr
    (65) expr -> . - expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr MDE expr
    (72) expr -> . expr TE expr
    (73) expr -> . expr DE expr
    (74) expr -> . expr PE expr
    (75) expr -> . expr ME expr
    (76) expr -> . expr > expr
    (77) expr -> . expr GE expr
    (78) expr -> . expr < expr
    (79) expr -> . expr LE expr
    (80) expr -> . expr NE expr
    (81) expr -> . expr EQ expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . location = expr
    (47) location -> . IDENT [ expr ]
    (48) location -> . IDENT
    NEW             shift and go to state 24
    STRING_LIT      shift and go to state 25
    CHAR_LIT        shift and go to state 26
    FLOAT_LIT       shift and go to state 27
    INT_LIT         shift and go to state 28
    BOOL_LIT        shift and go to state 29
    IDENT           shift and go to state 22
    (               shift and go to state 30
    SUB             shift and go to state 32
    ADD             shift and go to state 33
    !               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36

    expr                           shift and go to state 92
    location                       shift and go to state 31

state 56

    (72) expr -> expr TE . expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . STRING_LIT
    (51) expr -> . CHAR_LIT
    (52) expr -> . FLOAT_LIT
    (53) expr -> . INT_LIT
    (54) expr -> . BOOL_LIT
    (55) expr -> . IDENT . SIZE
    (56) expr -> . IDENT ( args )
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . expr SUB
    (60) expr -> . expr ADD
    (61) expr -> . SUB expr
    (62) expr -> . ADD expr
    (63) expr -> . ! expr
    (64) expr -> . + expr
    (65) expr -> . - expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr MDE expr
    (72) expr -> . expr TE expr
    (73) expr -> . expr DE expr
    (74) expr -> . expr PE expr
    (75) expr -> . expr ME expr
    (76) expr -> . expr > expr
    (77) expr -> . expr GE expr
    (78) expr -> . expr < expr
    (79) expr -> . expr LE expr
    (80) expr -> . expr NE expr
    (81) expr -> . expr EQ expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . location = expr
    (47) location -> . IDENT [ expr ]
    (48) location -> . IDENT
    NEW             shift and go to state 24
    STRING_LIT      shift and go to state 25
    CHAR_LIT        shift and go to state 26
    FLOAT_LIT       shift and go to state 27
    INT_LIT         shift and go to state 28
    BOOL_LIT        shift and go to state 29
    IDENT           shift and go to state 22
    (               shift and go to state 30
    SUB             shift and go to state 32
    ADD             shift and go to state 33
    !               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36

    expr                           shift and go to state 93
    location                       shift and go to state 31

state 57

    (73) expr -> expr DE . expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . STRING_LIT
    (51) expr -> . CHAR_LIT
    (52) expr -> . FLOAT_LIT
    (53) expr -> . INT_LIT
    (54) expr -> . BOOL_LIT
    (55) expr -> . IDENT . SIZE
    (56) expr -> . IDENT ( args )
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . expr SUB
    (60) expr -> . expr ADD
    (61) expr -> . SUB expr
    (62) expr -> . ADD expr
    (63) expr -> . ! expr
    (64) expr -> . + expr
    (65) expr -> . - expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr MDE expr
    (72) expr -> . expr TE expr
    (73) expr -> . expr DE expr
    (74) expr -> . expr PE expr
    (75) expr -> . expr ME expr
    (76) expr -> . expr > expr
    (77) expr -> . expr GE expr
    (78) expr -> . expr < expr
    (79) expr -> . expr LE expr
    (80) expr -> . expr NE expr
    (81) expr -> . expr EQ expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . location = expr
    (47) location -> . IDENT [ expr ]
    (48) location -> . IDENT
    NEW             shift and go to state 24
    STRING_LIT      shift and go to state 25
    CHAR_LIT        shift and go to state 26
    FLOAT_LIT       shift and go to state 27
    INT_LIT         shift and go to state 28
    BOOL_LIT        shift and go to state 29
    IDENT           shift and go to state 22
    (               shift and go to state 30
    SUB             shift and go to state 32
    ADD             shift and go to state 33
    !               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36

    expr                           shift and go to state 94
    location                       shift and go to state 31

state 58

    (74) expr -> expr PE . expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . STRING_LIT
    (51) expr -> . CHAR_LIT
    (52) expr -> . FLOAT_LIT
    (53) expr -> . INT_LIT
    (54) expr -> . BOOL_LIT
    (55) expr -> . IDENT . SIZE
    (56) expr -> . IDENT ( args )
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . expr SUB
    (60) expr -> . expr ADD
    (61) expr -> . SUB expr
    (62) expr -> . ADD expr
    (63) expr -> . ! expr
    (64) expr -> . + expr
    (65) expr -> . - expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr MDE expr
    (72) expr -> . expr TE expr
    (73) expr -> . expr DE expr
    (74) expr -> . expr PE expr
    (75) expr -> . expr ME expr
    (76) expr -> . expr > expr
    (77) expr -> . expr GE expr
    (78) expr -> . expr < expr
    (79) expr -> . expr LE expr
    (80) expr -> . expr NE expr
    (81) expr -> . expr EQ expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . location = expr
    (47) location -> . IDENT [ expr ]
    (48) location -> . IDENT
    NEW             shift and go to state 24
    STRING_LIT      shift and go to state 25
    CHAR_LIT        shift and go to state 26
    FLOAT_LIT       shift and go to state 27
    INT_LIT         shift and go to state 28
    BOOL_LIT        shift and go to state 29
    IDENT           shift and go to state 22
    (               shift and go to state 30
    SUB             shift and go to state 32
    ADD             shift and go to state 33
    !               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36

    expr                           shift and go to state 95
    location                       shift and go to state 31

state 59

    (75) expr -> expr ME . expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . STRING_LIT
    (51) expr -> . CHAR_LIT
    (52) expr -> . FLOAT_LIT
    (53) expr -> . INT_LIT
    (54) expr -> . BOOL_LIT
    (55) expr -> . IDENT . SIZE
    (56) expr -> . IDENT ( args )
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . expr SUB
    (60) expr -> . expr ADD
    (61) expr -> . SUB expr
    (62) expr -> . ADD expr
    (63) expr -> . ! expr
    (64) expr -> . + expr
    (65) expr -> . - expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr MDE expr
    (72) expr -> . expr TE expr
    (73) expr -> . expr DE expr
    (74) expr -> . expr PE expr
    (75) expr -> . expr ME expr
    (76) expr -> . expr > expr
    (77) expr -> . expr GE expr
    (78) expr -> . expr < expr
    (79) expr -> . expr LE expr
    (80) expr -> . expr NE expr
    (81) expr -> . expr EQ expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . location = expr
    (47) location -> . IDENT [ expr ]
    (48) location -> . IDENT
    NEW             shift and go to state 24
    STRING_LIT      shift and go to state 25
    CHAR_LIT        shift and go to state 26
    FLOAT_LIT       shift and go to state 27
    INT_LIT         shift and go to state 28
    BOOL_LIT        shift and go to state 29
    IDENT           shift and go to state 22
    (               shift and go to state 30
    SUB             shift and go to state 32
    ADD             shift and go to state 33
    !               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36

    expr                           shift and go to state 96
    location                       shift and go to state 31

state 60

    (76) expr -> expr > . expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . STRING_LIT
    (51) expr -> . CHAR_LIT
    (52) expr -> . FLOAT_LIT
    (53) expr -> . INT_LIT
    (54) expr -> . BOOL_LIT
    (55) expr -> . IDENT . SIZE
    (56) expr -> . IDENT ( args )
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . expr SUB
    (60) expr -> . expr ADD
    (61) expr -> . SUB expr
    (62) expr -> . ADD expr
    (63) expr -> . ! expr
    (64) expr -> . + expr
    (65) expr -> . - expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr MDE expr
    (72) expr -> . expr TE expr
    (73) expr -> . expr DE expr
    (74) expr -> . expr PE expr
    (75) expr -> . expr ME expr
    (76) expr -> . expr > expr
    (77) expr -> . expr GE expr
    (78) expr -> . expr < expr
    (79) expr -> . expr LE expr
    (80) expr -> . expr NE expr
    (81) expr -> . expr EQ expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . location = expr
    (47) location -> . IDENT [ expr ]
    (48) location -> . IDENT
    NEW             shift and go to state 24
    STRING_LIT      shift and go to state 25
    CHAR_LIT        shift and go to state 26
    FLOAT_LIT       shift and go to state 27
    INT_LIT         shift and go to state 28
    BOOL_LIT        shift and go to state 29
    IDENT           shift and go to state 22
    (               shift and go to state 30
    SUB             shift and go to state 32
    ADD             shift and go to state 33
    !               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36

    expr                           shift and go to state 97
    location                       shift and go to state 31

state 61

    (77) expr -> expr GE . expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . STRING_LIT
    (51) expr -> . CHAR_LIT
    (52) expr -> . FLOAT_LIT
    (53) expr -> . INT_LIT
    (54) expr -> . BOOL_LIT
    (55) expr -> . IDENT . SIZE
    (56) expr -> . IDENT ( args )
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . expr SUB
    (60) expr -> . expr ADD
    (61) expr -> . SUB expr
    (62) expr -> . ADD expr
    (63) expr -> . ! expr
    (64) expr -> . + expr
    (65) expr -> . - expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr MDE expr
    (72) expr -> . expr TE expr
    (73) expr -> . expr DE expr
    (74) expr -> . expr PE expr
    (75) expr -> . expr ME expr
    (76) expr -> . expr > expr
    (77) expr -> . expr GE expr
    (78) expr -> . expr < expr
    (79) expr -> . expr LE expr
    (80) expr -> . expr NE expr
    (81) expr -> . expr EQ expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . location = expr
    (47) location -> . IDENT [ expr ]
    (48) location -> . IDENT
    NEW             shift and go to state 24
    STRING_LIT      shift and go to state 25
    CHAR_LIT        shift and go to state 26
    FLOAT_LIT       shift and go to state 27
    INT_LIT         shift and go to state 28
    BOOL_LIT        shift and go to state 29
    IDENT           shift and go to state 22
    (               shift and go to state 30
    SUB             shift and go to state 32
    ADD             shift and go to state 33
    !               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36

    expr                           shift and go to state 98
    location                       shift and go to state 31

state 62

    (78) expr -> expr < . expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . STRING_LIT
    (51) expr -> . CHAR_LIT
    (52) expr -> . FLOAT_LIT
    (53) expr -> . INT_LIT
    (54) expr -> . BOOL_LIT
    (55) expr -> . IDENT . SIZE
    (56) expr -> . IDENT ( args )
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . expr SUB
    (60) expr -> . expr ADD
    (61) expr -> . SUB expr
    (62) expr -> . ADD expr
    (63) expr -> . ! expr
    (64) expr -> . + expr
    (65) expr -> . - expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr MDE expr
    (72) expr -> . expr TE expr
    (73) expr -> . expr DE expr
    (74) expr -> . expr PE expr
    (75) expr -> . expr ME expr
    (76) expr -> . expr > expr
    (77) expr -> . expr GE expr
    (78) expr -> . expr < expr
    (79) expr -> . expr LE expr
    (80) expr -> . expr NE expr
    (81) expr -> . expr EQ expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . location = expr
    (47) location -> . IDENT [ expr ]
    (48) location -> . IDENT
    NEW             shift and go to state 24
    STRING_LIT      shift and go to state 25
    CHAR_LIT        shift and go to state 26
    FLOAT_LIT       shift and go to state 27
    INT_LIT         shift and go to state 28
    BOOL_LIT        shift and go to state 29
    IDENT           shift and go to state 22
    (               shift and go to state 30
    SUB             shift and go to state 32
    ADD             shift and go to state 33
    !               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36

    expr                           shift and go to state 99
    location                       shift and go to state 31

state 63

    (79) expr -> expr LE . expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . STRING_LIT
    (51) expr -> . CHAR_LIT
    (52) expr -> . FLOAT_LIT
    (53) expr -> . INT_LIT
    (54) expr -> . BOOL_LIT
    (55) expr -> . IDENT . SIZE
    (56) expr -> . IDENT ( args )
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . expr SUB
    (60) expr -> . expr ADD
    (61) expr -> . SUB expr
    (62) expr -> . ADD expr
    (63) expr -> . ! expr
    (64) expr -> . + expr
    (65) expr -> . - expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr MDE expr
    (72) expr -> . expr TE expr
    (73) expr -> . expr DE expr
    (74) expr -> . expr PE expr
    (75) expr -> . expr ME expr
    (76) expr -> . expr > expr
    (77) expr -> . expr GE expr
    (78) expr -> . expr < expr
    (79) expr -> . expr LE expr
    (80) expr -> . expr NE expr
    (81) expr -> . expr EQ expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . location = expr
    (47) location -> . IDENT [ expr ]
    (48) location -> . IDENT
    NEW             shift and go to state 24
    STRING_LIT      shift and go to state 25
    CHAR_LIT        shift and go to state 26
    FLOAT_LIT       shift and go to state 27
    INT_LIT         shift and go to state 28
    BOOL_LIT        shift and go to state 29
    IDENT           shift and go to state 22
    (               shift and go to state 30
    SUB             shift and go to state 32
    ADD             shift and go to state 33
    !               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36

    expr                           shift and go to state 100
    location                       shift and go to state 31

state 64

    (80) expr -> expr NE . expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . STRING_LIT
    (51) expr -> . CHAR_LIT
    (52) expr -> . FLOAT_LIT
    (53) expr -> . INT_LIT
    (54) expr -> . BOOL_LIT
    (55) expr -> . IDENT . SIZE
    (56) expr -> . IDENT ( args )
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . expr SUB
    (60) expr -> . expr ADD
    (61) expr -> . SUB expr
    (62) expr -> . ADD expr
    (63) expr -> . ! expr
    (64) expr -> . + expr
    (65) expr -> . - expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr MDE expr
    (72) expr -> . expr TE expr
    (73) expr -> . expr DE expr
    (74) expr -> . expr PE expr
    (75) expr -> . expr ME expr
    (76) expr -> . expr > expr
    (77) expr -> . expr GE expr
    (78) expr -> . expr < expr
    (79) expr -> . expr LE expr
    (80) expr -> . expr NE expr
    (81) expr -> . expr EQ expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . location = expr
    (47) location -> . IDENT [ expr ]
    (48) location -> . IDENT
    NEW             shift and go to state 24
    STRING_LIT      shift and go to state 25
    CHAR_LIT        shift and go to state 26
    FLOAT_LIT       shift and go to state 27
    INT_LIT         shift and go to state 28
    BOOL_LIT        shift and go to state 29
    IDENT           shift and go to state 22
    (               shift and go to state 30
    SUB             shift and go to state 32
    ADD             shift and go to state 33
    !               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36

    expr                           shift and go to state 101
    location                       shift and go to state 31

state 65

    (81) expr -> expr EQ . expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . STRING_LIT
    (51) expr -> . CHAR_LIT
    (52) expr -> . FLOAT_LIT
    (53) expr -> . INT_LIT
    (54) expr -> . BOOL_LIT
    (55) expr -> . IDENT . SIZE
    (56) expr -> . IDENT ( args )
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . expr SUB
    (60) expr -> . expr ADD
    (61) expr -> . SUB expr
    (62) expr -> . ADD expr
    (63) expr -> . ! expr
    (64) expr -> . + expr
    (65) expr -> . - expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr MDE expr
    (72) expr -> . expr TE expr
    (73) expr -> . expr DE expr
    (74) expr -> . expr PE expr
    (75) expr -> . expr ME expr
    (76) expr -> . expr > expr
    (77) expr -> . expr GE expr
    (78) expr -> . expr < expr
    (79) expr -> . expr LE expr
    (80) expr -> . expr NE expr
    (81) expr -> . expr EQ expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . location = expr
    (47) location -> . IDENT [ expr ]
    (48) location -> . IDENT
    NEW             shift and go to state 24
    STRING_LIT      shift and go to state 25
    CHAR_LIT        shift and go to state 26
    FLOAT_LIT       shift and go to state 27
    INT_LIT         shift and go to state 28
    BOOL_LIT        shift and go to state 29
    IDENT           shift and go to state 22
    (               shift and go to state 30
    SUB             shift and go to state 32
    ADD             shift and go to state 33
    !               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36

    expr                           shift and go to state 102
    location                       shift and go to state 31

state 66

    (82) expr -> expr AND . expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . STRING_LIT
    (51) expr -> . CHAR_LIT
    (52) expr -> . FLOAT_LIT
    (53) expr -> . INT_LIT
    (54) expr -> . BOOL_LIT
    (55) expr -> . IDENT . SIZE
    (56) expr -> . IDENT ( args )
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . expr SUB
    (60) expr -> . expr ADD
    (61) expr -> . SUB expr
    (62) expr -> . ADD expr
    (63) expr -> . ! expr
    (64) expr -> . + expr
    (65) expr -> . - expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr MDE expr
    (72) expr -> . expr TE expr
    (73) expr -> . expr DE expr
    (74) expr -> . expr PE expr
    (75) expr -> . expr ME expr
    (76) expr -> . expr > expr
    (77) expr -> . expr GE expr
    (78) expr -> . expr < expr
    (79) expr -> . expr LE expr
    (80) expr -> . expr NE expr
    (81) expr -> . expr EQ expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . location = expr
    (47) location -> . IDENT [ expr ]
    (48) location -> . IDENT
    NEW             shift and go to state 24
    STRING_LIT      shift and go to state 25
    CHAR_LIT        shift and go to state 26
    FLOAT_LIT       shift and go to state 27
    INT_LIT         shift and go to state 28
    BOOL_LIT        shift and go to state 29
    IDENT           shift and go to state 22
    (               shift and go to state 30
    SUB             shift and go to state 32
    ADD             shift and go to state 33
    !               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36

    expr                           shift and go to state 103
    location                       shift and go to state 31

state 67

    (83) expr -> expr OR . expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . STRING_LIT
    (51) expr -> . CHAR_LIT
    (52) expr -> . FLOAT_LIT
    (53) expr -> . INT_LIT
    (54) expr -> . BOOL_LIT
    (55) expr -> . IDENT . SIZE
    (56) expr -> . IDENT ( args )
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . expr SUB
    (60) expr -> . expr ADD
    (61) expr -> . SUB expr
    (62) expr -> . ADD expr
    (63) expr -> . ! expr
    (64) expr -> . + expr
    (65) expr -> . - expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr MDE expr
    (72) expr -> . expr TE expr
    (73) expr -> . expr DE expr
    (74) expr -> . expr PE expr
    (75) expr -> . expr ME expr
    (76) expr -> . expr > expr
    (77) expr -> . expr GE expr
    (78) expr -> . expr < expr
    (79) expr -> . expr LE expr
    (80) expr -> . expr NE expr
    (81) expr -> . expr EQ expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . location = expr
    (47) location -> . IDENT [ expr ]
    (48) location -> . IDENT
    NEW             shift and go to state 24
    STRING_LIT      shift and go to state 25
    CHAR_LIT        shift and go to state 26
    FLOAT_LIT       shift and go to state 27
    INT_LIT         shift and go to state 28
    BOOL_LIT        shift and go to state 29
    IDENT           shift and go to state 22
    (               shift and go to state 30
    SUB             shift and go to state 32
    ADD             shift and go to state 33
    !               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36

    expr                           shift and go to state 104
    location                       shift and go to state 31

state 68

    (49) expr -> NEW type_spec . [ expr ]
    [               shift and go to state 105


state 69

    (58) expr -> ( expr . )
    (59) expr -> expr . SUB
    (60) expr -> expr . ADD
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . MDE expr
    (72) expr -> expr . TE expr
    (73) expr -> expr . DE expr
    (74) expr -> expr . PE expr
    (75) expr -> expr . ME expr
    (76) expr -> expr . > expr
    (77) expr -> expr . GE expr
    (78) expr -> expr . < expr
    (79) expr -> expr . LE expr
    (80) expr -> expr . NE expr
    (81) expr -> expr . EQ expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    )               shift and go to state 106
    SUB             shift and go to state 48
    ADD             shift and go to state 49
    %               shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54
    MDE             shift and go to state 55
    TE              shift and go to state 56
    DE              shift and go to state 57
    PE              shift and go to state 58
    ME              shift and go to state 59
    >               shift and go to state 60
    GE              shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    NE              shift and go to state 64
    EQ              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 70

    (84) expr -> location = . expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . STRING_LIT
    (51) expr -> . CHAR_LIT
    (52) expr -> . FLOAT_LIT
    (53) expr -> . INT_LIT
    (54) expr -> . BOOL_LIT
    (55) expr -> . IDENT . SIZE
    (56) expr -> . IDENT ( args )
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . expr SUB
    (60) expr -> . expr ADD
    (61) expr -> . SUB expr
    (62) expr -> . ADD expr
    (63) expr -> . ! expr
    (64) expr -> . + expr
    (65) expr -> . - expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr MDE expr
    (72) expr -> . expr TE expr
    (73) expr -> . expr DE expr
    (74) expr -> . expr PE expr
    (75) expr -> . expr ME expr
    (76) expr -> . expr > expr
    (77) expr -> . expr GE expr
    (78) expr -> . expr < expr
    (79) expr -> . expr LE expr
    (80) expr -> . expr NE expr
    (81) expr -> . expr EQ expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . location = expr
    (47) location -> . IDENT [ expr ]
    (48) location -> . IDENT
    NEW             shift and go to state 24
    STRING_LIT      shift and go to state 25
    CHAR_LIT        shift and go to state 26
    FLOAT_LIT       shift and go to state 27
    INT_LIT         shift and go to state 28
    BOOL_LIT        shift and go to state 29
    IDENT           shift and go to state 22
    (               shift and go to state 30
    SUB             shift and go to state 32
    ADD             shift and go to state 33
    !               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36

    location                       shift and go to state 31
    expr                           shift and go to state 107

state 71

    (61) expr -> SUB expr .
    (59) expr -> expr . SUB
    (60) expr -> expr . ADD
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . MDE expr
    (72) expr -> expr . TE expr
    (73) expr -> expr . DE expr
    (74) expr -> expr . PE expr
    (75) expr -> expr . ME expr
    (76) expr -> expr . > expr
    (77) expr -> expr . GE expr
    (78) expr -> expr . < expr
    (79) expr -> expr . LE expr
    (80) expr -> expr . NE expr
    (81) expr -> expr . EQ expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    ;               reduce using rule 61 (expr -> SUB expr .)
    SUB             reduce using rule 61 (expr -> SUB expr .)
    ADD             reduce using rule 61 (expr -> SUB expr .)
    %               reduce using rule 61 (expr -> SUB expr .)
    /               reduce using rule 61 (expr -> SUB expr .)
    *               reduce using rule 61 (expr -> SUB expr .)
    -               reduce using rule 61 (expr -> SUB expr .)
    +               reduce using rule 61 (expr -> SUB expr .)
    MDE             reduce using rule 61 (expr -> SUB expr .)
    TE              reduce using rule 61 (expr -> SUB expr .)
    DE              reduce using rule 61 (expr -> SUB expr .)
    PE              reduce using rule 61 (expr -> SUB expr .)
    ME              reduce using rule 61 (expr -> SUB expr .)
    >               reduce using rule 61 (expr -> SUB expr .)
    GE              reduce using rule 61 (expr -> SUB expr .)
    <               reduce using rule 61 (expr -> SUB expr .)
    LE              reduce using rule 61 (expr -> SUB expr .)
    NE              reduce using rule 61 (expr -> SUB expr .)
    EQ              reduce using rule 61 (expr -> SUB expr .)
    AND             reduce using rule 61 (expr -> SUB expr .)
    OR              reduce using rule 61 (expr -> SUB expr .)
    )               reduce using rule 61 (expr -> SUB expr .)
    ,               reduce using rule 61 (expr -> SUB expr .)
    ]               reduce using rule 61 (expr -> SUB expr .)


state 72

    (62) expr -> ADD expr .
    (59) expr -> expr . SUB
    (60) expr -> expr . ADD
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . MDE expr
    (72) expr -> expr . TE expr
    (73) expr -> expr . DE expr
    (74) expr -> expr . PE expr
    (75) expr -> expr . ME expr
    (76) expr -> expr . > expr
    (77) expr -> expr . GE expr
    (78) expr -> expr . < expr
    (79) expr -> expr . LE expr
    (80) expr -> expr . NE expr
    (81) expr -> expr . EQ expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    ;               reduce using rule 62 (expr -> ADD expr .)
    SUB             reduce using rule 62 (expr -> ADD expr .)
    ADD             reduce using rule 62 (expr -> ADD expr .)
    %               reduce using rule 62 (expr -> ADD expr .)
    /               reduce using rule 62 (expr -> ADD expr .)
    *               reduce using rule 62 (expr -> ADD expr .)
    -               reduce using rule 62 (expr -> ADD expr .)
    +               reduce using rule 62 (expr -> ADD expr .)
    MDE             reduce using rule 62 (expr -> ADD expr .)
    TE              reduce using rule 62 (expr -> ADD expr .)
    DE              reduce using rule 62 (expr -> ADD expr .)
    PE              reduce using rule 62 (expr -> ADD expr .)
    ME              reduce using rule 62 (expr -> ADD expr .)
    >               reduce using rule 62 (expr -> ADD expr .)
    GE              reduce using rule 62 (expr -> ADD expr .)
    <               reduce using rule 62 (expr -> ADD expr .)
    LE              reduce using rule 62 (expr -> ADD expr .)
    NE              reduce using rule 62 (expr -> ADD expr .)
    EQ              reduce using rule 62 (expr -> ADD expr .)
    AND             reduce using rule 62 (expr -> ADD expr .)
    OR              reduce using rule 62 (expr -> ADD expr .)
    )               reduce using rule 62 (expr -> ADD expr .)
    ,               reduce using rule 62 (expr -> ADD expr .)
    ]               reduce using rule 62 (expr -> ADD expr .)


state 73

    (63) expr -> ! expr .
    (59) expr -> expr . SUB
    (60) expr -> expr . ADD
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . MDE expr
    (72) expr -> expr . TE expr
    (73) expr -> expr . DE expr
    (74) expr -> expr . PE expr
    (75) expr -> expr . ME expr
    (76) expr -> expr . > expr
    (77) expr -> expr . GE expr
    (78) expr -> expr . < expr
    (79) expr -> expr . LE expr
    (80) expr -> expr . NE expr
    (81) expr -> expr . EQ expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    ;               reduce using rule 63 (expr -> ! expr .)
    SUB             reduce using rule 63 (expr -> ! expr .)
    ADD             reduce using rule 63 (expr -> ! expr .)
    %               reduce using rule 63 (expr -> ! expr .)
    /               reduce using rule 63 (expr -> ! expr .)
    *               reduce using rule 63 (expr -> ! expr .)
    -               reduce using rule 63 (expr -> ! expr .)
    +               reduce using rule 63 (expr -> ! expr .)
    MDE             reduce using rule 63 (expr -> ! expr .)
    TE              reduce using rule 63 (expr -> ! expr .)
    DE              reduce using rule 63 (expr -> ! expr .)
    PE              reduce using rule 63 (expr -> ! expr .)
    ME              reduce using rule 63 (expr -> ! expr .)
    >               reduce using rule 63 (expr -> ! expr .)
    GE              reduce using rule 63 (expr -> ! expr .)
    <               reduce using rule 63 (expr -> ! expr .)
    LE              reduce using rule 63 (expr -> ! expr .)
    NE              reduce using rule 63 (expr -> ! expr .)
    EQ              reduce using rule 63 (expr -> ! expr .)
    AND             reduce using rule 63 (expr -> ! expr .)
    OR              reduce using rule 63 (expr -> ! expr .)
    )               reduce using rule 63 (expr -> ! expr .)
    ,               reduce using rule 63 (expr -> ! expr .)
    ]               reduce using rule 63 (expr -> ! expr .)


state 74

    (64) expr -> + expr .
    (59) expr -> expr . SUB
    (60) expr -> expr . ADD
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . MDE expr
    (72) expr -> expr . TE expr
    (73) expr -> expr . DE expr
    (74) expr -> expr . PE expr
    (75) expr -> expr . ME expr
    (76) expr -> expr . > expr
    (77) expr -> expr . GE expr
    (78) expr -> expr . < expr
    (79) expr -> expr . LE expr
    (80) expr -> expr . NE expr
    (81) expr -> expr . EQ expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    ;               reduce using rule 64 (expr -> + expr .)
    SUB             reduce using rule 64 (expr -> + expr .)
    ADD             reduce using rule 64 (expr -> + expr .)
    %               reduce using rule 64 (expr -> + expr .)
    /               reduce using rule 64 (expr -> + expr .)
    *               reduce using rule 64 (expr -> + expr .)
    -               reduce using rule 64 (expr -> + expr .)
    +               reduce using rule 64 (expr -> + expr .)
    MDE             reduce using rule 64 (expr -> + expr .)
    TE              reduce using rule 64 (expr -> + expr .)
    DE              reduce using rule 64 (expr -> + expr .)
    PE              reduce using rule 64 (expr -> + expr .)
    ME              reduce using rule 64 (expr -> + expr .)
    >               reduce using rule 64 (expr -> + expr .)
    GE              reduce using rule 64 (expr -> + expr .)
    <               reduce using rule 64 (expr -> + expr .)
    LE              reduce using rule 64 (expr -> + expr .)
    NE              reduce using rule 64 (expr -> + expr .)
    EQ              reduce using rule 64 (expr -> + expr .)
    AND             reduce using rule 64 (expr -> + expr .)
    OR              reduce using rule 64 (expr -> + expr .)
    )               reduce using rule 64 (expr -> + expr .)
    ,               reduce using rule 64 (expr -> + expr .)
    ]               reduce using rule 64 (expr -> + expr .)


state 75

    (65) expr -> - expr .
    (59) expr -> expr . SUB
    (60) expr -> expr . ADD
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . MDE expr
    (72) expr -> expr . TE expr
    (73) expr -> expr . DE expr
    (74) expr -> expr . PE expr
    (75) expr -> expr . ME expr
    (76) expr -> expr . > expr
    (77) expr -> expr . GE expr
    (78) expr -> expr . < expr
    (79) expr -> expr . LE expr
    (80) expr -> expr . NE expr
    (81) expr -> expr . EQ expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    ;               reduce using rule 65 (expr -> - expr .)
    SUB             reduce using rule 65 (expr -> - expr .)
    ADD             reduce using rule 65 (expr -> - expr .)
    %               reduce using rule 65 (expr -> - expr .)
    /               reduce using rule 65 (expr -> - expr .)
    *               reduce using rule 65 (expr -> - expr .)
    -               reduce using rule 65 (expr -> - expr .)
    +               reduce using rule 65 (expr -> - expr .)
    MDE             reduce using rule 65 (expr -> - expr .)
    TE              reduce using rule 65 (expr -> - expr .)
    DE              reduce using rule 65 (expr -> - expr .)
    PE              reduce using rule 65 (expr -> - expr .)
    ME              reduce using rule 65 (expr -> - expr .)
    >               reduce using rule 65 (expr -> - expr .)
    GE              reduce using rule 65 (expr -> - expr .)
    <               reduce using rule 65 (expr -> - expr .)
    LE              reduce using rule 65 (expr -> - expr .)
    NE              reduce using rule 65 (expr -> - expr .)
    EQ              reduce using rule 65 (expr -> - expr .)
    AND             reduce using rule 65 (expr -> - expr .)
    OR              reduce using rule 65 (expr -> - expr .)
    )               reduce using rule 65 (expr -> - expr .)
    ,               reduce using rule 65 (expr -> - expr .)
    ]               reduce using rule 65 (expr -> - expr .)


state 76

    (21) param -> type_spec IDENT . [ ]
    (22) param -> type_spec IDENT .
    [               shift and go to state 108
    ,               reduce using rule 22 (param -> type_spec IDENT .)
    )               reduce using rule 22 (param -> type_spec IDENT .)


state 77

    (16) fun_decl -> type_spec IDENT ( params ) . compound_stmt
    (23) compound_stmt -> . { local_decls stmt_list }
    {               shift and go to state 110

    compound_stmt                  shift and go to state 109

state 78

    (20) param_list -> param_list , . param
    (21) param -> . type_spec IDENT [ ]
    (22) param -> . type_spec IDENT
    (11) type_spec -> . CHAR
    (12) type_spec -> . VOID
    (13) type_spec -> . FLOAT
    (14) type_spec -> . INT
    (15) type_spec -> . BOOL
    CHAR            shift and go to state 9
    VOID            shift and go to state 10
    FLOAT           shift and go to state 11
    INT             shift and go to state 12
    BOOL            shift and go to state 13

    param                          shift and go to state 111
    type_spec                      shift and go to state 37

state 79

    (8) var_decl -> type_spec IDENT [ ] ; .
    CONST           reduce using rule 8 (var_decl -> type_spec IDENT [ ] ; .)
    CHAR            reduce using rule 8 (var_decl -> type_spec IDENT [ ] ; .)
    VOID            reduce using rule 8 (var_decl -> type_spec IDENT [ ] ; .)
    FLOAT           reduce using rule 8 (var_decl -> type_spec IDENT [ ] ; .)
    INT             reduce using rule 8 (var_decl -> type_spec IDENT [ ] ; .)
    BOOL            reduce using rule 8 (var_decl -> type_spec IDENT [ ] ; .)
    $end            reduce using rule 8 (var_decl -> type_spec IDENT [ ] ; .)
    ;               reduce using rule 8 (var_decl -> type_spec IDENT [ ] ; .)
    NEW             reduce using rule 8 (var_decl -> type_spec IDENT [ ] ; .)
    STRING_LIT      reduce using rule 8 (var_decl -> type_spec IDENT [ ] ; .)
    CHAR_LIT        reduce using rule 8 (var_decl -> type_spec IDENT [ ] ; .)
    FLOAT_LIT       reduce using rule 8 (var_decl -> type_spec IDENT [ ] ; .)
    INT_LIT         reduce using rule 8 (var_decl -> type_spec IDENT [ ] ; .)
    BOOL_LIT        reduce using rule 8 (var_decl -> type_spec IDENT [ ] ; .)
    IDENT           reduce using rule 8 (var_decl -> type_spec IDENT [ ] ; .)
    (               reduce using rule 8 (var_decl -> type_spec IDENT [ ] ; .)
    SUB             reduce using rule 8 (var_decl -> type_spec IDENT [ ] ; .)
    ADD             reduce using rule 8 (var_decl -> type_spec IDENT [ ] ; .)
    !               reduce using rule 8 (var_decl -> type_spec IDENT [ ] ; .)
    +               reduce using rule 8 (var_decl -> type_spec IDENT [ ] ; .)
    -               reduce using rule 8 (var_decl -> type_spec IDENT [ ] ; .)


state 80

    (9) var_decl -> type_spec IDENT = expr ; .
    CONST           reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    CHAR            reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    VOID            reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    FLOAT           reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    INT             reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    BOOL            reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    $end            reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    ;               reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    NEW             reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    STRING_LIT      reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    CHAR_LIT        reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    FLOAT_LIT       reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    INT_LIT         reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    BOOL_LIT        reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    IDENT           reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    (               reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    SUB             reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    ADD             reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    !               reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    +               reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)
    -               reduce using rule 9 (var_decl -> type_spec IDENT = expr ; .)


state 81

    (55) expr -> IDENT . SIZE .
    ;               reduce using rule 55 (expr -> IDENT . SIZE .)
    SUB             reduce using rule 55 (expr -> IDENT . SIZE .)
    ADD             reduce using rule 55 (expr -> IDENT . SIZE .)
    %               reduce using rule 55 (expr -> IDENT . SIZE .)
    /               reduce using rule 55 (expr -> IDENT . SIZE .)
    *               reduce using rule 55 (expr -> IDENT . SIZE .)
    -               reduce using rule 55 (expr -> IDENT . SIZE .)
    +               reduce using rule 55 (expr -> IDENT . SIZE .)
    MDE             reduce using rule 55 (expr -> IDENT . SIZE .)
    TE              reduce using rule 55 (expr -> IDENT . SIZE .)
    DE              reduce using rule 55 (expr -> IDENT . SIZE .)
    PE              reduce using rule 55 (expr -> IDENT . SIZE .)
    ME              reduce using rule 55 (expr -> IDENT . SIZE .)
    >               reduce using rule 55 (expr -> IDENT . SIZE .)
    GE              reduce using rule 55 (expr -> IDENT . SIZE .)
    <               reduce using rule 55 (expr -> IDENT . SIZE .)
    LE              reduce using rule 55 (expr -> IDENT . SIZE .)
    NE              reduce using rule 55 (expr -> IDENT . SIZE .)
    EQ              reduce using rule 55 (expr -> IDENT . SIZE .)
    AND             reduce using rule 55 (expr -> IDENT . SIZE .)
    OR              reduce using rule 55 (expr -> IDENT . SIZE .)
    )               reduce using rule 55 (expr -> IDENT . SIZE .)
    ,               reduce using rule 55 (expr -> IDENT . SIZE .)
    ]               reduce using rule 55 (expr -> IDENT . SIZE .)


state 82

    (56) expr -> IDENT ( args . )
    )               shift and go to state 112


state 83

    (87) args -> empty .
    )               reduce using rule 87 (args -> empty .)


state 84

    (88) args -> arg_list .
    (86) arg_list -> arg_list . , expr
    )               reduce using rule 88 (args -> arg_list .)
    ,               shift and go to state 113


state 85

    (85) arg_list -> expr .
    (59) expr -> expr . SUB
    (60) expr -> expr . ADD
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . MDE expr
    (72) expr -> expr . TE expr
    (73) expr -> expr . DE expr
    (74) expr -> expr . PE expr
    (75) expr -> expr . ME expr
    (76) expr -> expr . > expr
    (77) expr -> expr . GE expr
    (78) expr -> expr . < expr
    (79) expr -> expr . LE expr
    (80) expr -> expr . NE expr
    (81) expr -> expr . EQ expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    ,               reduce using rule 85 (arg_list -> expr .)
    )               reduce using rule 85 (arg_list -> expr .)
    SUB             shift and go to state 48
    ADD             shift and go to state 49
    %               shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54
    MDE             shift and go to state 55
    TE              shift and go to state 56
    DE              shift and go to state 57
    PE              shift and go to state 58
    ME              shift and go to state 59
    >               shift and go to state 60
    GE              shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    NE              shift and go to state 64
    EQ              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 86

    (47) location -> IDENT [ expr . ]
    (59) expr -> expr . SUB
    (60) expr -> expr . ADD
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . MDE expr
    (72) expr -> expr . TE expr
    (73) expr -> expr . DE expr
    (74) expr -> expr . PE expr
    (75) expr -> expr . ME expr
    (76) expr -> expr . > expr
    (77) expr -> expr . GE expr
    (78) expr -> expr . < expr
    (79) expr -> expr . LE expr
    (80) expr -> expr . NE expr
    (81) expr -> expr . EQ expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    ]               shift and go to state 114
    SUB             shift and go to state 48
    ADD             shift and go to state 49
    %               shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54
    MDE             shift and go to state 55
    TE              shift and go to state 56
    DE              shift and go to state 57
    PE              shift and go to state 58
    ME              shift and go to state 59
    >               shift and go to state 60
    GE              shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    NE              shift and go to state 64
    EQ              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 87

    (66) expr -> expr % expr .
    (59) expr -> expr . SUB
    (60) expr -> expr . ADD
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . MDE expr
    (72) expr -> expr . TE expr
    (73) expr -> expr . DE expr
    (74) expr -> expr . PE expr
    (75) expr -> expr . ME expr
    (76) expr -> expr . > expr
    (77) expr -> expr . GE expr
    (78) expr -> expr . < expr
    (79) expr -> expr . LE expr
    (80) expr -> expr . NE expr
    (81) expr -> expr . EQ expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    ;               reduce using rule 66 (expr -> expr % expr .)
    SUB             reduce using rule 66 (expr -> expr % expr .)
    ADD             reduce using rule 66 (expr -> expr % expr .)
    %               reduce using rule 66 (expr -> expr % expr .)
    /               reduce using rule 66 (expr -> expr % expr .)
    *               reduce using rule 66 (expr -> expr % expr .)
    -               reduce using rule 66 (expr -> expr % expr .)
    +               reduce using rule 66 (expr -> expr % expr .)
    MDE             reduce using rule 66 (expr -> expr % expr .)
    TE              reduce using rule 66 (expr -> expr % expr .)
    DE              reduce using rule 66 (expr -> expr % expr .)
    PE              reduce using rule 66 (expr -> expr % expr .)
    ME              reduce using rule 66 (expr -> expr % expr .)
    >               reduce using rule 66 (expr -> expr % expr .)
    GE              reduce using rule 66 (expr -> expr % expr .)
    <               reduce using rule 66 (expr -> expr % expr .)
    LE              reduce using rule 66 (expr -> expr % expr .)
    NE              reduce using rule 66 (expr -> expr % expr .)
    EQ              reduce using rule 66 (expr -> expr % expr .)
    AND             reduce using rule 66 (expr -> expr % expr .)
    OR              reduce using rule 66 (expr -> expr % expr .)
    )               reduce using rule 66 (expr -> expr % expr .)
    ,               reduce using rule 66 (expr -> expr % expr .)
    ]               reduce using rule 66 (expr -> expr % expr .)


state 88

    (67) expr -> expr / expr .
    (59) expr -> expr . SUB
    (60) expr -> expr . ADD
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . MDE expr
    (72) expr -> expr . TE expr
    (73) expr -> expr . DE expr
    (74) expr -> expr . PE expr
    (75) expr -> expr . ME expr
    (76) expr -> expr . > expr
    (77) expr -> expr . GE expr
    (78) expr -> expr . < expr
    (79) expr -> expr . LE expr
    (80) expr -> expr . NE expr
    (81) expr -> expr . EQ expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    ;               reduce using rule 67 (expr -> expr / expr .)
    SUB             reduce using rule 67 (expr -> expr / expr .)
    ADD             reduce using rule 67 (expr -> expr / expr .)
    %               reduce using rule 67 (expr -> expr / expr .)
    /               reduce using rule 67 (expr -> expr / expr .)
    *               reduce using rule 67 (expr -> expr / expr .)
    -               reduce using rule 67 (expr -> expr / expr .)
    +               reduce using rule 67 (expr -> expr / expr .)
    MDE             reduce using rule 67 (expr -> expr / expr .)
    TE              reduce using rule 67 (expr -> expr / expr .)
    DE              reduce using rule 67 (expr -> expr / expr .)
    PE              reduce using rule 67 (expr -> expr / expr .)
    ME              reduce using rule 67 (expr -> expr / expr .)
    >               reduce using rule 67 (expr -> expr / expr .)
    GE              reduce using rule 67 (expr -> expr / expr .)
    <               reduce using rule 67 (expr -> expr / expr .)
    LE              reduce using rule 67 (expr -> expr / expr .)
    NE              reduce using rule 67 (expr -> expr / expr .)
    EQ              reduce using rule 67 (expr -> expr / expr .)
    AND             reduce using rule 67 (expr -> expr / expr .)
    OR              reduce using rule 67 (expr -> expr / expr .)
    )               reduce using rule 67 (expr -> expr / expr .)
    ,               reduce using rule 67 (expr -> expr / expr .)
    ]               reduce using rule 67 (expr -> expr / expr .)


state 89

    (68) expr -> expr * expr .
    (59) expr -> expr . SUB
    (60) expr -> expr . ADD
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . MDE expr
    (72) expr -> expr . TE expr
    (73) expr -> expr . DE expr
    (74) expr -> expr . PE expr
    (75) expr -> expr . ME expr
    (76) expr -> expr . > expr
    (77) expr -> expr . GE expr
    (78) expr -> expr . < expr
    (79) expr -> expr . LE expr
    (80) expr -> expr . NE expr
    (81) expr -> expr . EQ expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    ;               reduce using rule 68 (expr -> expr * expr .)
    SUB             reduce using rule 68 (expr -> expr * expr .)
    ADD             reduce using rule 68 (expr -> expr * expr .)
    %               reduce using rule 68 (expr -> expr * expr .)
    /               reduce using rule 68 (expr -> expr * expr .)
    *               reduce using rule 68 (expr -> expr * expr .)
    -               reduce using rule 68 (expr -> expr * expr .)
    +               reduce using rule 68 (expr -> expr * expr .)
    MDE             reduce using rule 68 (expr -> expr * expr .)
    TE              reduce using rule 68 (expr -> expr * expr .)
    DE              reduce using rule 68 (expr -> expr * expr .)
    PE              reduce using rule 68 (expr -> expr * expr .)
    ME              reduce using rule 68 (expr -> expr * expr .)
    >               reduce using rule 68 (expr -> expr * expr .)
    GE              reduce using rule 68 (expr -> expr * expr .)
    <               reduce using rule 68 (expr -> expr * expr .)
    LE              reduce using rule 68 (expr -> expr * expr .)
    NE              reduce using rule 68 (expr -> expr * expr .)
    EQ              reduce using rule 68 (expr -> expr * expr .)
    AND             reduce using rule 68 (expr -> expr * expr .)
    OR              reduce using rule 68 (expr -> expr * expr .)
    )               reduce using rule 68 (expr -> expr * expr .)
    ,               reduce using rule 68 (expr -> expr * expr .)
    ]               reduce using rule 68 (expr -> expr * expr .)


state 90

    (69) expr -> expr - expr .
    (59) expr -> expr . SUB
    (60) expr -> expr . ADD
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . MDE expr
    (72) expr -> expr . TE expr
    (73) expr -> expr . DE expr
    (74) expr -> expr . PE expr
    (75) expr -> expr . ME expr
    (76) expr -> expr . > expr
    (77) expr -> expr . GE expr
    (78) expr -> expr . < expr
    (79) expr -> expr . LE expr
    (80) expr -> expr . NE expr
    (81) expr -> expr . EQ expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    ;               reduce using rule 69 (expr -> expr - expr .)
    SUB             reduce using rule 69 (expr -> expr - expr .)
    ADD             reduce using rule 69 (expr -> expr - expr .)
    -               reduce using rule 69 (expr -> expr - expr .)
    +               reduce using rule 69 (expr -> expr - expr .)
    MDE             reduce using rule 69 (expr -> expr - expr .)
    TE              reduce using rule 69 (expr -> expr - expr .)
    DE              reduce using rule 69 (expr -> expr - expr .)
    PE              reduce using rule 69 (expr -> expr - expr .)
    ME              reduce using rule 69 (expr -> expr - expr .)
    >               reduce using rule 69 (expr -> expr - expr .)
    GE              reduce using rule 69 (expr -> expr - expr .)
    <               reduce using rule 69 (expr -> expr - expr .)
    LE              reduce using rule 69 (expr -> expr - expr .)
    NE              reduce using rule 69 (expr -> expr - expr .)
    EQ              reduce using rule 69 (expr -> expr - expr .)
    AND             reduce using rule 69 (expr -> expr - expr .)
    OR              reduce using rule 69 (expr -> expr - expr .)
    )               reduce using rule 69 (expr -> expr - expr .)
    ,               reduce using rule 69 (expr -> expr - expr .)
    ]               reduce using rule 69 (expr -> expr - expr .)
    %               shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52


state 91

    (70) expr -> expr + expr .
    (59) expr -> expr . SUB
    (60) expr -> expr . ADD
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . MDE expr
    (72) expr -> expr . TE expr
    (73) expr -> expr . DE expr
    (74) expr -> expr . PE expr
    (75) expr -> expr . ME expr
    (76) expr -> expr . > expr
    (77) expr -> expr . GE expr
    (78) expr -> expr . < expr
    (79) expr -> expr . LE expr
    (80) expr -> expr . NE expr
    (81) expr -> expr . EQ expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    ;               reduce using rule 70 (expr -> expr + expr .)
    SUB             reduce using rule 70 (expr -> expr + expr .)
    ADD             reduce using rule 70 (expr -> expr + expr .)
    -               reduce using rule 70 (expr -> expr + expr .)
    +               reduce using rule 70 (expr -> expr + expr .)
    MDE             reduce using rule 70 (expr -> expr + expr .)
    TE              reduce using rule 70 (expr -> expr + expr .)
    DE              reduce using rule 70 (expr -> expr + expr .)
    PE              reduce using rule 70 (expr -> expr + expr .)
    ME              reduce using rule 70 (expr -> expr + expr .)
    >               reduce using rule 70 (expr -> expr + expr .)
    GE              reduce using rule 70 (expr -> expr + expr .)
    <               reduce using rule 70 (expr -> expr + expr .)
    LE              reduce using rule 70 (expr -> expr + expr .)
    NE              reduce using rule 70 (expr -> expr + expr .)
    EQ              reduce using rule 70 (expr -> expr + expr .)
    AND             reduce using rule 70 (expr -> expr + expr .)
    OR              reduce using rule 70 (expr -> expr + expr .)
    )               reduce using rule 70 (expr -> expr + expr .)
    ,               reduce using rule 70 (expr -> expr + expr .)
    ]               reduce using rule 70 (expr -> expr + expr .)
    %               shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52


state 92

    (71) expr -> expr MDE expr .
    (59) expr -> expr . SUB
    (60) expr -> expr . ADD
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . MDE expr
    (72) expr -> expr . TE expr
    (73) expr -> expr . DE expr
    (74) expr -> expr . PE expr
    (75) expr -> expr . ME expr
    (76) expr -> expr . > expr
    (77) expr -> expr . GE expr
    (78) expr -> expr . < expr
    (79) expr -> expr . LE expr
    (80) expr -> expr . NE expr
    (81) expr -> expr . EQ expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    ;               reduce using rule 71 (expr -> expr MDE expr .)
    SUB             reduce using rule 71 (expr -> expr MDE expr .)
    ADD             reduce using rule 71 (expr -> expr MDE expr .)
    MDE             reduce using rule 71 (expr -> expr MDE expr .)
    TE              reduce using rule 71 (expr -> expr MDE expr .)
    DE              reduce using rule 71 (expr -> expr MDE expr .)
    PE              reduce using rule 71 (expr -> expr MDE expr .)
    ME              reduce using rule 71 (expr -> expr MDE expr .)
    >               reduce using rule 71 (expr -> expr MDE expr .)
    GE              reduce using rule 71 (expr -> expr MDE expr .)
    <               reduce using rule 71 (expr -> expr MDE expr .)
    LE              reduce using rule 71 (expr -> expr MDE expr .)
    NE              reduce using rule 71 (expr -> expr MDE expr .)
    EQ              reduce using rule 71 (expr -> expr MDE expr .)
    AND             reduce using rule 71 (expr -> expr MDE expr .)
    OR              reduce using rule 71 (expr -> expr MDE expr .)
    )               reduce using rule 71 (expr -> expr MDE expr .)
    ,               reduce using rule 71 (expr -> expr MDE expr .)
    ]               reduce using rule 71 (expr -> expr MDE expr .)
    %               shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54


state 93

    (72) expr -> expr TE expr .
    (59) expr -> expr . SUB
    (60) expr -> expr . ADD
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . MDE expr
    (72) expr -> expr . TE expr
    (73) expr -> expr . DE expr
    (74) expr -> expr . PE expr
    (75) expr -> expr . ME expr
    (76) expr -> expr . > expr
    (77) expr -> expr . GE expr
    (78) expr -> expr . < expr
    (79) expr -> expr . LE expr
    (80) expr -> expr . NE expr
    (81) expr -> expr . EQ expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    ;               reduce using rule 72 (expr -> expr TE expr .)
    SUB             reduce using rule 72 (expr -> expr TE expr .)
    ADD             reduce using rule 72 (expr -> expr TE expr .)
    MDE             reduce using rule 72 (expr -> expr TE expr .)
    TE              reduce using rule 72 (expr -> expr TE expr .)
    DE              reduce using rule 72 (expr -> expr TE expr .)
    PE              reduce using rule 72 (expr -> expr TE expr .)
    ME              reduce using rule 72 (expr -> expr TE expr .)
    >               reduce using rule 72 (expr -> expr TE expr .)
    GE              reduce using rule 72 (expr -> expr TE expr .)
    <               reduce using rule 72 (expr -> expr TE expr .)
    LE              reduce using rule 72 (expr -> expr TE expr .)
    NE              reduce using rule 72 (expr -> expr TE expr .)
    EQ              reduce using rule 72 (expr -> expr TE expr .)
    AND             reduce using rule 72 (expr -> expr TE expr .)
    OR              reduce using rule 72 (expr -> expr TE expr .)
    )               reduce using rule 72 (expr -> expr TE expr .)
    ,               reduce using rule 72 (expr -> expr TE expr .)
    ]               reduce using rule 72 (expr -> expr TE expr .)
    %               shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54


state 94

    (73) expr -> expr DE expr .
    (59) expr -> expr . SUB
    (60) expr -> expr . ADD
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . MDE expr
    (72) expr -> expr . TE expr
    (73) expr -> expr . DE expr
    (74) expr -> expr . PE expr
    (75) expr -> expr . ME expr
    (76) expr -> expr . > expr
    (77) expr -> expr . GE expr
    (78) expr -> expr . < expr
    (79) expr -> expr . LE expr
    (80) expr -> expr . NE expr
    (81) expr -> expr . EQ expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    ;               reduce using rule 73 (expr -> expr DE expr .)
    SUB             reduce using rule 73 (expr -> expr DE expr .)
    ADD             reduce using rule 73 (expr -> expr DE expr .)
    MDE             reduce using rule 73 (expr -> expr DE expr .)
    TE              reduce using rule 73 (expr -> expr DE expr .)
    DE              reduce using rule 73 (expr -> expr DE expr .)
    PE              reduce using rule 73 (expr -> expr DE expr .)
    ME              reduce using rule 73 (expr -> expr DE expr .)
    >               reduce using rule 73 (expr -> expr DE expr .)
    GE              reduce using rule 73 (expr -> expr DE expr .)
    <               reduce using rule 73 (expr -> expr DE expr .)
    LE              reduce using rule 73 (expr -> expr DE expr .)
    NE              reduce using rule 73 (expr -> expr DE expr .)
    EQ              reduce using rule 73 (expr -> expr DE expr .)
    AND             reduce using rule 73 (expr -> expr DE expr .)
    OR              reduce using rule 73 (expr -> expr DE expr .)
    )               reduce using rule 73 (expr -> expr DE expr .)
    ,               reduce using rule 73 (expr -> expr DE expr .)
    ]               reduce using rule 73 (expr -> expr DE expr .)
    %               shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54


state 95

    (74) expr -> expr PE expr .
    (59) expr -> expr . SUB
    (60) expr -> expr . ADD
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . MDE expr
    (72) expr -> expr . TE expr
    (73) expr -> expr . DE expr
    (74) expr -> expr . PE expr
    (75) expr -> expr . ME expr
    (76) expr -> expr . > expr
    (77) expr -> expr . GE expr
    (78) expr -> expr . < expr
    (79) expr -> expr . LE expr
    (80) expr -> expr . NE expr
    (81) expr -> expr . EQ expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    ;               reduce using rule 74 (expr -> expr PE expr .)
    SUB             reduce using rule 74 (expr -> expr PE expr .)
    ADD             reduce using rule 74 (expr -> expr PE expr .)
    MDE             reduce using rule 74 (expr -> expr PE expr .)
    TE              reduce using rule 74 (expr -> expr PE expr .)
    DE              reduce using rule 74 (expr -> expr PE expr .)
    PE              reduce using rule 74 (expr -> expr PE expr .)
    ME              reduce using rule 74 (expr -> expr PE expr .)
    >               reduce using rule 74 (expr -> expr PE expr .)
    GE              reduce using rule 74 (expr -> expr PE expr .)
    <               reduce using rule 74 (expr -> expr PE expr .)
    LE              reduce using rule 74 (expr -> expr PE expr .)
    NE              reduce using rule 74 (expr -> expr PE expr .)
    EQ              reduce using rule 74 (expr -> expr PE expr .)
    AND             reduce using rule 74 (expr -> expr PE expr .)
    OR              reduce using rule 74 (expr -> expr PE expr .)
    )               reduce using rule 74 (expr -> expr PE expr .)
    ,               reduce using rule 74 (expr -> expr PE expr .)
    ]               reduce using rule 74 (expr -> expr PE expr .)
    %               shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54


state 96

    (75) expr -> expr ME expr .
    (59) expr -> expr . SUB
    (60) expr -> expr . ADD
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . MDE expr
    (72) expr -> expr . TE expr
    (73) expr -> expr . DE expr
    (74) expr -> expr . PE expr
    (75) expr -> expr . ME expr
    (76) expr -> expr . > expr
    (77) expr -> expr . GE expr
    (78) expr -> expr . < expr
    (79) expr -> expr . LE expr
    (80) expr -> expr . NE expr
    (81) expr -> expr . EQ expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    ;               reduce using rule 75 (expr -> expr ME expr .)
    SUB             reduce using rule 75 (expr -> expr ME expr .)
    ADD             reduce using rule 75 (expr -> expr ME expr .)
    MDE             reduce using rule 75 (expr -> expr ME expr .)
    TE              reduce using rule 75 (expr -> expr ME expr .)
    DE              reduce using rule 75 (expr -> expr ME expr .)
    PE              reduce using rule 75 (expr -> expr ME expr .)
    ME              reduce using rule 75 (expr -> expr ME expr .)
    >               reduce using rule 75 (expr -> expr ME expr .)
    GE              reduce using rule 75 (expr -> expr ME expr .)
    <               reduce using rule 75 (expr -> expr ME expr .)
    LE              reduce using rule 75 (expr -> expr ME expr .)
    NE              reduce using rule 75 (expr -> expr ME expr .)
    EQ              reduce using rule 75 (expr -> expr ME expr .)
    AND             reduce using rule 75 (expr -> expr ME expr .)
    OR              reduce using rule 75 (expr -> expr ME expr .)
    )               reduce using rule 75 (expr -> expr ME expr .)
    ,               reduce using rule 75 (expr -> expr ME expr .)
    ]               reduce using rule 75 (expr -> expr ME expr .)
    %               shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54


state 97

    (76) expr -> expr > expr .
    (59) expr -> expr . SUB
    (60) expr -> expr . ADD
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . MDE expr
    (72) expr -> expr . TE expr
    (73) expr -> expr . DE expr
    (74) expr -> expr . PE expr
    (75) expr -> expr . ME expr
    (76) expr -> expr . > expr
    (77) expr -> expr . GE expr
    (78) expr -> expr . < expr
    (79) expr -> expr . LE expr
    (80) expr -> expr . NE expr
    (81) expr -> expr . EQ expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    ;               reduce using rule 76 (expr -> expr > expr .)
    SUB             reduce using rule 76 (expr -> expr > expr .)
    ADD             reduce using rule 76 (expr -> expr > expr .)
    >               reduce using rule 76 (expr -> expr > expr .)
    GE              reduce using rule 76 (expr -> expr > expr .)
    <               reduce using rule 76 (expr -> expr > expr .)
    LE              reduce using rule 76 (expr -> expr > expr .)
    NE              reduce using rule 76 (expr -> expr > expr .)
    EQ              reduce using rule 76 (expr -> expr > expr .)
    AND             reduce using rule 76 (expr -> expr > expr .)
    OR              reduce using rule 76 (expr -> expr > expr .)
    )               reduce using rule 76 (expr -> expr > expr .)
    ,               reduce using rule 76 (expr -> expr > expr .)
    ]               reduce using rule 76 (expr -> expr > expr .)
    %               shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54
    MDE             shift and go to state 55
    TE              shift and go to state 56
    DE              shift and go to state 57
    PE              shift and go to state 58
    ME              shift and go to state 59


state 98

    (77) expr -> expr GE expr .
    (59) expr -> expr . SUB
    (60) expr -> expr . ADD
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . MDE expr
    (72) expr -> expr . TE expr
    (73) expr -> expr . DE expr
    (74) expr -> expr . PE expr
    (75) expr -> expr . ME expr
    (76) expr -> expr . > expr
    (77) expr -> expr . GE expr
    (78) expr -> expr . < expr
    (79) expr -> expr . LE expr
    (80) expr -> expr . NE expr
    (81) expr -> expr . EQ expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    ;               reduce using rule 77 (expr -> expr GE expr .)
    SUB             reduce using rule 77 (expr -> expr GE expr .)
    ADD             reduce using rule 77 (expr -> expr GE expr .)
    >               reduce using rule 77 (expr -> expr GE expr .)
    GE              reduce using rule 77 (expr -> expr GE expr .)
    <               reduce using rule 77 (expr -> expr GE expr .)
    LE              reduce using rule 77 (expr -> expr GE expr .)
    NE              reduce using rule 77 (expr -> expr GE expr .)
    EQ              reduce using rule 77 (expr -> expr GE expr .)
    AND             reduce using rule 77 (expr -> expr GE expr .)
    OR              reduce using rule 77 (expr -> expr GE expr .)
    )               reduce using rule 77 (expr -> expr GE expr .)
    ,               reduce using rule 77 (expr -> expr GE expr .)
    ]               reduce using rule 77 (expr -> expr GE expr .)
    %               shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54
    MDE             shift and go to state 55
    TE              shift and go to state 56
    DE              shift and go to state 57
    PE              shift and go to state 58
    ME              shift and go to state 59


state 99

    (78) expr -> expr < expr .
    (59) expr -> expr . SUB
    (60) expr -> expr . ADD
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . MDE expr
    (72) expr -> expr . TE expr
    (73) expr -> expr . DE expr
    (74) expr -> expr . PE expr
    (75) expr -> expr . ME expr
    (76) expr -> expr . > expr
    (77) expr -> expr . GE expr
    (78) expr -> expr . < expr
    (79) expr -> expr . LE expr
    (80) expr -> expr . NE expr
    (81) expr -> expr . EQ expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    ;               reduce using rule 78 (expr -> expr < expr .)
    SUB             reduce using rule 78 (expr -> expr < expr .)
    ADD             reduce using rule 78 (expr -> expr < expr .)
    >               reduce using rule 78 (expr -> expr < expr .)
    GE              reduce using rule 78 (expr -> expr < expr .)
    <               reduce using rule 78 (expr -> expr < expr .)
    LE              reduce using rule 78 (expr -> expr < expr .)
    NE              reduce using rule 78 (expr -> expr < expr .)
    EQ              reduce using rule 78 (expr -> expr < expr .)
    AND             reduce using rule 78 (expr -> expr < expr .)
    OR              reduce using rule 78 (expr -> expr < expr .)
    )               reduce using rule 78 (expr -> expr < expr .)
    ,               reduce using rule 78 (expr -> expr < expr .)
    ]               reduce using rule 78 (expr -> expr < expr .)
    %               shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54
    MDE             shift and go to state 55
    TE              shift and go to state 56
    DE              shift and go to state 57
    PE              shift and go to state 58
    ME              shift and go to state 59


state 100

    (79) expr -> expr LE expr .
    (59) expr -> expr . SUB
    (60) expr -> expr . ADD
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . MDE expr
    (72) expr -> expr . TE expr
    (73) expr -> expr . DE expr
    (74) expr -> expr . PE expr
    (75) expr -> expr . ME expr
    (76) expr -> expr . > expr
    (77) expr -> expr . GE expr
    (78) expr -> expr . < expr
    (79) expr -> expr . LE expr
    (80) expr -> expr . NE expr
    (81) expr -> expr . EQ expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    ;               reduce using rule 79 (expr -> expr LE expr .)
    SUB             reduce using rule 79 (expr -> expr LE expr .)
    ADD             reduce using rule 79 (expr -> expr LE expr .)
    >               reduce using rule 79 (expr -> expr LE expr .)
    GE              reduce using rule 79 (expr -> expr LE expr .)
    <               reduce using rule 79 (expr -> expr LE expr .)
    LE              reduce using rule 79 (expr -> expr LE expr .)
    NE              reduce using rule 79 (expr -> expr LE expr .)
    EQ              reduce using rule 79 (expr -> expr LE expr .)
    AND             reduce using rule 79 (expr -> expr LE expr .)
    OR              reduce using rule 79 (expr -> expr LE expr .)
    )               reduce using rule 79 (expr -> expr LE expr .)
    ,               reduce using rule 79 (expr -> expr LE expr .)
    ]               reduce using rule 79 (expr -> expr LE expr .)
    %               shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54
    MDE             shift and go to state 55
    TE              shift and go to state 56
    DE              shift and go to state 57
    PE              shift and go to state 58
    ME              shift and go to state 59


state 101

    (80) expr -> expr NE expr .
    (59) expr -> expr . SUB
    (60) expr -> expr . ADD
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . MDE expr
    (72) expr -> expr . TE expr
    (73) expr -> expr . DE expr
    (74) expr -> expr . PE expr
    (75) expr -> expr . ME expr
    (76) expr -> expr . > expr
    (77) expr -> expr . GE expr
    (78) expr -> expr . < expr
    (79) expr -> expr . LE expr
    (80) expr -> expr . NE expr
    (81) expr -> expr . EQ expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    ;               reduce using rule 80 (expr -> expr NE expr .)
    SUB             reduce using rule 80 (expr -> expr NE expr .)
    ADD             reduce using rule 80 (expr -> expr NE expr .)
    NE              reduce using rule 80 (expr -> expr NE expr .)
    EQ              reduce using rule 80 (expr -> expr NE expr .)
    AND             reduce using rule 80 (expr -> expr NE expr .)
    OR              reduce using rule 80 (expr -> expr NE expr .)
    )               reduce using rule 80 (expr -> expr NE expr .)
    ,               reduce using rule 80 (expr -> expr NE expr .)
    ]               reduce using rule 80 (expr -> expr NE expr .)
    %               shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54
    MDE             shift and go to state 55
    TE              shift and go to state 56
    DE              shift and go to state 57
    PE              shift and go to state 58
    ME              shift and go to state 59
    >               shift and go to state 60
    GE              shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63


state 102

    (81) expr -> expr EQ expr .
    (59) expr -> expr . SUB
    (60) expr -> expr . ADD
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . MDE expr
    (72) expr -> expr . TE expr
    (73) expr -> expr . DE expr
    (74) expr -> expr . PE expr
    (75) expr -> expr . ME expr
    (76) expr -> expr . > expr
    (77) expr -> expr . GE expr
    (78) expr -> expr . < expr
    (79) expr -> expr . LE expr
    (80) expr -> expr . NE expr
    (81) expr -> expr . EQ expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    ;               reduce using rule 81 (expr -> expr EQ expr .)
    SUB             reduce using rule 81 (expr -> expr EQ expr .)
    ADD             reduce using rule 81 (expr -> expr EQ expr .)
    NE              reduce using rule 81 (expr -> expr EQ expr .)
    EQ              reduce using rule 81 (expr -> expr EQ expr .)
    AND             reduce using rule 81 (expr -> expr EQ expr .)
    OR              reduce using rule 81 (expr -> expr EQ expr .)
    )               reduce using rule 81 (expr -> expr EQ expr .)
    ,               reduce using rule 81 (expr -> expr EQ expr .)
    ]               reduce using rule 81 (expr -> expr EQ expr .)
    %               shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54
    MDE             shift and go to state 55
    TE              shift and go to state 56
    DE              shift and go to state 57
    PE              shift and go to state 58
    ME              shift and go to state 59
    >               shift and go to state 60
    GE              shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63


state 103

    (82) expr -> expr AND expr .
    (59) expr -> expr . SUB
    (60) expr -> expr . ADD
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . MDE expr
    (72) expr -> expr . TE expr
    (73) expr -> expr . DE expr
    (74) expr -> expr . PE expr
    (75) expr -> expr . ME expr
    (76) expr -> expr . > expr
    (77) expr -> expr . GE expr
    (78) expr -> expr . < expr
    (79) expr -> expr . LE expr
    (80) expr -> expr . NE expr
    (81) expr -> expr . EQ expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    ;               reduce using rule 82 (expr -> expr AND expr .)
    SUB             reduce using rule 82 (expr -> expr AND expr .)
    ADD             reduce using rule 82 (expr -> expr AND expr .)
    AND             reduce using rule 82 (expr -> expr AND expr .)
    OR              reduce using rule 82 (expr -> expr AND expr .)
    )               reduce using rule 82 (expr -> expr AND expr .)
    ,               reduce using rule 82 (expr -> expr AND expr .)
    ]               reduce using rule 82 (expr -> expr AND expr .)
    %               shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54
    MDE             shift and go to state 55
    TE              shift and go to state 56
    DE              shift and go to state 57
    PE              shift and go to state 58
    ME              shift and go to state 59
    >               shift and go to state 60
    GE              shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    NE              shift and go to state 64
    EQ              shift and go to state 65


state 104

    (83) expr -> expr OR expr .
    (59) expr -> expr . SUB
    (60) expr -> expr . ADD
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . MDE expr
    (72) expr -> expr . TE expr
    (73) expr -> expr . DE expr
    (74) expr -> expr . PE expr
    (75) expr -> expr . ME expr
    (76) expr -> expr . > expr
    (77) expr -> expr . GE expr
    (78) expr -> expr . < expr
    (79) expr -> expr . LE expr
    (80) expr -> expr . NE expr
    (81) expr -> expr . EQ expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    ;               reduce using rule 83 (expr -> expr OR expr .)
    SUB             reduce using rule 83 (expr -> expr OR expr .)
    ADD             reduce using rule 83 (expr -> expr OR expr .)
    OR              reduce using rule 83 (expr -> expr OR expr .)
    )               reduce using rule 83 (expr -> expr OR expr .)
    ,               reduce using rule 83 (expr -> expr OR expr .)
    ]               reduce using rule 83 (expr -> expr OR expr .)
    %               shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54
    MDE             shift and go to state 55
    TE              shift and go to state 56
    DE              shift and go to state 57
    PE              shift and go to state 58
    ME              shift and go to state 59
    >               shift and go to state 60
    GE              shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    NE              shift and go to state 64
    EQ              shift and go to state 65
    AND             shift and go to state 66


state 105

    (49) expr -> NEW type_spec [ . expr ]
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . STRING_LIT
    (51) expr -> . CHAR_LIT
    (52) expr -> . FLOAT_LIT
    (53) expr -> . INT_LIT
    (54) expr -> . BOOL_LIT
    (55) expr -> . IDENT . SIZE
    (56) expr -> . IDENT ( args )
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . expr SUB
    (60) expr -> . expr ADD
    (61) expr -> . SUB expr
    (62) expr -> . ADD expr
    (63) expr -> . ! expr
    (64) expr -> . + expr
    (65) expr -> . - expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr MDE expr
    (72) expr -> . expr TE expr
    (73) expr -> . expr DE expr
    (74) expr -> . expr PE expr
    (75) expr -> . expr ME expr
    (76) expr -> . expr > expr
    (77) expr -> . expr GE expr
    (78) expr -> . expr < expr
    (79) expr -> . expr LE expr
    (80) expr -> . expr NE expr
    (81) expr -> . expr EQ expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . location = expr
    (47) location -> . IDENT [ expr ]
    (48) location -> . IDENT
    NEW             shift and go to state 24
    STRING_LIT      shift and go to state 25
    CHAR_LIT        shift and go to state 26
    FLOAT_LIT       shift and go to state 27
    INT_LIT         shift and go to state 28
    BOOL_LIT        shift and go to state 29
    IDENT           shift and go to state 22
    (               shift and go to state 30
    SUB             shift and go to state 32
    ADD             shift and go to state 33
    !               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36

    expr                           shift and go to state 115
    location                       shift and go to state 31

state 106

    (58) expr -> ( expr ) .
    ;               reduce using rule 58 (expr -> ( expr ) .)
    SUB             reduce using rule 58 (expr -> ( expr ) .)
    ADD             reduce using rule 58 (expr -> ( expr ) .)
    %               reduce using rule 58 (expr -> ( expr ) .)
    /               reduce using rule 58 (expr -> ( expr ) .)
    *               reduce using rule 58 (expr -> ( expr ) .)
    -               reduce using rule 58 (expr -> ( expr ) .)
    +               reduce using rule 58 (expr -> ( expr ) .)
    MDE             reduce using rule 58 (expr -> ( expr ) .)
    TE              reduce using rule 58 (expr -> ( expr ) .)
    DE              reduce using rule 58 (expr -> ( expr ) .)
    PE              reduce using rule 58 (expr -> ( expr ) .)
    ME              reduce using rule 58 (expr -> ( expr ) .)
    >               reduce using rule 58 (expr -> ( expr ) .)
    GE              reduce using rule 58 (expr -> ( expr ) .)
    <               reduce using rule 58 (expr -> ( expr ) .)
    LE              reduce using rule 58 (expr -> ( expr ) .)
    NE              reduce using rule 58 (expr -> ( expr ) .)
    EQ              reduce using rule 58 (expr -> ( expr ) .)
    AND             reduce using rule 58 (expr -> ( expr ) .)
    OR              reduce using rule 58 (expr -> ( expr ) .)
    )               reduce using rule 58 (expr -> ( expr ) .)
    ,               reduce using rule 58 (expr -> ( expr ) .)
    ]               reduce using rule 58 (expr -> ( expr ) .)


state 107

    (84) expr -> location = expr .
    (59) expr -> expr . SUB
    (60) expr -> expr . ADD
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . MDE expr
    (72) expr -> expr . TE expr
    (73) expr -> expr . DE expr
    (74) expr -> expr . PE expr
    (75) expr -> expr . ME expr
    (76) expr -> expr . > expr
    (77) expr -> expr . GE expr
    (78) expr -> expr . < expr
    (79) expr -> expr . LE expr
    (80) expr -> expr . NE expr
    (81) expr -> expr . EQ expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    ;               reduce using rule 84 (expr -> location = expr .)
    SUB             reduce using rule 84 (expr -> location = expr .)
    ADD             reduce using rule 84 (expr -> location = expr .)
    )               reduce using rule 84 (expr -> location = expr .)
    ,               reduce using rule 84 (expr -> location = expr .)
    ]               reduce using rule 84 (expr -> location = expr .)
    %               shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54
    MDE             shift and go to state 55
    TE              shift and go to state 56
    DE              shift and go to state 57
    PE              shift and go to state 58
    ME              shift and go to state 59
    >               shift and go to state 60
    GE              shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    NE              shift and go to state 64
    EQ              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 108

    (21) param -> type_spec IDENT [ . ]
    ]               shift and go to state 116


state 109

    (16) fun_decl -> type_spec IDENT ( params ) compound_stmt .
    CONST           reduce using rule 16 (fun_decl -> type_spec IDENT ( params ) compound_stmt .)
    CHAR            reduce using rule 16 (fun_decl -> type_spec IDENT ( params ) compound_stmt .)
    VOID            reduce using rule 16 (fun_decl -> type_spec IDENT ( params ) compound_stmt .)
    FLOAT           reduce using rule 16 (fun_decl -> type_spec IDENT ( params ) compound_stmt .)
    INT             reduce using rule 16 (fun_decl -> type_spec IDENT ( params ) compound_stmt .)
    BOOL            reduce using rule 16 (fun_decl -> type_spec IDENT ( params ) compound_stmt .)
    $end            reduce using rule 16 (fun_decl -> type_spec IDENT ( params ) compound_stmt .)


state 110

    (23) compound_stmt -> { . local_decls stmt_list }
    (24) local_decls -> . empty
    (25) local_decls -> . local_decls local_decl
    (89) empty -> .
    CHAR            reduce using rule 89 (empty -> .)
    VOID            reduce using rule 89 (empty -> .)
    FLOAT           reduce using rule 89 (empty -> .)
    INT             reduce using rule 89 (empty -> .)
    BOOL            reduce using rule 89 (empty -> .)
    }               reduce using rule 89 (empty -> .)
    BREAK           reduce using rule 89 (empty -> .)
    RETURN          reduce using rule 89 (empty -> .)
    FOR             reduce using rule 89 (empty -> .)
    WHILE           reduce using rule 89 (empty -> .)
    IF              reduce using rule 89 (empty -> .)
    {               reduce using rule 89 (empty -> .)
    ;               reduce using rule 89 (empty -> .)
    NEW             reduce using rule 89 (empty -> .)
    STRING_LIT      reduce using rule 89 (empty -> .)
    CHAR_LIT        reduce using rule 89 (empty -> .)
    FLOAT_LIT       reduce using rule 89 (empty -> .)
    INT_LIT         reduce using rule 89 (empty -> .)
    BOOL_LIT        reduce using rule 89 (empty -> .)
    IDENT           reduce using rule 89 (empty -> .)
    (               reduce using rule 89 (empty -> .)
    SUB             reduce using rule 89 (empty -> .)
    ADD             reduce using rule 89 (empty -> .)
    !               reduce using rule 89 (empty -> .)
    +               reduce using rule 89 (empty -> .)
    -               reduce using rule 89 (empty -> .)

    local_decls                    shift and go to state 117
    empty                          shift and go to state 118

state 111

    (20) param_list -> param_list , param .
    ,               reduce using rule 20 (param_list -> param_list , param .)
    )               reduce using rule 20 (param_list -> param_list , param .)


state 112

    (56) expr -> IDENT ( args ) .
    ;               reduce using rule 56 (expr -> IDENT ( args ) .)
    SUB             reduce using rule 56 (expr -> IDENT ( args ) .)
    ADD             reduce using rule 56 (expr -> IDENT ( args ) .)
    %               reduce using rule 56 (expr -> IDENT ( args ) .)
    /               reduce using rule 56 (expr -> IDENT ( args ) .)
    *               reduce using rule 56 (expr -> IDENT ( args ) .)
    -               reduce using rule 56 (expr -> IDENT ( args ) .)
    +               reduce using rule 56 (expr -> IDENT ( args ) .)
    MDE             reduce using rule 56 (expr -> IDENT ( args ) .)
    TE              reduce using rule 56 (expr -> IDENT ( args ) .)
    DE              reduce using rule 56 (expr -> IDENT ( args ) .)
    PE              reduce using rule 56 (expr -> IDENT ( args ) .)
    ME              reduce using rule 56 (expr -> IDENT ( args ) .)
    >               reduce using rule 56 (expr -> IDENT ( args ) .)
    GE              reduce using rule 56 (expr -> IDENT ( args ) .)
    <               reduce using rule 56 (expr -> IDENT ( args ) .)
    LE              reduce using rule 56 (expr -> IDENT ( args ) .)
    NE              reduce using rule 56 (expr -> IDENT ( args ) .)
    EQ              reduce using rule 56 (expr -> IDENT ( args ) .)
    AND             reduce using rule 56 (expr -> IDENT ( args ) .)
    OR              reduce using rule 56 (expr -> IDENT ( args ) .)
    )               reduce using rule 56 (expr -> IDENT ( args ) .)
    ,               reduce using rule 56 (expr -> IDENT ( args ) .)
    ]               reduce using rule 56 (expr -> IDENT ( args ) .)


state 113

    (86) arg_list -> arg_list , . expr
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . STRING_LIT
    (51) expr -> . CHAR_LIT
    (52) expr -> . FLOAT_LIT
    (53) expr -> . INT_LIT
    (54) expr -> . BOOL_LIT
    (55) expr -> . IDENT . SIZE
    (56) expr -> . IDENT ( args )
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . expr SUB
    (60) expr -> . expr ADD
    (61) expr -> . SUB expr
    (62) expr -> . ADD expr
    (63) expr -> . ! expr
    (64) expr -> . + expr
    (65) expr -> . - expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr MDE expr
    (72) expr -> . expr TE expr
    (73) expr -> . expr DE expr
    (74) expr -> . expr PE expr
    (75) expr -> . expr ME expr
    (76) expr -> . expr > expr
    (77) expr -> . expr GE expr
    (78) expr -> . expr < expr
    (79) expr -> . expr LE expr
    (80) expr -> . expr NE expr
    (81) expr -> . expr EQ expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . location = expr
    (47) location -> . IDENT [ expr ]
    (48) location -> . IDENT
    NEW             shift and go to state 24
    STRING_LIT      shift and go to state 25
    CHAR_LIT        shift and go to state 26
    FLOAT_LIT       shift and go to state 27
    INT_LIT         shift and go to state 28
    BOOL_LIT        shift and go to state 29
    IDENT           shift and go to state 22
    (               shift and go to state 30
    SUB             shift and go to state 32
    ADD             shift and go to state 33
    !               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36

    expr                           shift and go to state 119
    location                       shift and go to state 31

state 114

    (47) location -> IDENT [ expr ] .
    =               reduce using rule 47 (location -> IDENT [ expr ] .)
    ;               reduce using rule 47 (location -> IDENT [ expr ] .)
    SUB             reduce using rule 47 (location -> IDENT [ expr ] .)
    ADD             reduce using rule 47 (location -> IDENT [ expr ] .)
    %               reduce using rule 47 (location -> IDENT [ expr ] .)
    /               reduce using rule 47 (location -> IDENT [ expr ] .)
    *               reduce using rule 47 (location -> IDENT [ expr ] .)
    -               reduce using rule 47 (location -> IDENT [ expr ] .)
    +               reduce using rule 47 (location -> IDENT [ expr ] .)
    MDE             reduce using rule 47 (location -> IDENT [ expr ] .)
    TE              reduce using rule 47 (location -> IDENT [ expr ] .)
    DE              reduce using rule 47 (location -> IDENT [ expr ] .)
    PE              reduce using rule 47 (location -> IDENT [ expr ] .)
    ME              reduce using rule 47 (location -> IDENT [ expr ] .)
    >               reduce using rule 47 (location -> IDENT [ expr ] .)
    GE              reduce using rule 47 (location -> IDENT [ expr ] .)
    <               reduce using rule 47 (location -> IDENT [ expr ] .)
    LE              reduce using rule 47 (location -> IDENT [ expr ] .)
    NE              reduce using rule 47 (location -> IDENT [ expr ] .)
    EQ              reduce using rule 47 (location -> IDENT [ expr ] .)
    AND             reduce using rule 47 (location -> IDENT [ expr ] .)
    OR              reduce using rule 47 (location -> IDENT [ expr ] .)
    )               reduce using rule 47 (location -> IDENT [ expr ] .)
    ,               reduce using rule 47 (location -> IDENT [ expr ] .)
    ]               reduce using rule 47 (location -> IDENT [ expr ] .)


state 115

    (49) expr -> NEW type_spec [ expr . ]
    (59) expr -> expr . SUB
    (60) expr -> expr . ADD
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . MDE expr
    (72) expr -> expr . TE expr
    (73) expr -> expr . DE expr
    (74) expr -> expr . PE expr
    (75) expr -> expr . ME expr
    (76) expr -> expr . > expr
    (77) expr -> expr . GE expr
    (78) expr -> expr . < expr
    (79) expr -> expr . LE expr
    (80) expr -> expr . NE expr
    (81) expr -> expr . EQ expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    ]               shift and go to state 120
    SUB             shift and go to state 48
    ADD             shift and go to state 49
    %               shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54
    MDE             shift and go to state 55
    TE              shift and go to state 56
    DE              shift and go to state 57
    PE              shift and go to state 58
    ME              shift and go to state 59
    >               shift and go to state 60
    GE              shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    NE              shift and go to state 64
    EQ              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 116

    (21) param -> type_spec IDENT [ ] .
    ,               reduce using rule 21 (param -> type_spec IDENT [ ] .)
    )               reduce using rule 21 (param -> type_spec IDENT [ ] .)


state 117

    (23) compound_stmt -> { local_decls . stmt_list }
    (25) local_decls -> local_decls . local_decl
    (29) stmt_list -> . empty
    (30) stmt_list -> . stmt_list stmt
    (26) local_decl -> . type_spec IDENT [ ] ;
    (27) local_decl -> . type_spec IDENT = expr ;
    (28) local_decl -> . type_spec IDENT ;
    (89) empty -> .
    (11) type_spec -> . CHAR
    (12) type_spec -> . VOID
    (13) type_spec -> . FLOAT
    (14) type_spec -> . INT
    (15) type_spec -> . BOOL
    }               reduce using rule 89 (empty -> .)
    BREAK           reduce using rule 89 (empty -> .)
    RETURN          reduce using rule 89 (empty -> .)
    FOR             reduce using rule 89 (empty -> .)
    WHILE           reduce using rule 89 (empty -> .)
    IF              reduce using rule 89 (empty -> .)
    {               reduce using rule 89 (empty -> .)
    ;               reduce using rule 89 (empty -> .)
    NEW             reduce using rule 89 (empty -> .)
    STRING_LIT      reduce using rule 89 (empty -> .)
    CHAR_LIT        reduce using rule 89 (empty -> .)
    FLOAT_LIT       reduce using rule 89 (empty -> .)
    INT_LIT         reduce using rule 89 (empty -> .)
    BOOL_LIT        reduce using rule 89 (empty -> .)
    IDENT           reduce using rule 89 (empty -> .)
    (               reduce using rule 89 (empty -> .)
    SUB             reduce using rule 89 (empty -> .)
    ADD             reduce using rule 89 (empty -> .)
    !               reduce using rule 89 (empty -> .)
    +               reduce using rule 89 (empty -> .)
    -               reduce using rule 89 (empty -> .)
    CHAR            shift and go to state 9
    VOID            shift and go to state 10
    FLOAT           shift and go to state 11
    INT             shift and go to state 12
    BOOL            shift and go to state 13

    stmt_list                      shift and go to state 121
    local_decl                     shift and go to state 122
    empty                          shift and go to state 123
    type_spec                      shift and go to state 124

state 118

    (24) local_decls -> empty .
    CHAR            reduce using rule 24 (local_decls -> empty .)
    VOID            reduce using rule 24 (local_decls -> empty .)
    FLOAT           reduce using rule 24 (local_decls -> empty .)
    INT             reduce using rule 24 (local_decls -> empty .)
    BOOL            reduce using rule 24 (local_decls -> empty .)
    }               reduce using rule 24 (local_decls -> empty .)
    BREAK           reduce using rule 24 (local_decls -> empty .)
    RETURN          reduce using rule 24 (local_decls -> empty .)
    FOR             reduce using rule 24 (local_decls -> empty .)
    WHILE           reduce using rule 24 (local_decls -> empty .)
    IF              reduce using rule 24 (local_decls -> empty .)
    {               reduce using rule 24 (local_decls -> empty .)
    ;               reduce using rule 24 (local_decls -> empty .)
    NEW             reduce using rule 24 (local_decls -> empty .)
    STRING_LIT      reduce using rule 24 (local_decls -> empty .)
    CHAR_LIT        reduce using rule 24 (local_decls -> empty .)
    FLOAT_LIT       reduce using rule 24 (local_decls -> empty .)
    INT_LIT         reduce using rule 24 (local_decls -> empty .)
    BOOL_LIT        reduce using rule 24 (local_decls -> empty .)
    IDENT           reduce using rule 24 (local_decls -> empty .)
    (               reduce using rule 24 (local_decls -> empty .)
    SUB             reduce using rule 24 (local_decls -> empty .)
    ADD             reduce using rule 24 (local_decls -> empty .)
    !               reduce using rule 24 (local_decls -> empty .)
    +               reduce using rule 24 (local_decls -> empty .)
    -               reduce using rule 24 (local_decls -> empty .)


state 119

    (86) arg_list -> arg_list , expr .
    (59) expr -> expr . SUB
    (60) expr -> expr . ADD
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . MDE expr
    (72) expr -> expr . TE expr
    (73) expr -> expr . DE expr
    (74) expr -> expr . PE expr
    (75) expr -> expr . ME expr
    (76) expr -> expr . > expr
    (77) expr -> expr . GE expr
    (78) expr -> expr . < expr
    (79) expr -> expr . LE expr
    (80) expr -> expr . NE expr
    (81) expr -> expr . EQ expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    ,               reduce using rule 86 (arg_list -> arg_list , expr .)
    )               reduce using rule 86 (arg_list -> arg_list , expr .)
    SUB             shift and go to state 48
    ADD             shift and go to state 49
    %               shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54
    MDE             shift and go to state 55
    TE              shift and go to state 56
    DE              shift and go to state 57
    PE              shift and go to state 58
    ME              shift and go to state 59
    >               shift and go to state 60
    GE              shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    NE              shift and go to state 64
    EQ              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 120

    (49) expr -> NEW type_spec [ expr ] .
    ;               reduce using rule 49 (expr -> NEW type_spec [ expr ] .)
    SUB             reduce using rule 49 (expr -> NEW type_spec [ expr ] .)
    ADD             reduce using rule 49 (expr -> NEW type_spec [ expr ] .)
    %               reduce using rule 49 (expr -> NEW type_spec [ expr ] .)
    /               reduce using rule 49 (expr -> NEW type_spec [ expr ] .)
    *               reduce using rule 49 (expr -> NEW type_spec [ expr ] .)
    -               reduce using rule 49 (expr -> NEW type_spec [ expr ] .)
    +               reduce using rule 49 (expr -> NEW type_spec [ expr ] .)
    MDE             reduce using rule 49 (expr -> NEW type_spec [ expr ] .)
    TE              reduce using rule 49 (expr -> NEW type_spec [ expr ] .)
    DE              reduce using rule 49 (expr -> NEW type_spec [ expr ] .)
    PE              reduce using rule 49 (expr -> NEW type_spec [ expr ] .)
    ME              reduce using rule 49 (expr -> NEW type_spec [ expr ] .)
    >               reduce using rule 49 (expr -> NEW type_spec [ expr ] .)
    GE              reduce using rule 49 (expr -> NEW type_spec [ expr ] .)
    <               reduce using rule 49 (expr -> NEW type_spec [ expr ] .)
    LE              reduce using rule 49 (expr -> NEW type_spec [ expr ] .)
    NE              reduce using rule 49 (expr -> NEW type_spec [ expr ] .)
    EQ              reduce using rule 49 (expr -> NEW type_spec [ expr ] .)
    AND             reduce using rule 49 (expr -> NEW type_spec [ expr ] .)
    OR              reduce using rule 49 (expr -> NEW type_spec [ expr ] .)
    )               reduce using rule 49 (expr -> NEW type_spec [ expr ] .)
    ,               reduce using rule 49 (expr -> NEW type_spec [ expr ] .)
    ]               reduce using rule 49 (expr -> NEW type_spec [ expr ] .)


state 121

    (23) compound_stmt -> { local_decls stmt_list . }
    (30) stmt_list -> stmt_list . stmt
    (31) stmt -> . break_stmt
    (32) stmt -> . return_stmt
    (33) stmt -> . for_stmt
    (34) stmt -> . while_stmt
    (35) stmt -> . if_stmt
    (36) stmt -> . compound_stmt
    (37) stmt -> . expr_stmt
    (46) break_stmt -> . BREAK ;
    (44) return_stmt -> . RETURN expr ;
    (45) return_stmt -> . RETURN ;
    (41) for_stmt -> . FOR ( var_decl expr_stmt expr ) compound_stmt
    (40) while_stmt -> . WHILE ( expr ) compound_stmt
    (42) if_stmt -> . IF ( expr ) stmt
    (43) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (23) compound_stmt -> . { local_decls stmt_list }
    (38) expr_stmt -> . ;
    (39) expr_stmt -> . expr ;
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . STRING_LIT
    (51) expr -> . CHAR_LIT
    (52) expr -> . FLOAT_LIT
    (53) expr -> . INT_LIT
    (54) expr -> . BOOL_LIT
    (55) expr -> . IDENT . SIZE
    (56) expr -> . IDENT ( args )
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . expr SUB
    (60) expr -> . expr ADD
    (61) expr -> . SUB expr
    (62) expr -> . ADD expr
    (63) expr -> . ! expr
    (64) expr -> . + expr
    (65) expr -> . - expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr MDE expr
    (72) expr -> . expr TE expr
    (73) expr -> . expr DE expr
    (74) expr -> . expr PE expr
    (75) expr -> . expr ME expr
    (76) expr -> . expr > expr
    (77) expr -> . expr GE expr
    (78) expr -> . expr < expr
    (79) expr -> . expr LE expr
    (80) expr -> . expr NE expr
    (81) expr -> . expr EQ expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . location = expr
    (47) location -> . IDENT [ expr ]
    (48) location -> . IDENT
    }               shift and go to state 125
    BREAK           shift and go to state 134
    RETURN          shift and go to state 136
    FOR             shift and go to state 138
    WHILE           shift and go to state 139
    IF              shift and go to state 140
    {               shift and go to state 110
    ;               shift and go to state 135
    NEW             shift and go to state 24
    STRING_LIT      shift and go to state 25
    CHAR_LIT        shift and go to state 26
    FLOAT_LIT       shift and go to state 27
    INT_LIT         shift and go to state 28
    BOOL_LIT        shift and go to state 29
    IDENT           shift and go to state 22
    (               shift and go to state 30
    SUB             shift and go to state 32
    ADD             shift and go to state 33
    !               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36

    stmt                           shift and go to state 126
    break_stmt                     shift and go to state 127
    return_stmt                    shift and go to state 128
    for_stmt                       shift and go to state 129
    while_stmt                     shift and go to state 130
    if_stmt                        shift and go to state 131
    compound_stmt                  shift and go to state 132
    expr_stmt                      shift and go to state 133
    expr                           shift and go to state 137
    location                       shift and go to state 31

state 122

    (25) local_decls -> local_decls local_decl .
    CHAR            reduce using rule 25 (local_decls -> local_decls local_decl .)
    VOID            reduce using rule 25 (local_decls -> local_decls local_decl .)
    FLOAT           reduce using rule 25 (local_decls -> local_decls local_decl .)
    INT             reduce using rule 25 (local_decls -> local_decls local_decl .)
    BOOL            reduce using rule 25 (local_decls -> local_decls local_decl .)
    }               reduce using rule 25 (local_decls -> local_decls local_decl .)
    BREAK           reduce using rule 25 (local_decls -> local_decls local_decl .)
    RETURN          reduce using rule 25 (local_decls -> local_decls local_decl .)
    FOR             reduce using rule 25 (local_decls -> local_decls local_decl .)
    WHILE           reduce using rule 25 (local_decls -> local_decls local_decl .)
    IF              reduce using rule 25 (local_decls -> local_decls local_decl .)
    {               reduce using rule 25 (local_decls -> local_decls local_decl .)
    ;               reduce using rule 25 (local_decls -> local_decls local_decl .)
    NEW             reduce using rule 25 (local_decls -> local_decls local_decl .)
    STRING_LIT      reduce using rule 25 (local_decls -> local_decls local_decl .)
    CHAR_LIT        reduce using rule 25 (local_decls -> local_decls local_decl .)
    FLOAT_LIT       reduce using rule 25 (local_decls -> local_decls local_decl .)
    INT_LIT         reduce using rule 25 (local_decls -> local_decls local_decl .)
    BOOL_LIT        reduce using rule 25 (local_decls -> local_decls local_decl .)
    IDENT           reduce using rule 25 (local_decls -> local_decls local_decl .)
    (               reduce using rule 25 (local_decls -> local_decls local_decl .)
    SUB             reduce using rule 25 (local_decls -> local_decls local_decl .)
    ADD             reduce using rule 25 (local_decls -> local_decls local_decl .)
    !               reduce using rule 25 (local_decls -> local_decls local_decl .)
    +               reduce using rule 25 (local_decls -> local_decls local_decl .)
    -               reduce using rule 25 (local_decls -> local_decls local_decl .)


state 123

    (29) stmt_list -> empty .
    }               reduce using rule 29 (stmt_list -> empty .)
    BREAK           reduce using rule 29 (stmt_list -> empty .)
    RETURN          reduce using rule 29 (stmt_list -> empty .)
    FOR             reduce using rule 29 (stmt_list -> empty .)
    WHILE           reduce using rule 29 (stmt_list -> empty .)
    IF              reduce using rule 29 (stmt_list -> empty .)
    {               reduce using rule 29 (stmt_list -> empty .)
    ;               reduce using rule 29 (stmt_list -> empty .)
    NEW             reduce using rule 29 (stmt_list -> empty .)
    STRING_LIT      reduce using rule 29 (stmt_list -> empty .)
    CHAR_LIT        reduce using rule 29 (stmt_list -> empty .)
    FLOAT_LIT       reduce using rule 29 (stmt_list -> empty .)
    INT_LIT         reduce using rule 29 (stmt_list -> empty .)
    BOOL_LIT        reduce using rule 29 (stmt_list -> empty .)
    IDENT           reduce using rule 29 (stmt_list -> empty .)
    (               reduce using rule 29 (stmt_list -> empty .)
    SUB             reduce using rule 29 (stmt_list -> empty .)
    ADD             reduce using rule 29 (stmt_list -> empty .)
    !               reduce using rule 29 (stmt_list -> empty .)
    +               reduce using rule 29 (stmt_list -> empty .)
    -               reduce using rule 29 (stmt_list -> empty .)


state 124

    (26) local_decl -> type_spec . IDENT [ ] ;
    (27) local_decl -> type_spec . IDENT = expr ;
    (28) local_decl -> type_spec . IDENT ;
    IDENT           shift and go to state 141


state 125

    (23) compound_stmt -> { local_decls stmt_list } .
    CONST           reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    CHAR            reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    VOID            reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    FLOAT           reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    INT             reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    BOOL            reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    $end            reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    }               reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    BREAK           reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    RETURN          reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    FOR             reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    WHILE           reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    IF              reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    {               reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    ;               reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    NEW             reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    STRING_LIT      reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    CHAR_LIT        reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    FLOAT_LIT       reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    INT_LIT         reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    BOOL_LIT        reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    IDENT           reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    (               reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    SUB             reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    ADD             reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    !               reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    +               reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    -               reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)
    ELSE            reduce using rule 23 (compound_stmt -> { local_decls stmt_list } .)


state 126

    (30) stmt_list -> stmt_list stmt .
    }               reduce using rule 30 (stmt_list -> stmt_list stmt .)
    BREAK           reduce using rule 30 (stmt_list -> stmt_list stmt .)
    RETURN          reduce using rule 30 (stmt_list -> stmt_list stmt .)
    FOR             reduce using rule 30 (stmt_list -> stmt_list stmt .)
    WHILE           reduce using rule 30 (stmt_list -> stmt_list stmt .)
    IF              reduce using rule 30 (stmt_list -> stmt_list stmt .)
    {               reduce using rule 30 (stmt_list -> stmt_list stmt .)
    ;               reduce using rule 30 (stmt_list -> stmt_list stmt .)
    NEW             reduce using rule 30 (stmt_list -> stmt_list stmt .)
    STRING_LIT      reduce using rule 30 (stmt_list -> stmt_list stmt .)
    CHAR_LIT        reduce using rule 30 (stmt_list -> stmt_list stmt .)
    FLOAT_LIT       reduce using rule 30 (stmt_list -> stmt_list stmt .)
    INT_LIT         reduce using rule 30 (stmt_list -> stmt_list stmt .)
    BOOL_LIT        reduce using rule 30 (stmt_list -> stmt_list stmt .)
    IDENT           reduce using rule 30 (stmt_list -> stmt_list stmt .)
    (               reduce using rule 30 (stmt_list -> stmt_list stmt .)
    SUB             reduce using rule 30 (stmt_list -> stmt_list stmt .)
    ADD             reduce using rule 30 (stmt_list -> stmt_list stmt .)
    !               reduce using rule 30 (stmt_list -> stmt_list stmt .)
    +               reduce using rule 30 (stmt_list -> stmt_list stmt .)
    -               reduce using rule 30 (stmt_list -> stmt_list stmt .)


state 127

    (31) stmt -> break_stmt .
    }               reduce using rule 31 (stmt -> break_stmt .)
    BREAK           reduce using rule 31 (stmt -> break_stmt .)
    RETURN          reduce using rule 31 (stmt -> break_stmt .)
    FOR             reduce using rule 31 (stmt -> break_stmt .)
    WHILE           reduce using rule 31 (stmt -> break_stmt .)
    IF              reduce using rule 31 (stmt -> break_stmt .)
    {               reduce using rule 31 (stmt -> break_stmt .)
    ;               reduce using rule 31 (stmt -> break_stmt .)
    NEW             reduce using rule 31 (stmt -> break_stmt .)
    STRING_LIT      reduce using rule 31 (stmt -> break_stmt .)
    CHAR_LIT        reduce using rule 31 (stmt -> break_stmt .)
    FLOAT_LIT       reduce using rule 31 (stmt -> break_stmt .)
    INT_LIT         reduce using rule 31 (stmt -> break_stmt .)
    BOOL_LIT        reduce using rule 31 (stmt -> break_stmt .)
    IDENT           reduce using rule 31 (stmt -> break_stmt .)
    (               reduce using rule 31 (stmt -> break_stmt .)
    SUB             reduce using rule 31 (stmt -> break_stmt .)
    ADD             reduce using rule 31 (stmt -> break_stmt .)
    !               reduce using rule 31 (stmt -> break_stmt .)
    +               reduce using rule 31 (stmt -> break_stmt .)
    -               reduce using rule 31 (stmt -> break_stmt .)
    ELSE            reduce using rule 31 (stmt -> break_stmt .)


state 128

    (32) stmt -> return_stmt .
    }               reduce using rule 32 (stmt -> return_stmt .)
    BREAK           reduce using rule 32 (stmt -> return_stmt .)
    RETURN          reduce using rule 32 (stmt -> return_stmt .)
    FOR             reduce using rule 32 (stmt -> return_stmt .)
    WHILE           reduce using rule 32 (stmt -> return_stmt .)
    IF              reduce using rule 32 (stmt -> return_stmt .)
    {               reduce using rule 32 (stmt -> return_stmt .)
    ;               reduce using rule 32 (stmt -> return_stmt .)
    NEW             reduce using rule 32 (stmt -> return_stmt .)
    STRING_LIT      reduce using rule 32 (stmt -> return_stmt .)
    CHAR_LIT        reduce using rule 32 (stmt -> return_stmt .)
    FLOAT_LIT       reduce using rule 32 (stmt -> return_stmt .)
    INT_LIT         reduce using rule 32 (stmt -> return_stmt .)
    BOOL_LIT        reduce using rule 32 (stmt -> return_stmt .)
    IDENT           reduce using rule 32 (stmt -> return_stmt .)
    (               reduce using rule 32 (stmt -> return_stmt .)
    SUB             reduce using rule 32 (stmt -> return_stmt .)
    ADD             reduce using rule 32 (stmt -> return_stmt .)
    !               reduce using rule 32 (stmt -> return_stmt .)
    +               reduce using rule 32 (stmt -> return_stmt .)
    -               reduce using rule 32 (stmt -> return_stmt .)
    ELSE            reduce using rule 32 (stmt -> return_stmt .)


state 129

    (33) stmt -> for_stmt .
    }               reduce using rule 33 (stmt -> for_stmt .)
    BREAK           reduce using rule 33 (stmt -> for_stmt .)
    RETURN          reduce using rule 33 (stmt -> for_stmt .)
    FOR             reduce using rule 33 (stmt -> for_stmt .)
    WHILE           reduce using rule 33 (stmt -> for_stmt .)
    IF              reduce using rule 33 (stmt -> for_stmt .)
    {               reduce using rule 33 (stmt -> for_stmt .)
    ;               reduce using rule 33 (stmt -> for_stmt .)
    NEW             reduce using rule 33 (stmt -> for_stmt .)
    STRING_LIT      reduce using rule 33 (stmt -> for_stmt .)
    CHAR_LIT        reduce using rule 33 (stmt -> for_stmt .)
    FLOAT_LIT       reduce using rule 33 (stmt -> for_stmt .)
    INT_LIT         reduce using rule 33 (stmt -> for_stmt .)
    BOOL_LIT        reduce using rule 33 (stmt -> for_stmt .)
    IDENT           reduce using rule 33 (stmt -> for_stmt .)
    (               reduce using rule 33 (stmt -> for_stmt .)
    SUB             reduce using rule 33 (stmt -> for_stmt .)
    ADD             reduce using rule 33 (stmt -> for_stmt .)
    !               reduce using rule 33 (stmt -> for_stmt .)
    +               reduce using rule 33 (stmt -> for_stmt .)
    -               reduce using rule 33 (stmt -> for_stmt .)
    ELSE            reduce using rule 33 (stmt -> for_stmt .)


state 130

    (34) stmt -> while_stmt .
    }               reduce using rule 34 (stmt -> while_stmt .)
    BREAK           reduce using rule 34 (stmt -> while_stmt .)
    RETURN          reduce using rule 34 (stmt -> while_stmt .)
    FOR             reduce using rule 34 (stmt -> while_stmt .)
    WHILE           reduce using rule 34 (stmt -> while_stmt .)
    IF              reduce using rule 34 (stmt -> while_stmt .)
    {               reduce using rule 34 (stmt -> while_stmt .)
    ;               reduce using rule 34 (stmt -> while_stmt .)
    NEW             reduce using rule 34 (stmt -> while_stmt .)
    STRING_LIT      reduce using rule 34 (stmt -> while_stmt .)
    CHAR_LIT        reduce using rule 34 (stmt -> while_stmt .)
    FLOAT_LIT       reduce using rule 34 (stmt -> while_stmt .)
    INT_LIT         reduce using rule 34 (stmt -> while_stmt .)
    BOOL_LIT        reduce using rule 34 (stmt -> while_stmt .)
    IDENT           reduce using rule 34 (stmt -> while_stmt .)
    (               reduce using rule 34 (stmt -> while_stmt .)
    SUB             reduce using rule 34 (stmt -> while_stmt .)
    ADD             reduce using rule 34 (stmt -> while_stmt .)
    !               reduce using rule 34 (stmt -> while_stmt .)
    +               reduce using rule 34 (stmt -> while_stmt .)
    -               reduce using rule 34 (stmt -> while_stmt .)
    ELSE            reduce using rule 34 (stmt -> while_stmt .)


state 131

    (35) stmt -> if_stmt .
    }               reduce using rule 35 (stmt -> if_stmt .)
    BREAK           reduce using rule 35 (stmt -> if_stmt .)
    RETURN          reduce using rule 35 (stmt -> if_stmt .)
    FOR             reduce using rule 35 (stmt -> if_stmt .)
    WHILE           reduce using rule 35 (stmt -> if_stmt .)
    IF              reduce using rule 35 (stmt -> if_stmt .)
    {               reduce using rule 35 (stmt -> if_stmt .)
    ;               reduce using rule 35 (stmt -> if_stmt .)
    NEW             reduce using rule 35 (stmt -> if_stmt .)
    STRING_LIT      reduce using rule 35 (stmt -> if_stmt .)
    CHAR_LIT        reduce using rule 35 (stmt -> if_stmt .)
    FLOAT_LIT       reduce using rule 35 (stmt -> if_stmt .)
    INT_LIT         reduce using rule 35 (stmt -> if_stmt .)
    BOOL_LIT        reduce using rule 35 (stmt -> if_stmt .)
    IDENT           reduce using rule 35 (stmt -> if_stmt .)
    (               reduce using rule 35 (stmt -> if_stmt .)
    SUB             reduce using rule 35 (stmt -> if_stmt .)
    ADD             reduce using rule 35 (stmt -> if_stmt .)
    !               reduce using rule 35 (stmt -> if_stmt .)
    +               reduce using rule 35 (stmt -> if_stmt .)
    -               reduce using rule 35 (stmt -> if_stmt .)
    ELSE            reduce using rule 35 (stmt -> if_stmt .)


state 132

    (36) stmt -> compound_stmt .
    }               reduce using rule 36 (stmt -> compound_stmt .)
    BREAK           reduce using rule 36 (stmt -> compound_stmt .)
    RETURN          reduce using rule 36 (stmt -> compound_stmt .)
    FOR             reduce using rule 36 (stmt -> compound_stmt .)
    WHILE           reduce using rule 36 (stmt -> compound_stmt .)
    IF              reduce using rule 36 (stmt -> compound_stmt .)
    {               reduce using rule 36 (stmt -> compound_stmt .)
    ;               reduce using rule 36 (stmt -> compound_stmt .)
    NEW             reduce using rule 36 (stmt -> compound_stmt .)
    STRING_LIT      reduce using rule 36 (stmt -> compound_stmt .)
    CHAR_LIT        reduce using rule 36 (stmt -> compound_stmt .)
    FLOAT_LIT       reduce using rule 36 (stmt -> compound_stmt .)
    INT_LIT         reduce using rule 36 (stmt -> compound_stmt .)
    BOOL_LIT        reduce using rule 36 (stmt -> compound_stmt .)
    IDENT           reduce using rule 36 (stmt -> compound_stmt .)
    (               reduce using rule 36 (stmt -> compound_stmt .)
    SUB             reduce using rule 36 (stmt -> compound_stmt .)
    ADD             reduce using rule 36 (stmt -> compound_stmt .)
    !               reduce using rule 36 (stmt -> compound_stmt .)
    +               reduce using rule 36 (stmt -> compound_stmt .)
    -               reduce using rule 36 (stmt -> compound_stmt .)
    ELSE            reduce using rule 36 (stmt -> compound_stmt .)


state 133

    (37) stmt -> expr_stmt .
    }               reduce using rule 37 (stmt -> expr_stmt .)
    BREAK           reduce using rule 37 (stmt -> expr_stmt .)
    RETURN          reduce using rule 37 (stmt -> expr_stmt .)
    FOR             reduce using rule 37 (stmt -> expr_stmt .)
    WHILE           reduce using rule 37 (stmt -> expr_stmt .)
    IF              reduce using rule 37 (stmt -> expr_stmt .)
    {               reduce using rule 37 (stmt -> expr_stmt .)
    ;               reduce using rule 37 (stmt -> expr_stmt .)
    NEW             reduce using rule 37 (stmt -> expr_stmt .)
    STRING_LIT      reduce using rule 37 (stmt -> expr_stmt .)
    CHAR_LIT        reduce using rule 37 (stmt -> expr_stmt .)
    FLOAT_LIT       reduce using rule 37 (stmt -> expr_stmt .)
    INT_LIT         reduce using rule 37 (stmt -> expr_stmt .)
    BOOL_LIT        reduce using rule 37 (stmt -> expr_stmt .)
    IDENT           reduce using rule 37 (stmt -> expr_stmt .)
    (               reduce using rule 37 (stmt -> expr_stmt .)
    SUB             reduce using rule 37 (stmt -> expr_stmt .)
    ADD             reduce using rule 37 (stmt -> expr_stmt .)
    !               reduce using rule 37 (stmt -> expr_stmt .)
    +               reduce using rule 37 (stmt -> expr_stmt .)
    -               reduce using rule 37 (stmt -> expr_stmt .)
    ELSE            reduce using rule 37 (stmt -> expr_stmt .)


state 134

    (46) break_stmt -> BREAK . ;
    ;               shift and go to state 142


state 135

    (38) expr_stmt -> ; .
    }               reduce using rule 38 (expr_stmt -> ; .)
    BREAK           reduce using rule 38 (expr_stmt -> ; .)
    RETURN          reduce using rule 38 (expr_stmt -> ; .)
    FOR             reduce using rule 38 (expr_stmt -> ; .)
    WHILE           reduce using rule 38 (expr_stmt -> ; .)
    IF              reduce using rule 38 (expr_stmt -> ; .)
    {               reduce using rule 38 (expr_stmt -> ; .)
    ;               reduce using rule 38 (expr_stmt -> ; .)
    NEW             reduce using rule 38 (expr_stmt -> ; .)
    STRING_LIT      reduce using rule 38 (expr_stmt -> ; .)
    CHAR_LIT        reduce using rule 38 (expr_stmt -> ; .)
    FLOAT_LIT       reduce using rule 38 (expr_stmt -> ; .)
    INT_LIT         reduce using rule 38 (expr_stmt -> ; .)
    BOOL_LIT        reduce using rule 38 (expr_stmt -> ; .)
    IDENT           reduce using rule 38 (expr_stmt -> ; .)
    (               reduce using rule 38 (expr_stmt -> ; .)
    SUB             reduce using rule 38 (expr_stmt -> ; .)
    ADD             reduce using rule 38 (expr_stmt -> ; .)
    !               reduce using rule 38 (expr_stmt -> ; .)
    +               reduce using rule 38 (expr_stmt -> ; .)
    -               reduce using rule 38 (expr_stmt -> ; .)
    ELSE            reduce using rule 38 (expr_stmt -> ; .)


state 136

    (44) return_stmt -> RETURN . expr ;
    (45) return_stmt -> RETURN . ;
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . STRING_LIT
    (51) expr -> . CHAR_LIT
    (52) expr -> . FLOAT_LIT
    (53) expr -> . INT_LIT
    (54) expr -> . BOOL_LIT
    (55) expr -> . IDENT . SIZE
    (56) expr -> . IDENT ( args )
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . expr SUB
    (60) expr -> . expr ADD
    (61) expr -> . SUB expr
    (62) expr -> . ADD expr
    (63) expr -> . ! expr
    (64) expr -> . + expr
    (65) expr -> . - expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr MDE expr
    (72) expr -> . expr TE expr
    (73) expr -> . expr DE expr
    (74) expr -> . expr PE expr
    (75) expr -> . expr ME expr
    (76) expr -> . expr > expr
    (77) expr -> . expr GE expr
    (78) expr -> . expr < expr
    (79) expr -> . expr LE expr
    (80) expr -> . expr NE expr
    (81) expr -> . expr EQ expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . location = expr
    (47) location -> . IDENT [ expr ]
    (48) location -> . IDENT
    ;               shift and go to state 144
    NEW             shift and go to state 24
    STRING_LIT      shift and go to state 25
    CHAR_LIT        shift and go to state 26
    FLOAT_LIT       shift and go to state 27
    INT_LIT         shift and go to state 28
    BOOL_LIT        shift and go to state 29
    IDENT           shift and go to state 22
    (               shift and go to state 30
    SUB             shift and go to state 32
    ADD             shift and go to state 33
    !               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36

    expr                           shift and go to state 143
    location                       shift and go to state 31

state 137

    (39) expr_stmt -> expr . ;
    (59) expr -> expr . SUB
    (60) expr -> expr . ADD
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . MDE expr
    (72) expr -> expr . TE expr
    (73) expr -> expr . DE expr
    (74) expr -> expr . PE expr
    (75) expr -> expr . ME expr
    (76) expr -> expr . > expr
    (77) expr -> expr . GE expr
    (78) expr -> expr . < expr
    (79) expr -> expr . LE expr
    (80) expr -> expr . NE expr
    (81) expr -> expr . EQ expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    ;               shift and go to state 145
    SUB             shift and go to state 48
    ADD             shift and go to state 49
    %               shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54
    MDE             shift and go to state 55
    TE              shift and go to state 56
    DE              shift and go to state 57
    PE              shift and go to state 58
    ME              shift and go to state 59
    >               shift and go to state 60
    GE              shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    NE              shift and go to state 64
    EQ              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 138

    (41) for_stmt -> FOR . ( var_decl expr_stmt expr ) compound_stmt
    (               shift and go to state 146


state 139

    (40) while_stmt -> WHILE . ( expr ) compound_stmt
    (               shift and go to state 147


state 140

    (42) if_stmt -> IF . ( expr ) stmt
    (43) if_stmt -> IF . ( expr ) stmt ELSE stmt
    (               shift and go to state 148


state 141

    (26) local_decl -> type_spec IDENT . [ ] ;
    (27) local_decl -> type_spec IDENT . = expr ;
    (28) local_decl -> type_spec IDENT . ;
    [               shift and go to state 149
    =               shift and go to state 151
    ;               shift and go to state 150


state 142

    (46) break_stmt -> BREAK ; .
    }               reduce using rule 46 (break_stmt -> BREAK ; .)
    BREAK           reduce using rule 46 (break_stmt -> BREAK ; .)
    RETURN          reduce using rule 46 (break_stmt -> BREAK ; .)
    FOR             reduce using rule 46 (break_stmt -> BREAK ; .)
    WHILE           reduce using rule 46 (break_stmt -> BREAK ; .)
    IF              reduce using rule 46 (break_stmt -> BREAK ; .)
    {               reduce using rule 46 (break_stmt -> BREAK ; .)
    ;               reduce using rule 46 (break_stmt -> BREAK ; .)
    NEW             reduce using rule 46 (break_stmt -> BREAK ; .)
    STRING_LIT      reduce using rule 46 (break_stmt -> BREAK ; .)
    CHAR_LIT        reduce using rule 46 (break_stmt -> BREAK ; .)
    FLOAT_LIT       reduce using rule 46 (break_stmt -> BREAK ; .)
    INT_LIT         reduce using rule 46 (break_stmt -> BREAK ; .)
    BOOL_LIT        reduce using rule 46 (break_stmt -> BREAK ; .)
    IDENT           reduce using rule 46 (break_stmt -> BREAK ; .)
    (               reduce using rule 46 (break_stmt -> BREAK ; .)
    SUB             reduce using rule 46 (break_stmt -> BREAK ; .)
    ADD             reduce using rule 46 (break_stmt -> BREAK ; .)
    !               reduce using rule 46 (break_stmt -> BREAK ; .)
    +               reduce using rule 46 (break_stmt -> BREAK ; .)
    -               reduce using rule 46 (break_stmt -> BREAK ; .)
    ELSE            reduce using rule 46 (break_stmt -> BREAK ; .)


state 143

    (44) return_stmt -> RETURN expr . ;
    (59) expr -> expr . SUB
    (60) expr -> expr . ADD
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . MDE expr
    (72) expr -> expr . TE expr
    (73) expr -> expr . DE expr
    (74) expr -> expr . PE expr
    (75) expr -> expr . ME expr
    (76) expr -> expr . > expr
    (77) expr -> expr . GE expr
    (78) expr -> expr . < expr
    (79) expr -> expr . LE expr
    (80) expr -> expr . NE expr
    (81) expr -> expr . EQ expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    ;               shift and go to state 152
    SUB             shift and go to state 48
    ADD             shift and go to state 49
    %               shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54
    MDE             shift and go to state 55
    TE              shift and go to state 56
    DE              shift and go to state 57
    PE              shift and go to state 58
    ME              shift and go to state 59
    >               shift and go to state 60
    GE              shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    NE              shift and go to state 64
    EQ              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 144

    (45) return_stmt -> RETURN ; .
    }               reduce using rule 45 (return_stmt -> RETURN ; .)
    BREAK           reduce using rule 45 (return_stmt -> RETURN ; .)
    RETURN          reduce using rule 45 (return_stmt -> RETURN ; .)
    FOR             reduce using rule 45 (return_stmt -> RETURN ; .)
    WHILE           reduce using rule 45 (return_stmt -> RETURN ; .)
    IF              reduce using rule 45 (return_stmt -> RETURN ; .)
    {               reduce using rule 45 (return_stmt -> RETURN ; .)
    ;               reduce using rule 45 (return_stmt -> RETURN ; .)
    NEW             reduce using rule 45 (return_stmt -> RETURN ; .)
    STRING_LIT      reduce using rule 45 (return_stmt -> RETURN ; .)
    CHAR_LIT        reduce using rule 45 (return_stmt -> RETURN ; .)
    FLOAT_LIT       reduce using rule 45 (return_stmt -> RETURN ; .)
    INT_LIT         reduce using rule 45 (return_stmt -> RETURN ; .)
    BOOL_LIT        reduce using rule 45 (return_stmt -> RETURN ; .)
    IDENT           reduce using rule 45 (return_stmt -> RETURN ; .)
    (               reduce using rule 45 (return_stmt -> RETURN ; .)
    SUB             reduce using rule 45 (return_stmt -> RETURN ; .)
    ADD             reduce using rule 45 (return_stmt -> RETURN ; .)
    !               reduce using rule 45 (return_stmt -> RETURN ; .)
    +               reduce using rule 45 (return_stmt -> RETURN ; .)
    -               reduce using rule 45 (return_stmt -> RETURN ; .)
    ELSE            reduce using rule 45 (return_stmt -> RETURN ; .)


state 145

    (39) expr_stmt -> expr ; .
    }               reduce using rule 39 (expr_stmt -> expr ; .)
    BREAK           reduce using rule 39 (expr_stmt -> expr ; .)
    RETURN          reduce using rule 39 (expr_stmt -> expr ; .)
    FOR             reduce using rule 39 (expr_stmt -> expr ; .)
    WHILE           reduce using rule 39 (expr_stmt -> expr ; .)
    IF              reduce using rule 39 (expr_stmt -> expr ; .)
    {               reduce using rule 39 (expr_stmt -> expr ; .)
    ;               reduce using rule 39 (expr_stmt -> expr ; .)
    NEW             reduce using rule 39 (expr_stmt -> expr ; .)
    STRING_LIT      reduce using rule 39 (expr_stmt -> expr ; .)
    CHAR_LIT        reduce using rule 39 (expr_stmt -> expr ; .)
    FLOAT_LIT       reduce using rule 39 (expr_stmt -> expr ; .)
    INT_LIT         reduce using rule 39 (expr_stmt -> expr ; .)
    BOOL_LIT        reduce using rule 39 (expr_stmt -> expr ; .)
    IDENT           reduce using rule 39 (expr_stmt -> expr ; .)
    (               reduce using rule 39 (expr_stmt -> expr ; .)
    SUB             reduce using rule 39 (expr_stmt -> expr ; .)
    ADD             reduce using rule 39 (expr_stmt -> expr ; .)
    !               reduce using rule 39 (expr_stmt -> expr ; .)
    +               reduce using rule 39 (expr_stmt -> expr ; .)
    -               reduce using rule 39 (expr_stmt -> expr ; .)
    ELSE            reduce using rule 39 (expr_stmt -> expr ; .)


state 146

    (41) for_stmt -> FOR ( . var_decl expr_stmt expr ) compound_stmt
    (8) var_decl -> . type_spec IDENT [ ] ;
    (9) var_decl -> . type_spec IDENT = expr ;
    (10) var_decl -> . type_spec IDENT ;
    (11) type_spec -> . CHAR
    (12) type_spec -> . VOID
    (13) type_spec -> . FLOAT
    (14) type_spec -> . INT
    (15) type_spec -> . BOOL
    CHAR            shift and go to state 9
    VOID            shift and go to state 10
    FLOAT           shift and go to state 11
    INT             shift and go to state 12
    BOOL            shift and go to state 13

    var_decl                       shift and go to state 153
    type_spec                      shift and go to state 154

state 147

    (40) while_stmt -> WHILE ( . expr ) compound_stmt
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . STRING_LIT
    (51) expr -> . CHAR_LIT
    (52) expr -> . FLOAT_LIT
    (53) expr -> . INT_LIT
    (54) expr -> . BOOL_LIT
    (55) expr -> . IDENT . SIZE
    (56) expr -> . IDENT ( args )
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . expr SUB
    (60) expr -> . expr ADD
    (61) expr -> . SUB expr
    (62) expr -> . ADD expr
    (63) expr -> . ! expr
    (64) expr -> . + expr
    (65) expr -> . - expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr MDE expr
    (72) expr -> . expr TE expr
    (73) expr -> . expr DE expr
    (74) expr -> . expr PE expr
    (75) expr -> . expr ME expr
    (76) expr -> . expr > expr
    (77) expr -> . expr GE expr
    (78) expr -> . expr < expr
    (79) expr -> . expr LE expr
    (80) expr -> . expr NE expr
    (81) expr -> . expr EQ expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . location = expr
    (47) location -> . IDENT [ expr ]
    (48) location -> . IDENT
    NEW             shift and go to state 24
    STRING_LIT      shift and go to state 25
    CHAR_LIT        shift and go to state 26
    FLOAT_LIT       shift and go to state 27
    INT_LIT         shift and go to state 28
    BOOL_LIT        shift and go to state 29
    IDENT           shift and go to state 22
    (               shift and go to state 30
    SUB             shift and go to state 32
    ADD             shift and go to state 33
    !               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36

    expr                           shift and go to state 155
    location                       shift and go to state 31

state 148

    (42) if_stmt -> IF ( . expr ) stmt
    (43) if_stmt -> IF ( . expr ) stmt ELSE stmt
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . STRING_LIT
    (51) expr -> . CHAR_LIT
    (52) expr -> . FLOAT_LIT
    (53) expr -> . INT_LIT
    (54) expr -> . BOOL_LIT
    (55) expr -> . IDENT . SIZE
    (56) expr -> . IDENT ( args )
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . expr SUB
    (60) expr -> . expr ADD
    (61) expr -> . SUB expr
    (62) expr -> . ADD expr
    (63) expr -> . ! expr
    (64) expr -> . + expr
    (65) expr -> . - expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr MDE expr
    (72) expr -> . expr TE expr
    (73) expr -> . expr DE expr
    (74) expr -> . expr PE expr
    (75) expr -> . expr ME expr
    (76) expr -> . expr > expr
    (77) expr -> . expr GE expr
    (78) expr -> . expr < expr
    (79) expr -> . expr LE expr
    (80) expr -> . expr NE expr
    (81) expr -> . expr EQ expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . location = expr
    (47) location -> . IDENT [ expr ]
    (48) location -> . IDENT
    NEW             shift and go to state 24
    STRING_LIT      shift and go to state 25
    CHAR_LIT        shift and go to state 26
    FLOAT_LIT       shift and go to state 27
    INT_LIT         shift and go to state 28
    BOOL_LIT        shift and go to state 29
    IDENT           shift and go to state 22
    (               shift and go to state 30
    SUB             shift and go to state 32
    ADD             shift and go to state 33
    !               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36

    expr                           shift and go to state 156
    location                       shift and go to state 31

state 149

    (26) local_decl -> type_spec IDENT [ . ] ;
    ]               shift and go to state 157


state 150

    (28) local_decl -> type_spec IDENT ; .
    CHAR            reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    VOID            reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    FLOAT           reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    INT             reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    BOOL            reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    }               reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    BREAK           reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    RETURN          reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    FOR             reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    WHILE           reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    IF              reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    {               reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    ;               reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    NEW             reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    STRING_LIT      reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    CHAR_LIT        reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    FLOAT_LIT       reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    INT_LIT         reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    BOOL_LIT        reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    IDENT           reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    (               reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    SUB             reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    ADD             reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    !               reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    +               reduce using rule 28 (local_decl -> type_spec IDENT ; .)
    -               reduce using rule 28 (local_decl -> type_spec IDENT ; .)


state 151

    (27) local_decl -> type_spec IDENT = . expr ;
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . STRING_LIT
    (51) expr -> . CHAR_LIT
    (52) expr -> . FLOAT_LIT
    (53) expr -> . INT_LIT
    (54) expr -> . BOOL_LIT
    (55) expr -> . IDENT . SIZE
    (56) expr -> . IDENT ( args )
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . expr SUB
    (60) expr -> . expr ADD
    (61) expr -> . SUB expr
    (62) expr -> . ADD expr
    (63) expr -> . ! expr
    (64) expr -> . + expr
    (65) expr -> . - expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr MDE expr
    (72) expr -> . expr TE expr
    (73) expr -> . expr DE expr
    (74) expr -> . expr PE expr
    (75) expr -> . expr ME expr
    (76) expr -> . expr > expr
    (77) expr -> . expr GE expr
    (78) expr -> . expr < expr
    (79) expr -> . expr LE expr
    (80) expr -> . expr NE expr
    (81) expr -> . expr EQ expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . location = expr
    (47) location -> . IDENT [ expr ]
    (48) location -> . IDENT
    NEW             shift and go to state 24
    STRING_LIT      shift and go to state 25
    CHAR_LIT        shift and go to state 26
    FLOAT_LIT       shift and go to state 27
    INT_LIT         shift and go to state 28
    BOOL_LIT        shift and go to state 29
    IDENT           shift and go to state 22
    (               shift and go to state 30
    SUB             shift and go to state 32
    ADD             shift and go to state 33
    !               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36

    expr                           shift and go to state 158
    location                       shift and go to state 31

state 152

    (44) return_stmt -> RETURN expr ; .
    }               reduce using rule 44 (return_stmt -> RETURN expr ; .)
    BREAK           reduce using rule 44 (return_stmt -> RETURN expr ; .)
    RETURN          reduce using rule 44 (return_stmt -> RETURN expr ; .)
    FOR             reduce using rule 44 (return_stmt -> RETURN expr ; .)
    WHILE           reduce using rule 44 (return_stmt -> RETURN expr ; .)
    IF              reduce using rule 44 (return_stmt -> RETURN expr ; .)
    {               reduce using rule 44 (return_stmt -> RETURN expr ; .)
    ;               reduce using rule 44 (return_stmt -> RETURN expr ; .)
    NEW             reduce using rule 44 (return_stmt -> RETURN expr ; .)
    STRING_LIT      reduce using rule 44 (return_stmt -> RETURN expr ; .)
    CHAR_LIT        reduce using rule 44 (return_stmt -> RETURN expr ; .)
    FLOAT_LIT       reduce using rule 44 (return_stmt -> RETURN expr ; .)
    INT_LIT         reduce using rule 44 (return_stmt -> RETURN expr ; .)
    BOOL_LIT        reduce using rule 44 (return_stmt -> RETURN expr ; .)
    IDENT           reduce using rule 44 (return_stmt -> RETURN expr ; .)
    (               reduce using rule 44 (return_stmt -> RETURN expr ; .)
    SUB             reduce using rule 44 (return_stmt -> RETURN expr ; .)
    ADD             reduce using rule 44 (return_stmt -> RETURN expr ; .)
    !               reduce using rule 44 (return_stmt -> RETURN expr ; .)
    +               reduce using rule 44 (return_stmt -> RETURN expr ; .)
    -               reduce using rule 44 (return_stmt -> RETURN expr ; .)
    ELSE            reduce using rule 44 (return_stmt -> RETURN expr ; .)


state 153

    (41) for_stmt -> FOR ( var_decl . expr_stmt expr ) compound_stmt
    (38) expr_stmt -> . ;
    (39) expr_stmt -> . expr ;
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . STRING_LIT
    (51) expr -> . CHAR_LIT
    (52) expr -> . FLOAT_LIT
    (53) expr -> . INT_LIT
    (54) expr -> . BOOL_LIT
    (55) expr -> . IDENT . SIZE
    (56) expr -> . IDENT ( args )
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . expr SUB
    (60) expr -> . expr ADD
    (61) expr -> . SUB expr
    (62) expr -> . ADD expr
    (63) expr -> . ! expr
    (64) expr -> . + expr
    (65) expr -> . - expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr MDE expr
    (72) expr -> . expr TE expr
    (73) expr -> . expr DE expr
    (74) expr -> . expr PE expr
    (75) expr -> . expr ME expr
    (76) expr -> . expr > expr
    (77) expr -> . expr GE expr
    (78) expr -> . expr < expr
    (79) expr -> . expr LE expr
    (80) expr -> . expr NE expr
    (81) expr -> . expr EQ expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . location = expr
    (47) location -> . IDENT [ expr ]
    (48) location -> . IDENT
    ;               shift and go to state 135
    NEW             shift and go to state 24
    STRING_LIT      shift and go to state 25
    CHAR_LIT        shift and go to state 26
    FLOAT_LIT       shift and go to state 27
    INT_LIT         shift and go to state 28
    BOOL_LIT        shift and go to state 29
    IDENT           shift and go to state 22
    (               shift and go to state 30
    SUB             shift and go to state 32
    ADD             shift and go to state 33
    !               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36

    expr_stmt                      shift and go to state 159
    expr                           shift and go to state 137
    location                       shift and go to state 31

state 154

    (8) var_decl -> type_spec . IDENT [ ] ;
    (9) var_decl -> type_spec . IDENT = expr ;
    (10) var_decl -> type_spec . IDENT ;
    IDENT           shift and go to state 160


state 155

    (40) while_stmt -> WHILE ( expr . ) compound_stmt
    (59) expr -> expr . SUB
    (60) expr -> expr . ADD
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . MDE expr
    (72) expr -> expr . TE expr
    (73) expr -> expr . DE expr
    (74) expr -> expr . PE expr
    (75) expr -> expr . ME expr
    (76) expr -> expr . > expr
    (77) expr -> expr . GE expr
    (78) expr -> expr . < expr
    (79) expr -> expr . LE expr
    (80) expr -> expr . NE expr
    (81) expr -> expr . EQ expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    )               shift and go to state 161
    SUB             shift and go to state 48
    ADD             shift and go to state 49
    %               shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54
    MDE             shift and go to state 55
    TE              shift and go to state 56
    DE              shift and go to state 57
    PE              shift and go to state 58
    ME              shift and go to state 59
    >               shift and go to state 60
    GE              shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    NE              shift and go to state 64
    EQ              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 156

    (42) if_stmt -> IF ( expr . ) stmt
    (43) if_stmt -> IF ( expr . ) stmt ELSE stmt
    (59) expr -> expr . SUB
    (60) expr -> expr . ADD
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . MDE expr
    (72) expr -> expr . TE expr
    (73) expr -> expr . DE expr
    (74) expr -> expr . PE expr
    (75) expr -> expr . ME expr
    (76) expr -> expr . > expr
    (77) expr -> expr . GE expr
    (78) expr -> expr . < expr
    (79) expr -> expr . LE expr
    (80) expr -> expr . NE expr
    (81) expr -> expr . EQ expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    )               shift and go to state 162
    SUB             shift and go to state 48
    ADD             shift and go to state 49
    %               shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54
    MDE             shift and go to state 55
    TE              shift and go to state 56
    DE              shift and go to state 57
    PE              shift and go to state 58
    ME              shift and go to state 59
    >               shift and go to state 60
    GE              shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    NE              shift and go to state 64
    EQ              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 157

    (26) local_decl -> type_spec IDENT [ ] . ;
    ;               shift and go to state 163


state 158

    (27) local_decl -> type_spec IDENT = expr . ;
    (59) expr -> expr . SUB
    (60) expr -> expr . ADD
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . MDE expr
    (72) expr -> expr . TE expr
    (73) expr -> expr . DE expr
    (74) expr -> expr . PE expr
    (75) expr -> expr . ME expr
    (76) expr -> expr . > expr
    (77) expr -> expr . GE expr
    (78) expr -> expr . < expr
    (79) expr -> expr . LE expr
    (80) expr -> expr . NE expr
    (81) expr -> expr . EQ expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    ;               shift and go to state 164
    SUB             shift and go to state 48
    ADD             shift and go to state 49
    %               shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54
    MDE             shift and go to state 55
    TE              shift and go to state 56
    DE              shift and go to state 57
    PE              shift and go to state 58
    ME              shift and go to state 59
    >               shift and go to state 60
    GE              shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    NE              shift and go to state 64
    EQ              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 159

    (41) for_stmt -> FOR ( var_decl expr_stmt . expr ) compound_stmt
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . STRING_LIT
    (51) expr -> . CHAR_LIT
    (52) expr -> . FLOAT_LIT
    (53) expr -> . INT_LIT
    (54) expr -> . BOOL_LIT
    (55) expr -> . IDENT . SIZE
    (56) expr -> . IDENT ( args )
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . expr SUB
    (60) expr -> . expr ADD
    (61) expr -> . SUB expr
    (62) expr -> . ADD expr
    (63) expr -> . ! expr
    (64) expr -> . + expr
    (65) expr -> . - expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr MDE expr
    (72) expr -> . expr TE expr
    (73) expr -> . expr DE expr
    (74) expr -> . expr PE expr
    (75) expr -> . expr ME expr
    (76) expr -> . expr > expr
    (77) expr -> . expr GE expr
    (78) expr -> . expr < expr
    (79) expr -> . expr LE expr
    (80) expr -> . expr NE expr
    (81) expr -> . expr EQ expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . location = expr
    (47) location -> . IDENT [ expr ]
    (48) location -> . IDENT
    NEW             shift and go to state 24
    STRING_LIT      shift and go to state 25
    CHAR_LIT        shift and go to state 26
    FLOAT_LIT       shift and go to state 27
    INT_LIT         shift and go to state 28
    BOOL_LIT        shift and go to state 29
    IDENT           shift and go to state 22
    (               shift and go to state 30
    SUB             shift and go to state 32
    ADD             shift and go to state 33
    !               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36

    expr                           shift and go to state 165
    location                       shift and go to state 31

state 160

    (8) var_decl -> type_spec IDENT . [ ] ;
    (9) var_decl -> type_spec IDENT . = expr ;
    (10) var_decl -> type_spec IDENT . ;
    [               shift and go to state 19
    =               shift and go to state 21
    ;               shift and go to state 20


state 161

    (40) while_stmt -> WHILE ( expr ) . compound_stmt
    (23) compound_stmt -> . { local_decls stmt_list }
    {               shift and go to state 110

    compound_stmt                  shift and go to state 166

state 162

    (42) if_stmt -> IF ( expr ) . stmt
    (43) if_stmt -> IF ( expr ) . stmt ELSE stmt
    (31) stmt -> . break_stmt
    (32) stmt -> . return_stmt
    (33) stmt -> . for_stmt
    (34) stmt -> . while_stmt
    (35) stmt -> . if_stmt
    (36) stmt -> . compound_stmt
    (37) stmt -> . expr_stmt
    (46) break_stmt -> . BREAK ;
    (44) return_stmt -> . RETURN expr ;
    (45) return_stmt -> . RETURN ;
    (41) for_stmt -> . FOR ( var_decl expr_stmt expr ) compound_stmt
    (40) while_stmt -> . WHILE ( expr ) compound_stmt
    (42) if_stmt -> . IF ( expr ) stmt
    (43) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (23) compound_stmt -> . { local_decls stmt_list }
    (38) expr_stmt -> . ;
    (39) expr_stmt -> . expr ;
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . STRING_LIT
    (51) expr -> . CHAR_LIT
    (52) expr -> . FLOAT_LIT
    (53) expr -> . INT_LIT
    (54) expr -> . BOOL_LIT
    (55) expr -> . IDENT . SIZE
    (56) expr -> . IDENT ( args )
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . expr SUB
    (60) expr -> . expr ADD
    (61) expr -> . SUB expr
    (62) expr -> . ADD expr
    (63) expr -> . ! expr
    (64) expr -> . + expr
    (65) expr -> . - expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr MDE expr
    (72) expr -> . expr TE expr
    (73) expr -> . expr DE expr
    (74) expr -> . expr PE expr
    (75) expr -> . expr ME expr
    (76) expr -> . expr > expr
    (77) expr -> . expr GE expr
    (78) expr -> . expr < expr
    (79) expr -> . expr LE expr
    (80) expr -> . expr NE expr
    (81) expr -> . expr EQ expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . location = expr
    (47) location -> . IDENT [ expr ]
    (48) location -> . IDENT
    BREAK           shift and go to state 134
    RETURN          shift and go to state 136
    FOR             shift and go to state 138
    WHILE           shift and go to state 139
    IF              shift and go to state 140
    {               shift and go to state 110
    ;               shift and go to state 135
    NEW             shift and go to state 24
    STRING_LIT      shift and go to state 25
    CHAR_LIT        shift and go to state 26
    FLOAT_LIT       shift and go to state 27
    INT_LIT         shift and go to state 28
    BOOL_LIT        shift and go to state 29
    IDENT           shift and go to state 22
    (               shift and go to state 30
    SUB             shift and go to state 32
    ADD             shift and go to state 33
    !               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36

    expr                           shift and go to state 137
    stmt                           shift and go to state 167
    break_stmt                     shift and go to state 127
    return_stmt                    shift and go to state 128
    for_stmt                       shift and go to state 129
    while_stmt                     shift and go to state 130
    if_stmt                        shift and go to state 131
    compound_stmt                  shift and go to state 132
    expr_stmt                      shift and go to state 133
    location                       shift and go to state 31

state 163

    (26) local_decl -> type_spec IDENT [ ] ; .
    CHAR            reduce using rule 26 (local_decl -> type_spec IDENT [ ] ; .)
    VOID            reduce using rule 26 (local_decl -> type_spec IDENT [ ] ; .)
    FLOAT           reduce using rule 26 (local_decl -> type_spec IDENT [ ] ; .)
    INT             reduce using rule 26 (local_decl -> type_spec IDENT [ ] ; .)
    BOOL            reduce using rule 26 (local_decl -> type_spec IDENT [ ] ; .)
    }               reduce using rule 26 (local_decl -> type_spec IDENT [ ] ; .)
    BREAK           reduce using rule 26 (local_decl -> type_spec IDENT [ ] ; .)
    RETURN          reduce using rule 26 (local_decl -> type_spec IDENT [ ] ; .)
    FOR             reduce using rule 26 (local_decl -> type_spec IDENT [ ] ; .)
    WHILE           reduce using rule 26 (local_decl -> type_spec IDENT [ ] ; .)
    IF              reduce using rule 26 (local_decl -> type_spec IDENT [ ] ; .)
    {               reduce using rule 26 (local_decl -> type_spec IDENT [ ] ; .)
    ;               reduce using rule 26 (local_decl -> type_spec IDENT [ ] ; .)
    NEW             reduce using rule 26 (local_decl -> type_spec IDENT [ ] ; .)
    STRING_LIT      reduce using rule 26 (local_decl -> type_spec IDENT [ ] ; .)
    CHAR_LIT        reduce using rule 26 (local_decl -> type_spec IDENT [ ] ; .)
    FLOAT_LIT       reduce using rule 26 (local_decl -> type_spec IDENT [ ] ; .)
    INT_LIT         reduce using rule 26 (local_decl -> type_spec IDENT [ ] ; .)
    BOOL_LIT        reduce using rule 26 (local_decl -> type_spec IDENT [ ] ; .)
    IDENT           reduce using rule 26 (local_decl -> type_spec IDENT [ ] ; .)
    (               reduce using rule 26 (local_decl -> type_spec IDENT [ ] ; .)
    SUB             reduce using rule 26 (local_decl -> type_spec IDENT [ ] ; .)
    ADD             reduce using rule 26 (local_decl -> type_spec IDENT [ ] ; .)
    !               reduce using rule 26 (local_decl -> type_spec IDENT [ ] ; .)
    +               reduce using rule 26 (local_decl -> type_spec IDENT [ ] ; .)
    -               reduce using rule 26 (local_decl -> type_spec IDENT [ ] ; .)


state 164

    (27) local_decl -> type_spec IDENT = expr ; .
    CHAR            reduce using rule 27 (local_decl -> type_spec IDENT = expr ; .)
    VOID            reduce using rule 27 (local_decl -> type_spec IDENT = expr ; .)
    FLOAT           reduce using rule 27 (local_decl -> type_spec IDENT = expr ; .)
    INT             reduce using rule 27 (local_decl -> type_spec IDENT = expr ; .)
    BOOL            reduce using rule 27 (local_decl -> type_spec IDENT = expr ; .)
    }               reduce using rule 27 (local_decl -> type_spec IDENT = expr ; .)
    BREAK           reduce using rule 27 (local_decl -> type_spec IDENT = expr ; .)
    RETURN          reduce using rule 27 (local_decl -> type_spec IDENT = expr ; .)
    FOR             reduce using rule 27 (local_decl -> type_spec IDENT = expr ; .)
    WHILE           reduce using rule 27 (local_decl -> type_spec IDENT = expr ; .)
    IF              reduce using rule 27 (local_decl -> type_spec IDENT = expr ; .)
    {               reduce using rule 27 (local_decl -> type_spec IDENT = expr ; .)
    ;               reduce using rule 27 (local_decl -> type_spec IDENT = expr ; .)
    NEW             reduce using rule 27 (local_decl -> type_spec IDENT = expr ; .)
    STRING_LIT      reduce using rule 27 (local_decl -> type_spec IDENT = expr ; .)
    CHAR_LIT        reduce using rule 27 (local_decl -> type_spec IDENT = expr ; .)
    FLOAT_LIT       reduce using rule 27 (local_decl -> type_spec IDENT = expr ; .)
    INT_LIT         reduce using rule 27 (local_decl -> type_spec IDENT = expr ; .)
    BOOL_LIT        reduce using rule 27 (local_decl -> type_spec IDENT = expr ; .)
    IDENT           reduce using rule 27 (local_decl -> type_spec IDENT = expr ; .)
    (               reduce using rule 27 (local_decl -> type_spec IDENT = expr ; .)
    SUB             reduce using rule 27 (local_decl -> type_spec IDENT = expr ; .)
    ADD             reduce using rule 27 (local_decl -> type_spec IDENT = expr ; .)
    !               reduce using rule 27 (local_decl -> type_spec IDENT = expr ; .)
    +               reduce using rule 27 (local_decl -> type_spec IDENT = expr ; .)
    -               reduce using rule 27 (local_decl -> type_spec IDENT = expr ; .)


state 165

    (41) for_stmt -> FOR ( var_decl expr_stmt expr . ) compound_stmt
    (59) expr -> expr . SUB
    (60) expr -> expr . ADD
    (66) expr -> expr . % expr
    (67) expr -> expr . / expr
    (68) expr -> expr . * expr
    (69) expr -> expr . - expr
    (70) expr -> expr . + expr
    (71) expr -> expr . MDE expr
    (72) expr -> expr . TE expr
    (73) expr -> expr . DE expr
    (74) expr -> expr . PE expr
    (75) expr -> expr . ME expr
    (76) expr -> expr . > expr
    (77) expr -> expr . GE expr
    (78) expr -> expr . < expr
    (79) expr -> expr . LE expr
    (80) expr -> expr . NE expr
    (81) expr -> expr . EQ expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    )               shift and go to state 168
    SUB             shift and go to state 48
    ADD             shift and go to state 49
    %               shift and go to state 50
    /               shift and go to state 51
    *               shift and go to state 52
    -               shift and go to state 53
    +               shift and go to state 54
    MDE             shift and go to state 55
    TE              shift and go to state 56
    DE              shift and go to state 57
    PE              shift and go to state 58
    ME              shift and go to state 59
    >               shift and go to state 60
    GE              shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    NE              shift and go to state 64
    EQ              shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 166

    (40) while_stmt -> WHILE ( expr ) compound_stmt .
    }               reduce using rule 40 (while_stmt -> WHILE ( expr ) compound_stmt .)
    BREAK           reduce using rule 40 (while_stmt -> WHILE ( expr ) compound_stmt .)
    RETURN          reduce using rule 40 (while_stmt -> WHILE ( expr ) compound_stmt .)
    FOR             reduce using rule 40 (while_stmt -> WHILE ( expr ) compound_stmt .)
    WHILE           reduce using rule 40 (while_stmt -> WHILE ( expr ) compound_stmt .)
    IF              reduce using rule 40 (while_stmt -> WHILE ( expr ) compound_stmt .)
    {               reduce using rule 40 (while_stmt -> WHILE ( expr ) compound_stmt .)
    ;               reduce using rule 40 (while_stmt -> WHILE ( expr ) compound_stmt .)
    NEW             reduce using rule 40 (while_stmt -> WHILE ( expr ) compound_stmt .)
    STRING_LIT      reduce using rule 40 (while_stmt -> WHILE ( expr ) compound_stmt .)
    CHAR_LIT        reduce using rule 40 (while_stmt -> WHILE ( expr ) compound_stmt .)
    FLOAT_LIT       reduce using rule 40 (while_stmt -> WHILE ( expr ) compound_stmt .)
    INT_LIT         reduce using rule 40 (while_stmt -> WHILE ( expr ) compound_stmt .)
    BOOL_LIT        reduce using rule 40 (while_stmt -> WHILE ( expr ) compound_stmt .)
    IDENT           reduce using rule 40 (while_stmt -> WHILE ( expr ) compound_stmt .)
    (               reduce using rule 40 (while_stmt -> WHILE ( expr ) compound_stmt .)
    SUB             reduce using rule 40 (while_stmt -> WHILE ( expr ) compound_stmt .)
    ADD             reduce using rule 40 (while_stmt -> WHILE ( expr ) compound_stmt .)
    !               reduce using rule 40 (while_stmt -> WHILE ( expr ) compound_stmt .)
    +               reduce using rule 40 (while_stmt -> WHILE ( expr ) compound_stmt .)
    -               reduce using rule 40 (while_stmt -> WHILE ( expr ) compound_stmt .)
    ELSE            reduce using rule 40 (while_stmt -> WHILE ( expr ) compound_stmt .)


state 167

    (42) if_stmt -> IF ( expr ) stmt .
    (43) if_stmt -> IF ( expr ) stmt . ELSE stmt
    }               reduce using rule 42 (if_stmt -> IF ( expr ) stmt .)
    BREAK           reduce using rule 42 (if_stmt -> IF ( expr ) stmt .)
    RETURN          reduce using rule 42 (if_stmt -> IF ( expr ) stmt .)
    FOR             reduce using rule 42 (if_stmt -> IF ( expr ) stmt .)
    WHILE           reduce using rule 42 (if_stmt -> IF ( expr ) stmt .)
    IF              reduce using rule 42 (if_stmt -> IF ( expr ) stmt .)
    {               reduce using rule 42 (if_stmt -> IF ( expr ) stmt .)
    ;               reduce using rule 42 (if_stmt -> IF ( expr ) stmt .)
    NEW             reduce using rule 42 (if_stmt -> IF ( expr ) stmt .)
    STRING_LIT      reduce using rule 42 (if_stmt -> IF ( expr ) stmt .)
    CHAR_LIT        reduce using rule 42 (if_stmt -> IF ( expr ) stmt .)
    FLOAT_LIT       reduce using rule 42 (if_stmt -> IF ( expr ) stmt .)
    INT_LIT         reduce using rule 42 (if_stmt -> IF ( expr ) stmt .)
    BOOL_LIT        reduce using rule 42 (if_stmt -> IF ( expr ) stmt .)
    IDENT           reduce using rule 42 (if_stmt -> IF ( expr ) stmt .)
    (               reduce using rule 42 (if_stmt -> IF ( expr ) stmt .)
    SUB             reduce using rule 42 (if_stmt -> IF ( expr ) stmt .)
    ADD             reduce using rule 42 (if_stmt -> IF ( expr ) stmt .)
    !               reduce using rule 42 (if_stmt -> IF ( expr ) stmt .)
    +               reduce using rule 42 (if_stmt -> IF ( expr ) stmt .)
    -               reduce using rule 42 (if_stmt -> IF ( expr ) stmt .)
    ELSE            shift and go to state 169


state 168

    (41) for_stmt -> FOR ( var_decl expr_stmt expr ) . compound_stmt
    (23) compound_stmt -> . { local_decls stmt_list }
    {               shift and go to state 110

    compound_stmt                  shift and go to state 170

state 169

    (43) if_stmt -> IF ( expr ) stmt ELSE . stmt
    (31) stmt -> . break_stmt
    (32) stmt -> . return_stmt
    (33) stmt -> . for_stmt
    (34) stmt -> . while_stmt
    (35) stmt -> . if_stmt
    (36) stmt -> . compound_stmt
    (37) stmt -> . expr_stmt
    (46) break_stmt -> . BREAK ;
    (44) return_stmt -> . RETURN expr ;
    (45) return_stmt -> . RETURN ;
    (41) for_stmt -> . FOR ( var_decl expr_stmt expr ) compound_stmt
    (40) while_stmt -> . WHILE ( expr ) compound_stmt
    (42) if_stmt -> . IF ( expr ) stmt
    (43) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (23) compound_stmt -> . { local_decls stmt_list }
    (38) expr_stmt -> . ;
    (39) expr_stmt -> . expr ;
    (49) expr -> . NEW type_spec [ expr ]
    (50) expr -> . STRING_LIT
    (51) expr -> . CHAR_LIT
    (52) expr -> . FLOAT_LIT
    (53) expr -> . INT_LIT
    (54) expr -> . BOOL_LIT
    (55) expr -> . IDENT . SIZE
    (56) expr -> . IDENT ( args )
    (57) expr -> . location
    (58) expr -> . ( expr )
    (59) expr -> . expr SUB
    (60) expr -> . expr ADD
    (61) expr -> . SUB expr
    (62) expr -> . ADD expr
    (63) expr -> . ! expr
    (64) expr -> . + expr
    (65) expr -> . - expr
    (66) expr -> . expr % expr
    (67) expr -> . expr / expr
    (68) expr -> . expr * expr
    (69) expr -> . expr - expr
    (70) expr -> . expr + expr
    (71) expr -> . expr MDE expr
    (72) expr -> . expr TE expr
    (73) expr -> . expr DE expr
    (74) expr -> . expr PE expr
    (75) expr -> . expr ME expr
    (76) expr -> . expr > expr
    (77) expr -> . expr GE expr
    (78) expr -> . expr < expr
    (79) expr -> . expr LE expr
    (80) expr -> . expr NE expr
    (81) expr -> . expr EQ expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . location = expr
    (47) location -> . IDENT [ expr ]
    (48) location -> . IDENT
    BREAK           shift and go to state 134
    RETURN          shift and go to state 136
    FOR             shift and go to state 138
    WHILE           shift and go to state 139
    IF              shift and go to state 140
    {               shift and go to state 110
    ;               shift and go to state 135
    NEW             shift and go to state 24
    STRING_LIT      shift and go to state 25
    CHAR_LIT        shift and go to state 26
    FLOAT_LIT       shift and go to state 27
    INT_LIT         shift and go to state 28
    BOOL_LIT        shift and go to state 29
    IDENT           shift and go to state 22
    (               shift and go to state 30
    SUB             shift and go to state 32
    ADD             shift and go to state 33
    !               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36

    expr                           shift and go to state 137
    stmt                           shift and go to state 171
    break_stmt                     shift and go to state 127
    return_stmt                    shift and go to state 128
    for_stmt                       shift and go to state 129
    while_stmt                     shift and go to state 130
    if_stmt                        shift and go to state 131
    compound_stmt                  shift and go to state 132
    expr_stmt                      shift and go to state 133
    location                       shift and go to state 31

state 170

    (41) for_stmt -> FOR ( var_decl expr_stmt expr ) compound_stmt .
    }               reduce using rule 41 (for_stmt -> FOR ( var_decl expr_stmt expr ) compound_stmt .)
    BREAK           reduce using rule 41 (for_stmt -> FOR ( var_decl expr_stmt expr ) compound_stmt .)
    RETURN          reduce using rule 41 (for_stmt -> FOR ( var_decl expr_stmt expr ) compound_stmt .)
    FOR             reduce using rule 41 (for_stmt -> FOR ( var_decl expr_stmt expr ) compound_stmt .)
    WHILE           reduce using rule 41 (for_stmt -> FOR ( var_decl expr_stmt expr ) compound_stmt .)
    IF              reduce using rule 41 (for_stmt -> FOR ( var_decl expr_stmt expr ) compound_stmt .)
    {               reduce using rule 41 (for_stmt -> FOR ( var_decl expr_stmt expr ) compound_stmt .)
    ;               reduce using rule 41 (for_stmt -> FOR ( var_decl expr_stmt expr ) compound_stmt .)
    NEW             reduce using rule 41 (for_stmt -> FOR ( var_decl expr_stmt expr ) compound_stmt .)
    STRING_LIT      reduce using rule 41 (for_stmt -> FOR ( var_decl expr_stmt expr ) compound_stmt .)
    CHAR_LIT        reduce using rule 41 (for_stmt -> FOR ( var_decl expr_stmt expr ) compound_stmt .)
    FLOAT_LIT       reduce using rule 41 (for_stmt -> FOR ( var_decl expr_stmt expr ) compound_stmt .)
    INT_LIT         reduce using rule 41 (for_stmt -> FOR ( var_decl expr_stmt expr ) compound_stmt .)
    BOOL_LIT        reduce using rule 41 (for_stmt -> FOR ( var_decl expr_stmt expr ) compound_stmt .)
    IDENT           reduce using rule 41 (for_stmt -> FOR ( var_decl expr_stmt expr ) compound_stmt .)
    (               reduce using rule 41 (for_stmt -> FOR ( var_decl expr_stmt expr ) compound_stmt .)
    SUB             reduce using rule 41 (for_stmt -> FOR ( var_decl expr_stmt expr ) compound_stmt .)
    ADD             reduce using rule 41 (for_stmt -> FOR ( var_decl expr_stmt expr ) compound_stmt .)
    !               reduce using rule 41 (for_stmt -> FOR ( var_decl expr_stmt expr ) compound_stmt .)
    +               reduce using rule 41 (for_stmt -> FOR ( var_decl expr_stmt expr ) compound_stmt .)
    -               reduce using rule 41 (for_stmt -> FOR ( var_decl expr_stmt expr ) compound_stmt .)
    ELSE            reduce using rule 41 (for_stmt -> FOR ( var_decl expr_stmt expr ) compound_stmt .)


state 171

    (43) if_stmt -> IF ( expr ) stmt ELSE stmt .
    }               reduce using rule 43 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    BREAK           reduce using rule 43 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    RETURN          reduce using rule 43 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    FOR             reduce using rule 43 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    WHILE           reduce using rule 43 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    IF              reduce using rule 43 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    {               reduce using rule 43 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    ;               reduce using rule 43 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    NEW             reduce using rule 43 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    STRING_LIT      reduce using rule 43 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    CHAR_LIT        reduce using rule 43 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    FLOAT_LIT       reduce using rule 43 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    INT_LIT         reduce using rule 43 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    BOOL_LIT        reduce using rule 43 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    IDENT           reduce using rule 43 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    (               reduce using rule 43 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    SUB             reduce using rule 43 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    ADD             reduce using rule 43 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    !               reduce using rule 43 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    +               reduce using rule 43 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    -               reduce using rule 43 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    ELSE            reduce using rule 43 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
